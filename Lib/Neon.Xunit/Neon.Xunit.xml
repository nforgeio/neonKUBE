<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Xunit</name>
    </assembly>
    <members>
        <member name="T:Neon.Xunit.AnsiblePlayer">
            <summary>
            Used for running Ansible playbooks within unit tests.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.PlayInFolder(System.String,System.String,System.String[])">
            <summary>
            <para>
            Plays a playbook within a specific working directory using <b>neon ansible play -- [args] playbook</b>.
            </para>
            <note>
            This method will have Ansible gather facts by default which can be quite slow.
            Consider using <see cref="M:Neon.Xunit.AnsiblePlayer.PlayInFolderNoGather(System.String,System.String,System.String[])"/> instead
            for unit tests that don't required the facts.
            </note>
            </summary>
            <param name="workDir">The playbook working directory (or <c>null</c> to use a temporary folder).</param>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.Play(System.String,System.String[])">
            <summary>
            <para>
            Plays a playbook within a temporary directory using <b>neon ansible play -- [args] playbook</b>.
            </para>
            <note>
            This method will have Ansible gather facts by default which can be quite slow.
            Consider using <see cref="M:Neon.Xunit.AnsiblePlayer.PlayNoGather(System.String,System.String[])"/> instead
            for unit tests that don't required the facts.
            </note>
            </summary>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.PlayInFolderNoGather(System.String,System.String,System.String[])">
            <summary>
            Plays a playbook without gathering facts by default within a specific working directory using 
            <b>neon ansible play -- [args] playbook</b>.
            </summary>
            <param name="workDir">The playbook working directory (or <c>null</c> to use a temporary folder).</param>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            <para>
            This method will add <b>gather_facts: no</b> to the playbook when
            this argument isn't already present.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayer.PlayNoGather(System.String,System.String[])">
            <summary>
            Plays a playbook without gathering facts by default within a temporary directory using 
            <b>neon ansible play -- [args] playbook</b>.
            </summary>
            <param name="playbook">The playbook text.</param>
            <param name="args">Optional command line arguments to be included in the command.</param>
            <returns>An <see cref="T:Neon.Xunit.AnsiblePlayResults"/> describing what happened.</returns>
            <remarks>
            <note>
            Use this method for playbooks that need to read or write files.
            </note>
            <para>
            This method will add <b>gather_facts: no</b> to the playbook when
            this argument isnt already present.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.AnsiblePlayResults">
            <summary>
            Holds the results from an <see cref="T:Neon.Xunit.AnsiblePlayer"/> play operation.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayResults.#ctor(Neon.Common.ExecuteResponse)">
            <summary>
            Constructs an instance from the execution results of an
            <see cref="T:Neon.Xunit.AnsiblePlayer"/> play operation.
            </summary>
            <param name="rawResults">The execution results.</param>
        </member>
        <member name="P:Neon.Xunit.AnsiblePlayResults.RawResults">
            <summary>
            Returns the raw execution results.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsiblePlayResults.TaskResults">
            <summary>
            Returns the list of <see cref="T:Neon.Xunit.AnsibleTaskResult"/> instance in the order
            of execution.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsiblePlayResults.GetTaskResult(System.String)">
            <summary>
            Returns the first <see cref="T:Neon.Xunit.AnsibleTaskResult"/> for a named task.
            </summary>
            <param name="taskName">The task name.</param>
            <returns>The <see cref="T:Neon.Xunit.AnsibleTaskResult"/> or <c>null</c> if the named task was not found.</returns>
            <remarks>
            <note>
            Ansible does not enforce task name uniqueness, so it's possible
            to have more than one task sharing the same name.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.AnsibleTaskResult">
            <summary>
            Holds the results for a specific task executed in an Ansible playbook.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AnsibleTaskResult.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="rawTaskResults">The raw Ansible task results.</param>
            <remarks>
            <para>
            We're expecting <paramref name="rawTaskResults"/> to include the lines
            starting with:
            </para>
            <code>
            TASK [name] ******
            </code>
            <para>
            and then continuing up to the next task start line or the play recap line:
            </para>
            <code>
            PLAY RECAP ******
            </code>
            </remarks>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.RawResults">
            <summary>
            Returns the raw task results.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.HasStatus">
            <summary>
            Returns <c>true</c> for tasks that returned JSON status.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.TaskName">
            <summary>
            Returns the task name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.Success">
            <summary>
            Returns <c>true</c> if the task succeeded.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.Changed">
            <summary>
            Returns <c>true</c> if the task made any changes.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.OutputText">
            <summary>
            Returns the standard output text from the task.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.ErrorText">
            <summary>
            Returns the standard error text from the task.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AnsibleTaskResult.Message">
            <summary>
            Returns the error message (if any).
            </summary>
        </member>
        <member name="T:Neon.Xunit.CollectionComparer`1">
            <summary>
            Compares two collections for strict equality by ensuring they
            have the same items in the same order.
            </summary>
            <typeparam name="T">The collection item type.</typeparam>
        </member>
        <member name="M:Neon.Xunit.CollectionComparer`1.Equals(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns true if two collections are identical.
            </summary>
            <param name="collection1">Collection #1.</param>
            <param name="collection2">Collection #2</param>
            <returns><c>true</c> if the collections are identical.</returns>
        </member>
        <member name="M:Neon.Xunit.CollectionComparer`1.GetHashCode(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Not implemented.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Neon.Xunit.AspNetFixture">
            <summary>
            Fixture for testing ASP.NET Core based websites and services.
            </summary>
        </member>
        <member name="T:Neon.Xunit.AspNetFixture.LoggingProvider">
            <summary>
            Handles site logging if enabled below.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.JsonClient">
            <summary>
            Returns a <see cref="P:Neon.Xunit.AspNetFixture.JsonClient"/> suitable for querying the service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.HttpClient">
            <summary>
            Returns an <see cref="P:Neon.Xunit.AspNetFixture.HttpClient"/> suitable for querying the service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.BaseAddress">
            <summary>
            Returns the base URI for the running service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.AspNetFixture.WebHost">
            <summary>
            Returns the service's <see cref="T:Microsoft.AspNetCore.Hosting.IWebHost"/>.
            </summary>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Start``1(System.Action{Microsoft.AspNetCore.Hosting.IWebHostBuilder},System.Int32,Neon.Xunit.TestOutputWriter,Neon.Diagnostics.LogLevel)">
             <summary>
             <para>
             Starts the ASP.NET service using the default controller factory.
             </para>
             <note>
             You'll need to call <see cref="M:Neon.Xunit.AspNetFixture.StartAsComposed``1(System.Action{Microsoft.AspNetCore.Hosting.IWebHostBuilder},System.Int32,Neon.Xunit.TestOutputWriter,Neon.Diagnostics.LogLevel)"/>
             instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
             </note>
             </summary>
             <typeparam name="TStartup">The startup class for the service.</typeparam>
             <param name="hostConfigurator">Optional action providing for customization of the hosting environment.</param>
             <param name="port">The port where the server will listen or zero to allow the operating system to select a free port.</param>
             <param name="logWriter">Optionally specifies a test output writer.</param>
             <param name="logLevel">Optionally specifies the log level.  This defaults to <see cref="F:Neon.Diagnostics.LogLevel.None"/>.</param>
             <remarks>
             <para>
             You can capture ASP.NET and service logs into your unit test logs by passing <paramref name="logWriter"/> as 
             non-null and <paramref name="logLevel"/> as something other than <see cref="F:Neon.Diagnostics.LogLevel.None"/>.  You'll need
             to obtain a <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> instance from Xunit via dependency injection by adding a parameter
             to your test constructor and then creating a <see cref="T:Neon.Xunit.TestOutputWriter"/> from it, like:
             </para>
             <code language="c#">
             public class MyTest : IClassFixture&lt;AspNetFixture&gt;
             {
                 private AspNetFixture               fixture;
                 private TestAspNetFixtureClient     client;
                 private TestOutputWriter            testWriter;
            
                 public Test_EndToEnd(AspNetFixture fixture, ITestOutputHelper outputHelper)
                 {
                     this.fixture    = fixture;
                     this.testWriter = new TestOutputWriter(outputHelper);
            
                     fixture.Start&lt;Startup&gt;(logWriter: testWriter, logLevel: Neon.Diagnostics.LogLevel.Debug);
            
                     client = new TestAspNetFixtureClient()
                     {
                         BaseAddress = fixture.BaseAddress
                     };
                  }
             }
             </code>
             </remarks>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.StartAsComposed``1(System.Action{Microsoft.AspNetCore.Hosting.IWebHostBuilder},System.Int32,Neon.Xunit.TestOutputWriter,Neon.Diagnostics.LogLevel)">
             <summary>
             Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
             </summary>
             <typeparam name="TStartup">The startup class for the service.</typeparam>
             <param name="hostConfigurator">Optional action providing for customization of the hosting environment.</param>
             <param name="port">The port where the server will listen or zero to allow the operating system to select a free port.</param>
             <param name="logWriter">Optionally specifies a test output writer.</param>
             <param name="logLevel">Optionally specifies the log level.  This defaults to <see cref="F:Neon.Diagnostics.LogLevel.None"/>.</param>
             <remarks>
             <para>
             You can capture ASP.NET and service logs into your unit test logs by passing <paramref name="logWriter"/> as 
             non-null and <paramref name="logLevel"/> as something other than <see cref="F:Neon.Diagnostics.LogLevel.None"/>.  You'll need
             to obtain a <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> instance from Xunit via dependency injection by adding a parameter
             to your test constructor and then creating a <see cref="T:Neon.Xunit.TestOutputWriter"/> from it, like:
             </para>
             <code language="c#">
             public class MyTest : IClassFixture&lt;AspNetFixture&gt;
             {
                 private AspNetFixture               fixture;
                 private TestAspNetFixtureClient     client;
                 private TestOutputWriter            testWriter;
            
                 public Test_EndToEnd(AspNetFixture fixture, ITestOutputHelper outputHelper)
                 {
                     this.fixture    = fixture;
                     this.testWriter = new TestOutputWriter(outputHelper);
            
                     fixture.Start&lt;Startup&gt;(logWriter: testWriter, logLevel: Neon.Diagnostics.LogLevel.Debug);
            
                     client = new TestAspNetFixtureClient()
                     {
                         BaseAddress = fixture.BaseAddress
                     };
                  }
             }
             </code>
             </remarks>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.StartServer``1(System.Int32)">
            <summary>
            Starts the service using the default controller factory.
            </summary>
            <param name="port">The port where the server will listen.</param>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Restart``1">
            <summary>
            Restarts the web service.
            </summary>
            <typeparam name="TStartup">Specifies the web service startup class.</typeparam>
        </member>
        <member name="M:Neon.Xunit.AspNetFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Xunit.CodeFixture">
            <summary>
            Used to execute some custom code while <see cref="T:Neon.Xunit.ComposedFixture"/> is starting
            subfixtures.  This is typically used to perform additional configuration of a
            <see cref="T:Neon.Service.ServiceMap"/>, etc. to configure components like <see cref="T:Neon.Service.NeonService"/>
            instances for integration testing.
            </summary>
            <remarks>
            <para>
            A common use case for this is to deploy a cluster of services in-process with databases
            and/or workflow engines deployed as local Docker containers by other test fixtures.  The
            idea is to add a <see cref="T:Neon.Xunit.CodeFixture"/> via <see cref="M:Neon.Xunit.ComposedFixture.AddFixture``1(System.String,``0,System.Action{``0},System.Int32)"/>,
            passing the <see cref="T:System.Action"/> as a function that performs any custom configuration.
            </para>
            <note>
            <see cref="T:Neon.Xunit.CodeFixture"/> really doesn't do anything by itself.  It's purpose is simply 
            to provide a mechanism for adding and executing your custom code to the <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            <para>
            You action code can then do things like initialize the database schema and test data
            as well as initializing a <see cref="T:Neon.Service.ServiceMap"/> by setting the environment variables
            and configuration files for any <see cref="T:Neon.Service.NeonService"/> instances that will also be
            deployed for the test.  Many integration test scenarios follow this pattern:
            </para>
            <list type="number">
                <item>
                Implement a unit test derived from <c>IClassFixture&lt;ComposedFixture&gt;</c>.
                </item>
                <item>
                In the test constructor, add any database and/or workflow engine fixtures as
                <b>group=0</b>.  These fixtures will start in parallel and will be running 
                before any fixtures in subsequent groups are started.
                </item>
                <item>
                Then add a <see cref="T:Neon.Xunit.CodeFixture"/> to the cluster fixture via
                <see cref="M:Neon.Xunit.ComposedFixture.AddFixture``1(System.String,``0,System.Action{``0},System.Int32)"/>,
                passing your action as <b>group=1</b>.
                </item>
                <item>
                Your action should perform any custom configuration.
                </item>
                <item>
                Add your <see cref="T:Neon.Service.NeonService"/> and/or other fixtures as <b>group=2</b> or beyond,
                as required.
                </item>
            </list>
            <para>
            So when the <see cref="T:Neon.Xunit.ComposedFixture"/> starts, it'll start the database/workflow engine
            fixtures first as <b>group=0</b> and then start your <see cref="T:Neon.Xunit.CodeFixture"/> as <b>group=1</b>
            and your custom action can initialize the database and perhaps configure a <see cref="T:Neon.Service.ServiceMap"/>.
            Once your action has returned, <see cref="T:Neon.Xunit.ComposedFixture"/> will start the fixtures in any
            remaining groups with a configured database and <see cref="T:Neon.Service.ServiceMap"/> before the test framework
            starts executing your tests cases.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.CodeFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.CodeFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.CodeFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.CodeFixture.Reset">
            <summary>
            <b>INTERNAL USE ONLY:</b> Resets the fixture state.
            </summary>
        </member>
        <member name="T:Neon.Xunit.ComposedFixture">
            <summary>
            Implements an <see cref="T:Neon.Xunit.ITestFixture"/> that is composed of other test
            fixtures.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests : IClassFixture&lt;ComposedFixture&gt;, IDisposable
            {
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            <para>
            Derived test fixtures that modify global machine or other environmental state
            must implement a <c>public static void EnsureReset()</c> method resets the state
            to a reasonable default.  These will be reflected and called when the first
            <see cref="T:Neon.Xunit.TestFixture"/> is created by the test runner for every test class.
            </para>
            <para><b>INTEGRATION TESTING</b></para>
            <para>
            One use case we've found valuable is to use <see cref="T:Neon.Xunit.ComposedFixture"/> to enulate
            an entire cluster of services as a unit test or in a console application.  The idea
            is to have the unit test or console app code reference all of your service assemblies
            and then add these services to a <see cref="T:Neon.Xunit.ComposedFixture"/> as well as any database
            and/or workflow engines and then start the composed fixtures.
            </para>
            <para>
            This can require a lot of memory and CPU, but it can be really nice to have an entire
            service running in Visual Studio where you can set breakpoints anywhere.  We've emulated
            clusters with well over 75 services this way.
            </para>
            <para>
            One of the problems we encountered is that it can take several minutes for the all of
            the services and other subfixtures to start because they are started one at a time
            by default.  We've enhanced this class so that you can optionally start groups of 
            subfixtures in parallel via the optional <c>group</c> parameter.  By default,
            this is passed as <b>-1</b>, indicating that subfixtures with <c>group=-1</c> will
            be started one at a time in the group they were added to the <see cref="T:Neon.Xunit.ComposedFixture"/>
            and these will be started before any other fixtures.  This results in the same behavior
            as older versions of the fixture.
            </para>
            <para>
            Fixtures added with <c>group</c> passed as zero or a positive number are started when
            you call <see cref="M:Neon.Xunit.ComposedFixture.Start(System.Action)"/>.  This starts the subfixtures in the same group in
            parallel with any others in the group.  Note that we'll start at the lowest group number 
            and wait for all fixtures to start before moving on to the next group.
            </para>
            <para>
            <see cref="T:Neon.Xunit.CodeFixture"/> can be used as a way to inject custom code what will
            be executed while <see cref="T:Neon.Xunit.ComposedFixture"/> is starting subfixtures.  The basic
            idea is to add things like database fixtures as <b>group=0</b> and then add a
            <see cref="T:Neon.Xunit.CodeFixture"/> with a custom action as <b>group=1</b> followed by
            <see cref="T:Neon.Xunit.NeonServiceFixture`1"/> and/or other fixtures as <b>group=2+</b>.
            </para>
            <para>
            Then the <see cref="T:Neon.Xunit.ComposedFixture"/> will start the database first, followed by the
            <see cref="T:Neon.Xunit.CodeFixture"/> where the action has an opportunity to initialize the database
            before the remaining fixtures are started.
            </para>
            </remarks>
            <threadsafety instance="false"/>
        </member>
        <member name="T:Neon.Xunit.ComposedFixture.SubFixture">
            <summary>
            Holds information about a NeonServ subfixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.SubFixture.#ctor(Neon.Xunit.ITestFixture,System.Object,System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Constructor for non-<see cref="T:Neon.Xunit.NeonServiceFixture`1"/> fixtures.
            </summary>
            <param name="fixture">The subfixture.</param>
            <param name="actionTarget">The optional fixture action instance.</param>
            <param name="actionMethod">The optional fixture action method.</param>
            <param name="group">The fixture group.</param>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.SubFixture.#ctor(Neon.Xunit.ITestFixture,System.Object,Neon.Service.ServiceMap,System.TimeSpan,System.Int32)">
            <summary>
            Constructor for <see cref="T:Neon.Xunit.NeonServiceFixture`1"/> fixtures.
            </summary>
            <param name="fixture">The subfixture.</param>
            <param name="serviceCreator">The service creator function as an object.</param>
            <param name="serviceMap">Specifies the service map, if any.</param>
            <param name="startTimeout">Specifies the maximum time to wait for the service to transition to the running state.</param>
            <param name="group">The fixture group.</param>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.AddFixture``1(System.String,``0,System.Action{``0},System.Int32)">
            <summary>
            Adds a named <see cref="T:Neon.Xunit.ITestFixture"/>.
            </summary>
            <typeparam name="TFixture">The new fixture type.</typeparam>
            <param name="name">The fixture name (case insenstitive).</param>
            <param name="subFixture">The subfixture instance.</param>
            <param name="action">
            The optional <see cref="T:System.Action"/> to be called when the fixture is initialized.  This can
            be used for things like waiting until the service is actually ready before returning.
            </param>
            <param name="group">
            Optionally specifies the fixture group.  Fixtures with <paramref name="group"/><c>=-1</c> (the default)
            will be started one by one before all other fixtures.  Fixtures with a <c>group >= 0</c> will
            be started in parallel by group starting at the lowest group.  All of the fixtures in the same
            group will be started in parallel on separate threads and the <see cref="T:Neon.Xunit.ComposedFixture"/> will
            wait until all fixtures in a group have started before advancing to the next group.
            </param>
            <remarks>
            <note>
            This method doesn't work for <see cref="T:Neon.Xunit.NeonServiceFixture`1"/> based fixtures.  Use
            <see cref="M:Neon.Xunit.ComposedFixture.AddServiceFixture``1(System.String,Neon.Xunit.NeonServiceFixture{``0},System.Func{``0},Neon.Service.ServiceMap,System.TimeSpan,System.Int32)"/> instead.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.AddServiceFixture``1(System.String,Neon.Xunit.NeonServiceFixture{``0},System.Func{``0},Neon.Service.ServiceMap,System.TimeSpan,System.Int32)">
            <summary>
            Adds a named <see cref="T:Neon.Xunit.NeonServiceFixture`1"/> fixture.
            </summary>
            <typeparam name="TService">The service type (derived from <see cref="T:Neon.Service.NeonService"/>).</typeparam>
            <param name="name">The fixture name (case insenstitive).</param>
            <param name="subFixture">The subfixture being added.</param>
            <param name="serviceCreator">
            <para>
            Callback that creates and returns the new service instance.
            </para>
            </param>
            <param name="serviceMap">
            Optionally specifies a <see cref="T:Neon.Service.ServiceMap"/>.  When a service map is passed and there's
            a <see cref="T:Neon.Service.ServiceDescription"/> for the created service, then the fixture will configure
            the service with <see cref="P:Neon.Service.ServiceDescription.TestEnvironmentVariables"/>, <see cref="P:Neon.Service.ServiceDescription.TestBinaryConfigFiles"/>,
            and <see cref="P:Neon.Service.ServiceDescription.TestTextConfigFiles"/> before starting the service.
            </param>
            <param name="startTimeout">
            Optionally specifies maximum time to wait for the service to transition to the running state.
            </param>
            <param name="group">
            Optionally specifies the fixture group.  Fixtures with <paramref name="group"/><c>=-1</c> (the default)
            will be started one by one before all other fixtures.  Fixtures with a <c>group >= 0</c> will
            be started in parallel by group starting at the lowest group.  All of the fixtures in the same
            group will be started in parallel on separate threads and the <see cref="T:Neon.Xunit.ComposedFixture"/> will
            wait until all fixtures in a group have started before advancing to the next group.
            </param>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Start(System.Action)">
            <summary>
            Starts the fixture if it hasn't already been started including invoking the optional
            <see cref="T:System.Action"/> when the first time <see cref="M:Neon.Xunit.ComposedFixture.Start(System.Action)"/> is called for
            a fixture instance.
            </summary>
            <param name="action">
            <para>
            The optional custom start action.
            </para>
            <note>
            This is generally intended for use when developing custom test fixtures.
            </note>
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this is called from within the <see cref="T:System.Action"/>.</exception>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Children">
            <summary>
            Returns the subfixtures.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Item(System.String)">
            <summary>
            Returns the named test fixture.
            </summary>
            <param name="name">The fixture name (case insensitive).</param>
            <returns>The test fixture.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the named fixture does not exist.</exception>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Item(System.Int32)">
            <summary>
            Returns the fixture at the specified index (based on the order
            the fixture was added).
            </summary>
            <param name="index">Specfies the index of the desired fixture.</param>
            <returns>The test fixture.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Thrown if <paramref name="index"/> is outside the range of valid indexes.</exception>
        </member>
        <member name="P:Neon.Xunit.ComposedFixture.Count">
            <summary>
            Returns the number of fixtures in the set.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Dispose(System.Boolean)">
            <summary>
            Disposes all fixtures in the set.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.GetEnumerator">
            <summary>
            Enumerates the named test fixtures in the set.
            </summary>
            <returns>The fixtures as <c>KeyValuePair&lt;string, ITestFixture&gt;</c> instances.</returns>
        </member>
        <member name="M:Neon.Xunit.ComposedFixture.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the named test fixtures in the set.
            </summary>
            <returns>The fixtures as <c>KeyValuePair&lt;string, ITestFixture&gt;</c> instances.</returns>
        </member>
        <member name="T:Neon.Xunit.ContainerFixture">
            <summary>
            Used to run a Docker container on the current machine as a test 
            fixture while tests are being performed and then deletes the
            container when the fixture is disposed.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests : IClassFixture&lt;ontainerFixture&gt;, IDisposable
            {
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="P:Neon.Xunit.ContainerFixture.DefaultHostInterface">
            <summary>
            Specifies the IP address of host interface where container ports
            will be published.  This defaults to <b>0.0.0.0</b> which binds
            ports to all network interfaces.
            </summary>
            <remarks>
            <para>
            You may need to customize this to avoid port conflicts with other
            running applications.  When all tests are running on a single host,
            you should consider setting this to one of the 16 million loopback
            addresses in the <b>127.0.0.0/8</b> subnet (e.g. 127.0.0.1, 127.0.0.2,
            etc).  You'll need to set this before starting any fixture containers.
            </para>
            <note>
            Fixtures implemented by neonFORGE that are derived from <see cref="T:Neon.Xunit.ContainerFixture"/> 
            all implement this behavior.  If you implement your own derived fixtures,
            you should consider implementing this as well for consistency.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.GetHostInterface(System.String,System.Boolean)">
            <summary>
            Used by derived fixtures to retrieve the host network interface address for the docker
            <b>-p</b> port publish option or the address to use for establishing a Cadence connections.
            interfaces.
            </summary>
            <param name="hostInterface">The desired host interface IPv4 address or <c>null</c>.</param>
            <param name="forConnection">
            Indicates that the address a client should use to establish a connection should be 
            returned vs. the address the container will listen on.
            </param>
            <returns>The target network interface address.</returns>
            <remarks>
            This method returns <see cref="P:Neon.Xunit.ContainerFixture.DefaultHostInterface"/> when <paramref name="hostInterface"/>
            is <c>null</c> or empty otherwise it will ensure that the parameter is valid
            and before returning it.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerFixture.ContainerName">
            <summary>
            Returns the running container's name or <c>null</c> if the container
            has not been started.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerFixture.ContainerId">
            <summary>
            Returns the running container's short ID or <c>null</c> if the container
            has not been started.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Start(System.String,System.String,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,Neon.Xunit.ContainerLimits)">
            <summary>
            <para>
            Starts the container.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.ContainerFixture.StartAsComposed(System.String,System.String,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,Neon.Xunit.ContainerLimits)"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="name">Specifies the container name.</param>
            <param name="image">Specifies the container Docker image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker run ...</b> command.</param>
            <param name="containerArgs">Optional arguments to be passed to the container.</param>
            <param name="env">Optional environment variables to be passed to the Couchbase container, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <param name="noRemove">Optionally indicates that the <b>--rm</b> option should not be included when creating the container.</param>
            <param name="keepOpen">
            Optionally indicates that the container should continue to run after the fixture is disposed.  
            This implies <see cref="F:Neon.Xunit.ContainerFixture.noRemove"/><c>=true</c> and defaults to <c>false</c>.
            </param>
            <param name="limits">Optionally specifies the Docker container resource limits.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is not called from  within the <see cref="T:System.Action"/> method 
            passed <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            </exception>
            <remarks>
            <note>
            You must specify a valid container <paramref name="name"/>so that the fixure
            can remove any existing container with the same name before starting the new container.
            This is very useful during test debugging when the test might be interrupted during 
            debugging before ensuring that the container is stopped.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.StartAsComposed(System.String,System.String,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,Neon.Xunit.ContainerLimits)">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="name">Specifies the container name.</param>
            <param name="image">Specifies the container Docker image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker run ...</b> command.</param>
            <param name="containerArgs">Optional arguments to be passed to the container.</param>
            <param name="env">Optional environment variables to be passed to the Couchbase container, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <param name="noRemove">Optionally indicates that the <b>--rm</b> option should not be included when creating the container.</param>
            <param name="keepOpen">
            Optionally indicates that the container should continue to run after the fixture is disposed.  
            This implies <see cref="F:Neon.Xunit.ContainerFixture.noRemove"/><c>=true</c> and defaults to <c>true</c>.
            </param>
            <param name="limits">Optionally specifies Docker container resource limits.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is not called from  within the <see cref="T:System.Action"/> method 
            passed <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            </exception>
            <remarks>
            <note>
            You must specify a valid container <paramref name="name"/>so that the fixure
            can remove any existing container with the same name before starting the new container.
            This is very useful during test debugging when the test might be interrupted during 
            debugging before ensuring that the container is stopped.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.StartContainer">
            <summary>
            Starts the container using the instance fields.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.ContainerFixture.Restart">
            <summary>
            Restarts the container.  This is a handy way to deploy a fresh container with the
            same properties while running unit tests.
            </summary>
        </member>
        <member name="T:Neon.Xunit.ContainerLimits">
            <summary>
            <para>
            Used by same Docker related (and derived) fixtures to limit the machine 
            resources that can be consumed by managed containers.  We support many
            of the limits described in detail bere:
            </para>
            <para>
            <a href="https://docs.docker.com/config/containers/resource_constraints/">https://docs.docker.com/config/containers/resource_constraints/</a>
            </para>
            <note>
            Byte size properties like <see cref="P:Neon.Xunit.ContainerLimits.Memory"/> are strings including the
            size (a <c>double</c>) along with an optional unit designation from
            <see cref="T:Neon.Common.ByteUnits"/> like <b>KiB</b>, <b>MiB</b>, and <b>GiB</b> rather 
            than using the Docker unit conventions for consistency with neonKUBE
            cluster definitions, etc.  These values will be converted to a simple 
            byte count before passing them on to Docker.
            </note>
            <note>
            We're currently implementing some memory limits along with one CPU limit.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerLimits.Memory">
            <summary>
            Optionally specifies the maximum memory that can be allocated to the
            container.  The minimum value is <b>4MiB</b>.  The default value is
            unconstrained.
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerLimits.MemorySwap">
            <summary>
            <para>
            The amount of memory the container is allowed to swap to disk.  This
            required <see cref="P:Neon.Xunit.ContainerLimits.Memory"/> to be also set to have any effect.  See
            the Docker documentation for more details on how this works:
            </para>
            <para>
            <a href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swap-details">https://docs.docker.com/config/containers/resource_constraints/#--memory-swap-details</a>
            </para>
            <para>
            
            </para>
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerLimits.MemorySwappiness">
            <summary>
            <para>
            The percentage of anonymous memory pages used by the container that may
            be swapped to disk.  This is an integer number between 0..100.  See the
            Docker documentation for more details on how this works:
            </para>
            <para>
            <a href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details">https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details</a>
            </para>
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerLimits.MemoryReservation">
            <summary>
            <para>
            Specifies a lower soft limit on memory than <see cref="P:Neon.Xunit.ContainerLimits.Memory"/> when Docker
            detects contention or low memory on the host.  <see cref="P:Neon.Xunit.ContainerLimits.Memory"/> must also
            be set and <see cref="P:Neon.Xunit.ContainerLimits.MemoryReservation"/> must be less than that for this
            to have any effect.
            </para>
            <note>
            Because it is a soft limit, it does not guarantee that the container doesnt
            exceed this value.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerLimits.KernelMemory">
            <summary>
            <para>
            The minimum amount of kernel memory the container can use.  Setting this can
            prevent the container from obtaining so much kernel memory that other machine
            level components are impacted.  The minimum value is <b>4MiB</b> and the default
            is unconstrained.  See the Docker documentation for more details on how this works:
            </para>
            <para>
            <a href="https://docs.docker.com/config/containers/resource_constraints/#--kernel-memory-details">https://docs.docker.com/config/containers/resource_constraints/#--kernel-memory-details</a>
            </para>
            </summary>
        </member>
        <member name="P:Neon.Xunit.ContainerLimits.OomKillDisable">
            <summary>
            <para>
            By default, the host machine's OOM killer will kill processes in a container
            when the host runs out of memory (OOM).  You can disable this behavior by setting
            this to <c>true</c>.  This defaults to <c>false</c>.
            </para>
            <note>
            <para>
            **WARNING:** You should also set <see cref="P:Neon.Xunit.ContainerLimits.Memory"/> when enabling this to 
            help prevent the OOM killer from killing important host level processes.
            </para>
            <para>
            <see cref="M:Neon.Xunit.ContainerLimits.Validate"/> will check for this condition.
            </para>
            </note>
            </summary>
        </member>
        <member name="M:Neon.Xunit.ContainerLimits.Validate">
            <summary>
            Verifies that the limit properties make sense.
            </summary>
            <returns><c>null</c> for valid properties, otherwise an error message.</returns>
        </member>
        <member name="T:Neon.Xunit.DockerComposeFixture">
            <summary>
            <para>
            Used to run a <b>docker-compose</b> application on the current machine as a test 
            fixture while tests are being performed and then deletes the applicatiuon when 
            the fixture is disposed.
            </para>
            <note>
            The <see cref="T:Neon.Xunit.DockerComposeFixture"/> and <see cref="T:Neon.Xunit.DockerFixture"/> fixtures are
            not compatible with each other.  You may only use one of these at a time.
            </note>
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests : IClassFixture&lt;DockerComposeFixture&gt;, IDisposable
            {
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.StopApplication(System.String,System.String[])">
            <summary>
            Stops any existing docker-compose application running with the same name passed.
            </summary>
            <param name="name">The application name.</param>
            <param name="customContainerNames">
            Optionally specifies custom container names deployed by the Docker Compose file that
            will not be prefixed by the application name.  The fixture needs to know these so
            it can remove the containers when required.
            </param>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerComposeFixture.ApplicationName">
            <summary>
            Returns the running application name or <c>null</c> if the compose file
            has not been started.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.Start(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            <para>
            Starts the fixture by running a Docker compose application.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.DockerComposeFixture.StartAsComposed(System.String,System.String,System.Boolean,System.String[])"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="name">Specifies the application name.</param>
            <param name="composeFile">Specifies the contents of the <b>docker-compose.yml</b> file defining the application.</param>
            <param name="keepOpen">
            Optionally indicates that the application should continue to run after the fixture is disposed.  
            This defaults to <c>false</c>.
            </param>
            <param name="customContainerNames">
            Optionally specifies custom container names deployed by the Docker Compose file that
            will not be prefixed by the application name.  The fixture needs to know these so
            it can remove the containers when required.
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is not called from  within the <see cref="T:System.Action"/> method 
            passed <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            </exception>
            <remarks>
            <note>
            You must specify a valid application <paramref name="name"/> so that the fixure
            can remove any existing application with the same name before starting the new instance
            of the application.  This is very useful during test debugging when the test might be 
            interrupted during debugging or when <paramref name="keepOpen"/><c>=true</c>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.StartAsComposed(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="name">Specifies the application name.</param>
            <param name="composeFile">Specifies the contents of the <b>docker-compose.yml</b> file defining the application.</param>
            <param name="keepOpen">
            Optionally indicates that the application should continue to run after the fixture is disposed.  
            This defaults to <c>false</c>.
            </param>
            <param name="customContainerNames">
            Optionally specifies custom container names deployed by the Docker Compose file that
            will not be prefixed by the application name.  The fixture needs to know these so
            it can remove the containers when required.
            </param>
            <exception cref="T:System.InvalidOperationException">
            Thrown if this is not called from  within the <see cref="T:System.Action"/> method 
            passed <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            </exception>
            <remarks>
            <note>
            You must specify a valid application <paramref name="name"/> so that the fixure
            can remove any existing application with the same name before starting the new instance
            of the application.  This is very useful during test debugging when the test might be 
            interrupted during debugging or when <paramref name="keepOpen"/><c>=true</c>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.StartApplication">
            <summary>
            Starts the application using the instance fields.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.DockerComposeFixture.Restart">
            <summary>
            Restarts the application.  This is a handy way to deploy a fresh instance with the
            same properties while running unit tests.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture">
            <summary>
            <para>
            An Xunit test fixture used to manage a local Docker daemon within unit tests.
            </para>
            <note>
            The <see cref="T:Neon.Xunit.DockerComposeFixture"/> and <see cref="T:Neon.Xunit.DockerFixture"/> fixtures are
            not compatible with each other.  You may only use one of these at a time.
            </note>
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests : IClassFixture&lt;DockerFixture&gt;, IDisposable
            {
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            <para>
            This fixture resets the state of the local Docker daemon before and after
            the test runner executes the tests in a test class by removing all containers
            and services as well as swarm items such as secrets, configs and networks.
            </para>
            <note>
            This fixture works only for local Docker instances that <b>ARE NOT</b>
            members of a multi-node cluster as a safety measure to help avoid the
            possiblity of accidentially wiping out a production cluster.
            </note>
            <note>
            The fixture <see cref="M:Neon.Xunit.DockerFixture.Reset"/> method does not purge images from the target
            test node for performance reasons.  This can be a problem if you're testing
            container and you need to ensure that the latest image is downloaded from
            the registry first.  You can call <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/> to accomplish
            this or <see cref="M:Neon.Xunit.DockerFixture.PullImage(System.String)"/> to pull a specific image from the registry.
            </note>
            <para>
            This fixture is pretty easy to use.  Simply have your test class inherit
            from <see cref="T:Xunit.IClassFixture`1"/> and add a public constructor
            that accepts a <see cref="T:Neon.Xunit.DockerFixture"/> as the only argument.  Then
            you can call it's <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/> method
            within the constructor and optionally have your custom <see cref="T:System.Action"/>
            use the fixture to initialize swarm services, networks, secrets, etc.
            </para>
            <para>
            This fixture provides several methods for managing the cluster state.
            These may be called within the test class constructor's action method,
            within the test constructor but outside of tha action, or within
            the test methods:
            </para>
            <list type="table">
            <item>
                <term><b>Local Machine DNS</b></term>
                <description>
                <see cref="P:Neon.Xunit.DockerFixture.LocalMachineHosts"/>
                </description>
            </item>
            <item>
                <term><b>Docker</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.DockerExecute(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.DockerExecute(System.Object[])"/>
                </description>
            </item>
            <item>
                <term><b>Configs</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearConfigs(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.Byte[],System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.String,System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListConfigs(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveConfig(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Containers</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearContainers(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListContainers(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveContainer(System.String)"/>
                <see cref="M:Neon.Xunit.DockerFixture.RunContainer(System.String,System.String,System.String[],System.String[],System.String[])"/><br/>
                </description>
            </item>
            <item>
                <term><b>Images</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.PullImage(System.String)"/><br/>
                </description>
            </item>
            <item>
                <term><b>Networks</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearNetworks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateNetwork(System.String,System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListNetworks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveNetwork(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Secrets</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearSecrets(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.Byte[],System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.String,System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListSecrets(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveSecret(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Services</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearServices(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.CreateService(System.String,System.String,System.String[],System.String[],System.String[])"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListServices(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.InspectService(System.String,System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveService(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RestartService(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RollbackService(System.String)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.UpdateService(System.String,System.String[])"/>
                </description>
            </item>
            <item>
                <term><b>Stacks</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearStacks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.DeployStack(System.String,System.String,System.String[],System.TimeSpan,System.TimeSpan)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.ListStacks(System.Boolean)"/><br/>
                <see cref="M:Neon.Xunit.DockerFixture.RemoveStack(System.String)"/>
                </description>
            </item>
            <item>
                <term><b>Volumes</b></term>
                <description>
                <see cref="M:Neon.Xunit.DockerFixture.ClearVolumes(System.Boolean)"/>
                </description>
            </item>
            </list>
            <note>
            <see cref="T:Neon.Xunit.DockerFixture"/> derives from <see cref="T:Neon.Xunit.ComposedFixture"/> so you can
            use <see cref="M:Neon.Xunit.ComposedFixture.AddFixture``1(System.String,``0,System.Action{``0},System.Int32)"/>
            to add additional fixtures within your custom initialization action for advanced scenarios.
            </note>
            <para>
            There are two basic patterns for using this fixture.
            </para>
            <list type="table">
            <item>
                <term><b>initialize once</b></term>
                <description>
                <para>
                The basic idea here is to have your test class initialize the swarm
                once within the test class constructor inside of the initialize action
                with common state and services that all of the tests can access.
                </para>
                <para>
                This will be quite a bit faster than reconfiguring the swarm at the
                beginning of every test and can work well for many situations but it
                assumes that your test methods guarantee that running any test in 
                any order will not impact the results of subsequent tests.  A good 
                example of this is a series of read-only tests against a service
                or database.
                </para>
                </description>
            </item>
            <item>
                <term><b>initialize every test</b></term>
                <description>
                For common scenarios where the swarm must be reset before every test,
                you can call <see cref="M:Neon.Xunit.DockerFixture.Reset"/> within the test class constructor
                (but outside of the custom initialization <see cref="T:System.Action"/> to
                reset the swarm state before the next test method is invoked.
                </description>
            </item>
            </list>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.SecretInfo">
            <summary>
            Holds information about a Docker secret.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.SecretInfo.ID">
            <summary>
            Returns the secret ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.SecretInfo.Name">
            <summary>
            Returns the secret name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.NetworkInfo">
            <summary>
            Holds information about a Docker network.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.NetworkInfo.ID">
            <summary>
            Returns the network ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.NetworkInfo.Name">
            <summary>
            Returns the network name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.ConfigInfo">
            <summary>
            Holds information about a Docker config.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ConfigInfo.ID">
            <summary>
            Returns the config ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ConfigInfo.Name">
            <summary>
            Returns the config name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.ServiceInfo">
            <summary>
            Holds information about a Docker service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.ID">
            <summary>
            Returns the service ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.Name">
            <summary>
            Returns the service name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.ReplicasDesired">
            <summary>
            Returns the number of replicas desired.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ServiceInfo.ReplicasDeployed">
            <summary>
            Returns the number of replicas actually deployed.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.StackInfo">
            <summary>
            Holds information about a Docker stack.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackInfo.Name">
            <summary>
            Returns the stack name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackInfo.ServiceCount">
            <summary>
            Returns the number of services deployed by the stack.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.ContainerInfo">
            <summary>
            Holds information about a Docker container.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ContainerInfo.ID">
            <summary>
            Returns the container ID.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ContainerInfo.Name">
            <summary>
            Returns the container name.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.StackService">
            <summary>
            Describes a Docker stack service.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackService.Name">
            <summary>
            The service name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackService.Replicas">
            <summary>
            The number of service replicas.
            </summary>
        </member>
        <member name="T:Neon.Xunit.DockerFixture.StackDefinition">
            <summary>
            Parses useful information from a Docker YAML compose file.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.StackDefinition.#ctor(System.String,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The stack name.</param>
            <param name="composeYaml">The stack compose YAML definition.</param>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackDefinition.Name">
            <summary>
            Returns the stack name.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.StackDefinition.Services">
            <summary>
            Returns information about the stack's services.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.StackDefinition.GetServiceName(Neon.Xunit.DockerFixture.StackService)">
            <summary>
            Returns the service name Docker will assign to a stack service.
            </summary>
            <param name="service">The stack service.</param>
            <returns>The service name.</returns>
        </member>
        <member name="F:Neon.Xunit.DockerFixture.RefCount">
            <summary>
            Used to track how many fixture instances for the current test run
            remain so we can determine when reset the Docker Swarm.
            </summary>
        </member>
        <member name="F:Neon.Xunit.DockerFixture.DockerNetworks">
            <summary>
            Identifies the built-in Docker networks.  These networks will not
            be returned by <see cref="M:Neon.Xunit.DockerFixture.ListNetworks(System.Boolean)"/> and cannot be deleted.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.EnsureReset">
            <summary>
            Called by <see cref="T:Neon.Xunit.TestFixture"/> to ensure that Docker is
            reset after an interrupted test run.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.#ctor(Neon.Common.Stub.Value)">
            <summary>
            Special private constructor that doesn't do reference counting
            or automatically reset the fixture state.
            </summary>
            <param name="param">Not used.</param>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.#ctor(System.Boolean)">
            <summary>
            Used for derived classes that need to disable the <see cref="M:Neon.Xunit.DockerFixture.Reset"/>
            call on construction
            </summary>
            <param name="reset">Optionally calls <see cref="M:Neon.Xunit.DockerFixture.Reset"/> when the reference count is zero.</param>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.LocalMachineHosts">
            <summary>
            Returns an integrated <see cref="T:Neon.Xunit.HostsFixture"/> that can be used to manage
            DNS entries in the local machine's DNS <b>hosts</b> file.
            </summary>
        </member>
        <member name="P:Neon.Xunit.DockerFixture.ClearDelay">
            <summary>
            Some Docker clear operations appear to take a few moments to complete.
            This delay will be added afterwards in an attempt to address this.
            </summary>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.DockerExecute(System.Object[])">
            <summary>
            Executes an arbitrary <b>docker</b> CLI command passing unformatted
            arguments and returns the results.
            </summary>
            <param name="args">The <b>docker</b> command arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/>.</returns>
            <remarks>
            <para>
            This method formats any arguments passed so they will be suitable 
            for passing on the command line by quoting and escaping them
            as necessary.
            </para>
            <note>
            This method is defined as <c>virtual</c> so that derived classes
            can modify how Docker is called.  For example, the <c>HiveFixture</c>
            class implemented in another assembly will override this to run
            the <b>docker</b> within a cluster using <b>neon-cli</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.DockerExecute(System.String)">
            <summary>
            Executes an arbitrary <b>docker</b> CLI command passing a pre-formatted
            argument string and returns the results.
            </summary>
            <param name="argString">The <b>docker</b> command arguments.</param>
            <returns>The <see cref="T:Neon.Common.ExecuteResponse"/>.</returns>
            <remarks>
            <para>
            This method assumes that the single string argument passed is already
            formatted as required to pass on the command line.
            </para>
            <note>
            This method is defined as <c>virtual</c> so that derived classes
            can modify how Docker is called.  For example, the <c>HiveFixture</c>
            class implemented in another assembly will override this to run
            the <b>docker</b> within a cluster using <b>neon-cli</b>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.Reset">
            <summary>
            Resets the local Docker daemon by clearing all swarm services and state
            as well as removing all containers.
            </summary>
            <remarks>
            <note>
            This method does not reset the Docker images on the test node for
            performance reasons.  You can call <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/> from
            your tests if required.
            </note>
            <note>
            As a safety measure, this method ensures that the local Docker instance
            <b>IS NOT</b> a member of a multi-node swarm to avoid wiping out production
            clusters by accident.
            </note>
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the local Docker instance is a member of a multi-node swarm.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearImages">
            <summary>
            Removes all unreferenced images from the target test node.  <see cref="M:Neon.Xunit.DockerFixture.Reset"/>
            does not do this for performance reasonse but tests may use this method
            if necessary.
            </summary>
            <remarks>
            <note>
            <para>
            Using this may result in very slow test performance, especially since
            it will purge a local copy of <b>neon-cli</b> if present.  This means
            this and any other test images (like Couchbase) will need to be
            downloaded again after every reset.
            </para>
            <para>
            We highly recommend that you use <see cref="M:Neon.Xunit.DockerFixture.PullImage(System.String)"/> to
            ensure that the desired images are up-to-date rather than using
            <see cref="M:Neon.Xunit.DockerFixture.ClearImages"/>.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.PullImage(System.String)">
            <summary>
            Pulls a specific image to the target test node.
            </summary>
            <param name="image">The image name.</param>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateService(System.String,System.String,System.String[],System.String[],System.String[])">
            <summary>
            Creates a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <param name="image">Specifies the service image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker service create ...</b> command.</param>
            <param name="serviceArgs">Optional arguments to be passed to the service.</param>
            <param name="env">Optional environment variables to be passed to the service, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListServices(System.Boolean)">
            <summary>
            Returns information about the current swarm services.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster services whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.ServiceInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.InspectService(System.String,System.Boolean)">
            <summary>
            Inspects a service, returning details about its current state.
            </summary>
            <param name="name">The service name.</param>
            <param name="strict">Optionally specify strict JSON parsing.</param>
            <returns>The <see cref="T:Neon.Docker.ServiceDetails"/>.</returns>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveService(System.String)">
            <summary>
            Removes a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RestartService(System.String)">
            <summary>
            Restarts a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RollbackService(System.String)">
            <summary>
            Rolls back a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.UpdateService(System.String,System.String[])">
            <summary>
            Updates a Docker service.
            </summary>
            <param name="name">The service name.</param>
            <param name="dockerArgs">Arguments to be passed to the <b>docker service update ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearServices(System.Boolean)">
            <summary>
            Removes all deployed services.
            </summary>
            <param name="removeSystem">Optionally remove core cluster services as well.</param>
            <remarks>
            By default, this method will not remove core cluster services
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RunContainer(System.String,System.String,System.String[],System.String[],System.String[])">
            <summary>
            Creates a Docker container.
            </summary>
            <param name="name">The container name.</param>
            <param name="image">Specifies the container image.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker service create ...</b> command.</param>
            <param name="containerArgs">Optional arguments to be passed to the service.</param>
            <param name="env">Optional environment variables to be passed to the container, formatted as <b>NAME=VALUE</b> or just <b>NAME</b>.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListContainers(System.Boolean)">
            <summary>
            Returns information about the current Docker containers.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster containers whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.ContainerInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveContainer(System.String)">
            <summary>
            Removes a Docker container.
            </summary>
            <param name="name">The container name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearContainers(System.Boolean)">
            <summary>
            Removes all running containers.
            </summary>
            <param name="removeSystem">Optionally remove core cluster containers as well.</param>
            <remarks>
            By default, this method will not remove core cluster containers
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.DeployStack(System.String,System.String,System.String[],System.TimeSpan,System.TimeSpan)">
            <summary>
            Deploys a Docker stack.
            </summary>
            <param name="name">The stack name.</param>
            <param name="composeYaml">The compose-file YAML text.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker secret create ...</b> command.</param>
            <param name="timeout">Optionally specifies the maximum time to wait for service tasks to start (defaults to <b>5 minutes</b>).</param>
            <param name="convergeTime">
            Optionally specifies the time to wait after the service tasks 
            have been started for the tasks to initialize.  This defaults 
            to <b>5 seconds</b> which is the same time that Docker waits
            for Swarm services to converge.
            </param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <exception cref="T:System.TimeoutException">Thrown if the stack tasks were not deployed after waiting <paramref name="timeout"/>.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListStacks(System.Boolean)">
            <summary>
            Returns information about the current swarm stacks.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster stacks whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.StackInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveStack(System.String)">
            <summary>
            Removes a Docker stack.
            </summary>
            <param name="name">The stack name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearStacks(System.Boolean)">
            <summary>
            Removes all deployed stacks.
            </summary>
            <param name="removeSystem">Optionally remove core cluster stacks as well.</param>
            <remarks>
            By default, this method will not remove core cluster stacks
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.String,System.String[])">
            <summary>
            Creates a Docker secret from text.
            </summary>
            <param name="name">The secret name.</param>
            <param name="secretText">The secret text.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker secret create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateSecret(System.String,System.Byte[],System.String[])">
            <summary>
            Creates a Docker secret from bytes.
            </summary>
            <param name="name">The secret name.</param>
            <param name="secretBytes">The secret bytes.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker secret create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListSecrets(System.Boolean)">
            <summary>
            Returns information about the current swarm secrets.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster secrets whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.SecretInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveSecret(System.String)">
            <summary>
            Removes a Docker secret.
            </summary>
            <param name="name">The secret name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearSecrets(System.Boolean)">
            <summary>
            Removes all swarm secrets.
            </summary>
            <param name="removeSystem">Optionally remove core cluster secrets as well.</param>
            <remarks>
            By default, this method will not remove cluster cluster secrets
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.String,System.String[])">
            <summary>
            Creates a Docker config from text.
            </summary>
            <param name="name">The secret name.</param>
            <param name="configText">The secret text.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker config create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateConfig(System.String,System.Byte[],System.String[])">
            <summary>
            Creates a Docker config from bytes.
            </summary>
            <param name="name">The secret name.</param>
            <param name="configBytes">The secret bytes.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker config create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListConfigs(System.Boolean)">
            <summary>
            Returns information about the current swarm configs.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster configs whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.ConfigInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveConfig(System.String)">
            <summary>
            Removes a Docker config.
            </summary>
            <param name="name">The config name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearConfigs(System.Boolean)">
            <summary>
            Removes all swarm configs.
            </summary>
            <param name="removeSystem">Optionally remove core cluster configs as well.</param>
            <remarks>
            By default, this method will not remove core cluster configs
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.CreateNetwork(System.String,System.String[])">
            <summary>
            Creates a Docker network.
            </summary>
            <param name="name">The network name.</param>
            <param name="dockerArgs">Optional arguments to be passed to the <b>docker network create ...</b> command.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ListNetworks(System.Boolean)">
            <summary>
            Returns information about the current swarm networks.
            </summary>
            <param name="includeSystem">Optionally include core built-in cluster networks whose names start with <b>neon-</b>.</param>
            <returns>A list of <see cref="T:Neon.Xunit.DockerFixture.NetworkInfo"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <remarks>
            <note>
            This method <b>DOES NOT</b> include built-in Docker networks such as
            <b>bridge</b>, <b>docker_gwbridge</b>, <b>host</b>, <b>ingress</b>,
            or <b>none</b> in the listed networks.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.RemoveNetwork(System.String)">
            <summary>
            Removes a Docker network.
            </summary>
            <param name="name">The network name.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the fixture has been disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown for built-in Docker networks.</exception>
            <remarks>
            <note>
            This method <b>DOES NOT</b> allow the removal of built-in Docker networks 
            such as <b>bridge</b>, <b>docker_gwbridge</b>, <b>host</b>, <b>ingress</b>,
            or <b>none</b> in the listed networks.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearNetworks(System.Boolean)">
            <summary>
            Removes all swarm networks.
            </summary>
            <param name="removeSystem">Optionally remove core cluster networks as well.</param>
            <remarks>
            By default, this method will not remove core cluster networks
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="M:Neon.Xunit.DockerFixture.ClearVolumes(System.Boolean)">
            <summary>
            Removes all swarm volumes.
            </summary>
            <param name="removeSystem">Optionally remove core cluster volumes as well.</param>
            <remarks>
            By default, this method will not remove core cluster volumes
            whose names begin with <b>neon-</b>.  You can remove these too by
            passing <paramref name="removeSystem"/><c>=true</c>.
            </remarks>
        </member>
        <member name="T:Neon.Xunit.EnvironmentFixture">
            <summary>
            Used to save environment variables before unit tests run and then restore them afterwards.
            </summary>
            <remarks>
            <para>
            You may instantiate a single <see cref="T:Neon.Xunit.EnvironmentFixture"/> within your unit
            tests to manage environment variables and test files and folders such as simulated 
            service config and secret files.
            </para>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests : IClassFixture&lt;EnvironmentFixture&gt;
            {
                private EnvironmentFixture fixture;
                
                public MyTests()
                {
                    this.fixture = fixture;
            
                    if (fixture.Start() == TestFixtureStatus.AlreadyRunning)
                    {
                        fixture.Restore();
                    }
                }
                
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Reset">
            <summary>
            <b>INTERNAL USE ONLY:</b> Resets the fixture state.
            </summary>
        </member>
        <member name="M:Neon.Xunit.EnvironmentFixture.Restore">
            <summary>
            Restores the original environment variables captured at the time the
            fixture was instantiated and also removes any temporary test files.
            </summary>
        </member>
        <member name="T:Neon.Xunit.HostsFixture">
            <summary>
            Used to manage the local DNS resolver<b>hosts</b> file on the current computer.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests : IClassFixture&lt;HostsFixture&gt;, IDisposable
            {
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="F:Neon.Xunit.HostsFixture.HostsPath">
            <summary>
            Path to the local DNS resolver's [hosts] file.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.EnsureReset">
            <summary>
            Called by <see cref="T:Neon.Xunit.TestFixture"/> to ensure that the hosts file
            contains no DNS records remaining after an interrupted test run.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.RemoveSection(System.String)">
            <summary>
            Removes a specific fixture section from the <b>hosts</b> file or all
            fixture sections if <paramref name="fixtureId"/> is <c>null</c>.
            </summary>
            <param name="fixtureId">
            Identifies the fixture section to be removed or <c>null</c> to 
            remove all fixture sections.
            </param>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.GetSectionHostname(System.String)">
            <summary>
            Returns the hostname for a section GUID.
            </summary>
            <param name="guid">The section GUID string.</param>
            <returns>The section hostname.</returns>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.GetHostAddressesAsync(System.String)">
            <summary>
            Performs an asynchronous DNS lookup.
            </summary>
            <param name="hostname">The target hostname.</param>
            <returns>The array of IP addresses resolved or an empty array if the hostname lookup failed.</returns>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.GetHostAddresses(System.String)">
            <summary>
            Performs a synchronous DNS lookup.
            </summary>
            <param name="hostname">The target hostname.</param>
            <returns>The array of IP addresses resolved or an empty array if the hostname lookup failed.</returns>
        </member>
        <member name="F:Neon.Xunit.HostsFixture.fixtureId">
            <summary>
            The GUID used to mark this fixture instance's entries in the hosts file.
            </summary>
        </member>
        <member name="F:Neon.Xunit.HostsFixture.records">
            <summary>
            The DNS records.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.AddHostAddress(System.String,System.String,System.Boolean)">
            <summary>
            Adds an IP address to the local DNS resolver's hosts file.
            </summary>
            <param name="hostname">The hostname.</param>
            <param name="address">The IP address.</param>
            <param name="deferCommit">
            Optionally indicates that the change will not be committed to the hosts
            until <see cref="M:Neon.Xunit.HostsFixture.Commit"/> is called.  This defaults to <c>falsae</c>.
            </param>
            <remarks>
            <note>
            This method will not add the duplicate hostname/address mappings
            to the fixture.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Commit">
            <summary>
            Commits the DNS records to the hosts file.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Reset">
            <summary>
            <b>INTERNAL USE ONLY:</b> Resets the fixture state.
            </summary>
        </member>
        <member name="M:Neon.Xunit.HostsFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="T:Neon.Xunit.ITestFixture">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Defines the behavior of a Neon Xunit test fixture.
            </para>
            <note>
            All test fixture implementations must inherit from <see cref="T:Neon.Xunit.TestFixture"/> to
            work properly.  Do not attempt to create a fixture from scratch that implements
            this interface.
            </note>
            </summary>
            <remarks>
            <para>
            Xunit test fixtures are designed to provide initialize global state 
            that tests can then reference during their execution.  Typical 
            scenarios include:
            </para>
            <list type="bullet">
            <item>
            Starting a database server and prepopulating it with a schema
            and data to test database access code.
            </item>
            <item>
            Starting a Docker service such that REST endpoints can be tested.
            </item>
            <item>
            Initializing a cluster and then configuring it with certificates,
            routes, services etc. and then performing tests against the
            actual swarm.
            </item>
            </list>
            <para>
            Test fixture lifecycle:
            </para>
            <list type="number">
            <item>
            First, you'll need create your Xunit test class and have it derive
            from <see cref="T:Xunit.IClassFixture`1"/>, where <c>TFixture</c>
            identifies the fixture.
            </item>
            <item>
            The Xunit test runner reflects the test assemblies and identifies the
            test classes with <c>[Fact]</c> test methods to be executed.
            </item>
            <item>
            For each test class to be executed, the test runner first creates
            an instance of the test fixture.  This is created <b>before</b>
            one before any of the test classes are instantiated and any
            test methods are called.
            </item>
            <item>
            <para>
            The test runner creates a new instance of the test class for each
            test method to be invoked.  The test class constructor must accept
            a single parameter with type <c>TFixture</c>.  The test class 
            constructor should call <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>
            to initialize the fixture, passing an optional <see cref="T:System.Action"/>
            that does any custom initialization for the test.
            </para>
            <para>
            The <see cref="T:System.Action"/> parameter is generally intended for internal
            use when implementing custom test fixtures.
            </para>
            <para>
            Test fixtures are designed to be aware of whether they've been
            initialized or not such that only the first call to
            <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/> will perform any
            necessary initialization (including calling the custom action)
            and any subsequent calls will do nothing.
            </para>
            <note>
            Some test fixtures may define a different different initialization
            method.
            </note>
            </item>
            <item>
            The test runner will continue instantiating test class instances
            and calling test methods using the test fixture state setup
            during the first test.
            </item>
            <item>
            Once all of the test methods have been called, the test runner
            will call the test fixtures <see cref="M:System.IDisposable.Dispose"/>
            method so that it can clean up any state.
            </item>
            </list>
            </remarks>
            <threadsafety instance="false"/>
        </member>
        <member name="M:Neon.Xunit.ITestFixture.Start(System.Action)">
            <summary>
            Starts the fixture if it hasn't already been started including invoking the optional
            <see cref="T:System.Action"/> the first time <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/> is called for
            a fixture instance.
            </summary>
            <param name="action">
            <para>
            The optional custom start action.
            </para>
            <note>
            This is generally intended for use when developing custom test fixtures.
            </note>
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="P:Neon.Xunit.ITestFixture.IsRunning">
            <summary>
            Returns <c>true</c> if the fixture has been started.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ITestFixture.Reset">
            <summary>
            <b>INTERNAL USE ONLY:</b> Resets the fixture state.
            </summary>
        </member>
        <member name="M:Neon.Xunit.ITestFixture.OnRestart">
            <summary>
            <para>
            Called when an already started fixture is being restarted.  This provides the
            fixture an opportunity to do some custom initialization.
            </para>
            <note>
            This method is intended only for use by test fixture implementations.  Unit
            tests or test fixtures should never call this directly.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Xunit.ITestFixture.State">
            <summary>
            Used by unit test classes to persist arbitrary name/value information across
            individual unit tests.
            </summary>
        </member>
        <member name="T:Neon.Xunit.NatsFixture">
            <summary>
            Used to run a Docker <b>nats</b> container on the current 
            machine as a test fixture while tests are being performed and 
            then deletes the container when the fixture is disposed.
            </summary>
            <remarks>
            <para>
            This fixture assumes that NATS is not currently running on the
            local workstation or as a container named <b>nats-test</b>.
            You may see port conflict errors if either of these conditions 
            are not true.
            </para>
            <para>
            A somewhat safer but slower alternative, is to use the <see cref="T:Neon.Xunit.DockerFixture"/>
            instead and add <see cref="T:Neon.Xunit.NatsFixture"/> as a subfixture.  The 
            advantage is that <see cref="T:Neon.Xunit.DockerFixture"/> will ensure that all
            (potentially conflicting) containers are removed before the NatsFixture
            fixture is started.
            </para>
            <para>
            Use <see cref="M:Neon.Xunit.NatsFixture.Restart"/> to clear the NATS server state by restarting
            its Docker container.  This also returns the new client connection.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="F:Neon.Xunit.NatsFixture.ConnectionUri">
            <summary>
            Returns the URI for a NATS server running locally (probably as a Docker container).
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="P:Neon.Xunit.NatsFixture.Connection">
            <summary>
            Returns the NATS connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.Start(System.String,System.String,System.String[],System.String)">
            <summary>
            <para>
            Starts a NATS container if it's not already running.  You'll generally want
            to call this in your test class constructor instead of <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.NatsFixture.StartAsComposed(System.String,System.String,System.String[],System.String)"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="image">
            Optionally specifies the NATS container image.  This defaults to 
            <b>ghcr.io/neonrelease/nats:latest</b> or <b>ghcr.io/ghcr.io/neonrelease-dev/nats:latest</b> depending 
            on whether the assembly was built from a git release branch or not.
            </param>
            <param name="name">Optionally specifies the NATS container name (defaults to <c>nats-test</c>).</param>
            <param name="args">Optional NATS server command line arguments.</param>
            <param name="hostInterface">
            Optionally specifies the host interface where the container public ports will be
            published.  This defaults to <see cref="P:Neon.Xunit.ContainerFixture.DefaultHostInterface"/>
            but may be customized.  This needs to be an IPv4 address.
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.StartAsComposed(System.String,System.String,System.String[],System.String)">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="image">
            Optionally specifies the NATS container image.  This defaults to 
            <b>ghcr.io/neonrelease/nats:latest</b> or <b>ghcr.io/ghcr.io/neonrelease-dev/nats:latest</b> depending
            on whether the assembly was built from a git release branch or not.
            </param>
            <param name="name">Optionally specifies the container name (defaults to <c>nats-test</c>).</param>
            <param name="args">Optional NATS server command line arguments.</param>
            <param name="hostInterface">
            Optionally specifies the host interface where the container public ports will be
            published.  This defaults to <see cref="P:Neon.Xunit.ContainerFixture.DefaultHostInterface"/>
            but may be customized.  This needs to be an IPv4 address.
            </param>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.Restart">
            <summary>
            Restarts the NATS container to clear any previous state and returns the 
            new client connection.
            </summary>
            <returns>The new connection.</returns>
        </member>
        <member name="M:Neon.Xunit.NatsFixture.Reset">
            <summary>
            This method completely resets the fixture by removing and recreating
            the NATS container.
            </summary>
        </member>
        <member name="T:Neon.Xunit.NatsStreamingFixture">
            <summary>
            Used to run a Docker <b>nats-streaming</b> container on the current 
            machine as a test fixture while tests are being performed and 
            then deletes the container when the fixture is disposed.
            </summary>
            <remarks>
            <para>
            This fixture assumes that NATS-SERVER is not currently running on the
            local workstation or as a container named <b>nats-test</b>.
            You may see port conflict errors if either of these conditions 
            are not true.
            </para>
            <para>
            A somewhat safer but slower alternative, is to use the <see cref="T:Neon.Xunit.DockerFixture"/>
            instead and add <see cref="T:Neon.Xunit.NatsStreamingFixture"/> as a subfixture.  The 
            advantage is that <see cref="T:Neon.Xunit.DockerFixture"/> will ensure that all
            (potentially conflicting) containers are removed before the NatsFixture
            fixture is started.
            </para>
            <para>
            Use <see cref="M:Neon.Xunit.NatsStreamingFixture.Restart"/> to clear the NATS-SATREAMIN server state by
            restarting its Docker container.  This also returns the new client 
            connection.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="P:Neon.Xunit.NatsStreamingFixture.Connection">
            <summary>
            Returns the NATS-STREAMING connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Start(System.String,System.String,System.String[])">
            <summary>
            <para>
            Starts a NATS-STREAMING container if it's not already running.  You'll generally want
            to call this in your test class constructor instead of <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/>.
            </para>
            <note>
            You'll need to call <see cref="M:Neon.Xunit.NatsStreamingFixture.StartAsComposed(System.String,System.String,System.String[])"/>
            instead when this fixture is being added to a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </note>
            </summary>
            <param name="image">
            Optionally specifies the NATS-STREAMING container image.  This defaults to 
            <b>ghcr.io/neonrelease/nats-streaming:latest</b> or <b>ghcr.io/neonrelease-dev/nats-streaming:latest</b>
            depending on whether the assembly was built from a git release branch
            or not.
            </param>
            <param name="name">Optionally specifies the NATS-STREAMING container name (defaults to <c>nats-streaming-test</c>).</param>
            <param name="args">Optional NATS-STREAMING server command line arguments.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.StartAsComposed(System.String,System.String,System.String[])">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="image">
            Optionally specifies the NATS container image.  This defaults to 
            <b>ghcr.io/neonrelease/nats-streaming:latest</b> or <b>ghcr.io/neonrelease-dev/nats-streaming:latest</b>
            depending on whether the assembly was built from a git release branch
            or not.
            </param>
            <param name="name">Optionally specifies the container name (defaults to <c>nats-streaming-test</c>).</param>
            <param name="args">
            <para>
            Optional NATS-STREAMING server command line arguments.
            </para>
            <note>
            Reasonable defaults are used when <paramref name="args"/> is passed 
            as <c>null</c>.  These connect the NATS streaming server to the NATS
            core server running within the container and also configure the
            default MEMORY persisted store.
            </note>
            </param>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Connect">
            <summary>
            Establishes the server connection.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Restart">
            <summary>
            Restarts the NATS container to clear any previous state and returns the 
            new client connection.
            </summary>
            <returns>The new connection.</returns>
        </member>
        <member name="M:Neon.Xunit.NatsStreamingFixture.Reset">
            <summary>
            This method completely resets the fixture by removing and recreating
            the NATS-STREAMING container.
            </summary>
        </member>
        <member name="T:Neon.Xunit.NeonServiceFixture`1">
            <summary>
            Fixture for testing a <see cref="T:Neon.Service.NeonService"/>.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.NeonServiceFixture`1.Service">
            <summary>
            Returns the service instance.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.Start(System.Action)">
            <summary>
            <b>DON'T USE THIS:</b> Use <see cref="M:Neon.Xunit.NeonServiceFixture`1.Start(System.Func{`0},Neon.Service.ServiceMap,System.TimeSpan)"/> instead for this fixture.
            </summary>
            <param name="action">The initialization action.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.Start(System.Func{`0},Neon.Service.ServiceMap,System.TimeSpan)">
            <summary>
            Starts the fixture including a <typeparamref name="TService"/> service instance if
            the fixture is not already running.
            </summary>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
            <param name="serviceMap">
            Optionally passed as the service map describing an emulated deployment.  When this is
            not <c>null</c>, the fixture will call <see cref="P:Neon.Service.NeonService.Name"/> on the service
            returned by your service creator function and then look up the service by name from
            the <paramref name="serviceMap"/>.  If an entry exists for the service, the fixture will
            add any environment variables or configuration files from the <see cref="T:Neon.Service.ServiceDescription"/>
            to the <see cref="T:Neon.Service.NeonService"/> before starting it.
            </param>
            <param name="readyTimeout">
            Optionally specifies the maximum time the fixture should wait for the service to transition
            to the <see cref="F:Neon.Service.NeonServiceStatus.Running"/> state.  This defaults to <b>30 seconds</b>.
            </param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.TimeoutException">
            Thrown if the service didn't transition to the running (or terminated) state 
            within <paramref name="readyTimeout"/>.
            </exception>
            <remarks>
            <para>
            This method first calls the <paramref name="serviceCreator"/> callback and expects it to
            return a new service instance that has been initialized by setting its environment variables
            and configuration files as required.  The callback should <b>not start</b> the service.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.StartAsComposed(System.Func{`0},Neon.Service.ServiceMap,System.TimeSpan)">
            <summary>
            Used to start the fixture within a <see cref="T:Neon.Xunit.ComposedFixture"/>.
            </summary>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
            <param name="serviceMap">
            Optionally passed as the service map describing an emulated deployment.  When this is
            not <c>null</c>, the fixture will call <see cref="P:Neon.Service.NeonService.Name"/> on the service
            returned by your service creator function and then look up the service by name from
            the <paramref name="serviceMap"/>.  If an entry exists for the service, the fixture will
            add any environment variables or configuration files from the <see cref="T:Neon.Service.ServiceDescription"/>
            to the <see cref="T:Neon.Service.NeonService"/> before starting it.
            </param>
            <param name="readyTimeout">
            Optionally specifies the maximum time the fixture should wait for the service to transition
            to the <see cref="F:Neon.Service.NeonServiceStatus.Running"/> state.  This defaults to <b>30 seconds</b>.
            </param>
            <exception cref="T:System.TimeoutException">
            Thrown if the service didn't transition to the running (or terminated) state
            within <paramref name="readyTimeout"/>.
            </exception>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.ClearCaches(System.Boolean)">
            <summary>
            Clears any instance caches.
            </summary>
            <param name="disposing">Optionally indicates that we're clearing because we're disposing the fixture.</param>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.Restart(System.Func{`0},System.TimeSpan)">
            <summary>
            Restarts the service.
            </summary>
            <param name="serviceCreator">Callback that creates and returns the new service instance.</param>
            <param name="runningTimeout">
            Optionally specifies the maximum time the fixture should wait for the service to transition
            to the <see cref="F:Neon.Service.NeonServiceStatus.Running"/> state.  This defaults to <b>30 seconds</b>.
            </param>
            <exception cref="T:System.TimeoutException">
            Thrown if the service didn't transition to the running (or terminated) state
            within <paramref name="runningTimeout"/>.
            </exception>
            <remarks>
            <para>
            This method first calls the <paramref name="serviceCreator"/> callback and expects
            it to return a new service instance that has been initialized by setting its environment
            variables and configuration files as required.  The callback should not start thge service.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.StopService">
            <summary>
            Stops the service if it's running.
            </summary>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.GetHttpClient(System.String,System.Net.Http.HttpClientHandler)">
            <summary>
            Returns a <see cref="T:System.Net.Http.HttpClient"/> instance configured to communicate with the
            service via the named HTTP/HTTPS endpoint.
            </summary>
            <param name="endpointName">Optionally specifies HTTP/HTTPS endpoint name as defined by the service description (defaults to <see cref="F:System.String.Empty"/>).</param>
            <param name="handler">Optionally specifies a custom HTTP handler.</param>
            <returns>The configured <see cref="T:System.Net.Http.HttpClient"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the named endpoint doesn't exist.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the endpoint protocol is not <see cref="F:Neon.Service.ServiceEndpointProtocol.Http"/>
            or <see cref="F:Neon.Service.ServiceEndpointProtocol.Https"/>.
            </exception>
            <remarks>
            <para>
            The client returned will have it's <see cref="P:System.Net.Http.HttpClient.BaseAddress"/> initialized
            with the URL of the service including the path prefix defined by the endpoint.
            </para>
            <note>
            The client returned will be cached such that subsequent calls will return
            the same client instance for the endpoint.  This cache will be cleared if
            the service fixture is restarted.
            </note>
            <note>
            Do not dispose the client returned since it will be cached by the fixture and
            then be disposed when the fixture is restarted or disposed.  The optional 
            <paramref name="handler"/> passed will also be disposed when fixture will
            also be disposed automatically.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.NeonServiceFixture`1.GetJsonClient(System.String,System.Net.Http.HttpClientHandler)">
            <summary>
            Returns a <see cref="T:Neon.Net.JsonClient"/> instance configured to communicate with the
            service via the named HTTP/HTTPS endpoint.
            </summary>
            <param name="endpointName">Optionally specifies HTTP/HTTPS endpoint name as defined by the service description (defaults to <see cref="F:System.String.Empty"/>).</param>
            <param name="handler">Optionally specifies a custom HTTP handler.</param>
            <returns>The configured <see cref="T:System.Net.Http.HttpClient"/>.</returns>
            <remarks>
            <para>
            The client returned will have it's <see cref="P:System.Net.Http.HttpClient.BaseAddress"/> initialized
            with the URL of the service including the path prefix defined by the endpoint.
            </para>
            <note>
            The client returned will be cached such that subsequent calls will return
            the same client instance for the endpoint.  This cache will be cleared if
            the service fixture is restarted.
            </note>
            <note>
            Do not dispose the client returned since it will be cached by the fixture and
            then be disposed when the fixture is restarted or disposed.  The optional 
            <paramref name="handler"/> passed will also be disposed when fixture will
            also be disposed automatically.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.TestFixture">
            <summary>
            Abstract test fixture base class.
            </summary>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> The base Neon <see cref="T:Neon.Xunit.TestFixture"/> implementation <b>DOES NOT</b>
            support parallel test execution because fixtures may impact global machine state
            like starting a Docker container, modifying the local DNS <b>hosts</b> file, configuring
            environment variables or initializing a test database.
            </para>
            <para>
            You should explicitly disable parallel execution in all test assemblies that
            rely on test fixtures by adding a C# file called <c>AssemblyInfo.cs</c> with:
            </para>
            <code language="csharp">
            [assembly: CollectionBehavior(DisableTestParallelization = true, MaxParallelThreads = 1)]
            </code>
            <para>
            and then define your test classes like:
            </para>
            <code language="csharp">
            public class MyTests
            {
                [Collection(TestCollection.NonParallel)]
                [CollectionDefinition(TestCollection.NonParallel, DisableParallelization = true)]
                [Fact]
                public void Test()
                {
                }
            }
            </code>
            </note>
            <para>
            Test fixtures that modify global machine or other environmental state must
            implement a <c>public static void EnsureReset()</c> method resets the state
            to reasonable defaults.  These will be reflected and called when the first
            <see cref="T:Neon.Xunit.TestFixture"/> is created by the test runner for every test class.
            </para>
            </remarks>
            <threadsafety instance="true"/>
        </member>
        <member name="F:Neon.Xunit.TestFixture.resetMethods">
            <summary>
            Holds any reflected <c>public static void EnsureReset()</c> from any
            <see cref="T:Neon.Xunit.TestFixture"/> implementations.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.EnsureReset">
            <summary>
            Resets the state of any reflected fixture implementations.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestFixture.RefCount">
            <summary>
            Used to track whether <see cref="M:Neon.Xunit.TestFixture.EnsureReset"/> should be called when
            the first test fixture is created or when the last one is disposed.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.#ctor">
            <summary>
            Constructs the fixture.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.IsDisposed">
            <summary>
            Returns <c>true</c> if the instance has been disposed.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.InAction">
            <summary>
            Returns <c>true</c> if the <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/> method
            is running.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.IsRunning">
            <summary>
            Returns <c>true</c> if the fixture has been initialized.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.CheckDisposed">
            <summary>
            Verifies that the fixture instance has not been disposed.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.CheckWithinAction">
            <summary>
            Verifies that the fixture instance's <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/>
            method is executing.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Start(System.Action)">
            <summary>
            Starts the fixture if it hasn't already been started including invoking the optional
            <see cref="T:System.Action"/> when the first time <see cref="M:Neon.Xunit.TestFixture.Start(System.Action)"/> is called for
            a fixture instance.
            </summary>
            <param name="action">The optional custom start action.</param>
            <returns>
            <see cref="F:Neon.Xunit.TestFixtureStatus.Started"/> if the fixture wasn't previously started and
            this method call started it or <see cref="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning"/> if the 
            fixture was already running.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown if this is called from within the <see cref="T:System.Action"/>.</exception>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.TestFixture.Reset">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestFixture.OnRestart">
            <summary>
            <para>
            Called when an already started fixture is being restarted.  This provides the
            fixture an opportunity to do some custom initialization.  This base method
            does nothing.
            </para>
            <note>
            This method is intended only for use by test fixture implementations.  Unit
            tests or test fixtures should never call this directly.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestFixture.State">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Xunit.TestFixtureStatus">
            <summary>
            Returned by <see cref="M:Neon.Xunit.ITestFixture.Start(System.Action)"/> to indicate whether
            the test fixture was just started or was already running.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestFixtureStatus.Started">
            <summary>
            The fixture was just started.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestFixtureStatus.AlreadyRunning">
            <summary>
            The fixture was already running.
            </summary>
        </member>
        <member name="T:Neon.Xunit.IncompatibleServiceException">
            <summary>
            Thrown by <see cref="M:Neon.Xunit.XunitExtensions.ValidateController``1(Neon.Data.IGeneratedServiceClient)"/> when
            the service type doesn't match a generated service client.
            </summary>
        </member>
        <member name="M:Neon.Xunit.IncompatibleServiceException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:Neon.Xunit.MockHttpServer">
            <summary>
            <para>
            Implements a very lightweight HTTP server suitable for locally
            mocking an HTTP based service.
            </para>
            <note>
            This currently runs only on Windows.
            </note>
            </summary>
            <threadsafety instance="true"/>
        </member>
        <member name="M:Neon.Xunit.MockHttpServer.#ctor(System.String,System.Func{Microsoft.Net.Http.Server.RequestContext,System.Threading.Tasks.Task})">
            <summary>
            Constuctor.
            </summary>
            <param name="urlPrefix">Specifies the URL prefixes to be served.</param>
            <param name="handler">The custom asynchronous request handler.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.MockHttpServer.RequestProcessor">
            <summary>
            Handles received requests.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Xunit.MockHttpServerExtensions">
            <summary>
            Misc extsnsions.
            </summary>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.QueryGet(Microsoft.Net.Http.Server.Request,System.String)">
            <summary>
            Returns the value of a request query argument.
            </summary>
            <param name="request">The request.</param>
            <param name="name">The query argument name.</param>
            <returns>The argument value or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.GetBodyText(Microsoft.Net.Http.Server.Request)">
            <summary>
            Returns a request body payload as text.
            </summary>
            <param name="request">The request.</param>
            <returns>The body text.</returns>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.Write(Microsoft.Net.Http.Server.Response,System.Byte[])">
            <summary>
            Writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.Write(Microsoft.Net.Http.Server.Response,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to be written.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.Write(Microsoft.Net.Http.Server.Response,System.String)">
            <summary>
            Writes a string to an HTTP response using UTF-8 encoding.
            </summary>
            <param name="response">The response.</param>
            <param name="text">The text to be written.</param>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.WritAsynce(Microsoft.Net.Http.Server.Response,System.Byte[])">
            <summary>
            Asynchronously writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.WriteAsync(Microsoft.Net.Http.Server.Response,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Asynchronously writes bytes to an HTTP response.
            </summary>
            <param name="response">The response.</param>
            <param name="bytes">The bytes.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to be written.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Xunit.MockHttpServerExtensions.WriteAsync(Microsoft.Net.Http.Server.Response,System.String)">
            <summary>
            Asynchronously writes a string to an HTTP response using UTF-8 encoding.
            </summary>
            <param name="response">The response.</param>
            <param name="text">The text to be written.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Xunit.NamespaceDoc">
            <summary>
            This namespace includes unit test related helper classes include Xunit test fixtures for ASP.NET, 
            Docker Containers, Docker Swarm, Environment variables, DNS (local hosts file), Kube services, 
            NATS/STAN message queues.
            </summary>
        </member>
        <member name="T:Neon.Xunit.PlatformFactAttribute">
            <summary>
            Inherits from <see cref="T:Xunit.FactAttribute"/> and sets <see cref="P:Xunit.FactAttribute.Skip"/> when
            the current operating system platform doesn't match any of the specified platform flags.
            </summary>
        </member>
        <member name="M:Neon.Xunit.PlatformFactAttribute.#ctor(Neon.Xunit.TargetPlatforms)">
            <summary>
            Default constructor.
            </summary>
            <param name="platforms">Specifies the platforms where the tagged test should execute.</param>
        </member>
        <member name="T:Neon.Xunit.RepeatAttribute">
            <summary>
            Used to annotate an Xunit <c>[Theory]</c> test method to have the test executed
            the specified number of times.
            </summary>
        </member>
        <member name="M:Neon.Xunit.RepeatAttribute.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="count">Specifies the number of times the theory should be executed.</param>
        </member>
        <member name="M:Neon.Xunit.RepeatAttribute.GetData(System.Reflection.MethodInfo)">
            <summary>
            Returns the data to be passed to the test theory method an enumeration of
            data arrays, each holding the objects to be passed as a test call.
            </summary>
            <param name="testMethod">Specifies the target test method.</param>
            <returns>The argument arrays.</returns>
        </member>
        <member name="T:Neon.Xunit.TargetPlatforms">
            <summary>
            Enumerates the platforms that can be targeted by unit tests tagged
            with <see cref="T:Neon.Xunit.PlatformFactAttribute"/>.  Note that these flags may
            be bitwise-ORed together.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TargetPlatforms.All">
            <summary>
            Target all platforms.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TargetPlatforms.Windows">
            <summary>
            Target Windows.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TargetPlatforms.Linux">
            <summary>
            Target Linux.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TargetPlatforms.Osx">
            <summary>
            Target OS/X.
            </summary>
        </member>
        <member name="T:Neon.Xunit.TestArea">
            <summary>
            Defines the neonFORGE related test areas.  These currently map to 
            neonFORGE related projects.  Use these in <c>[Trait(TestTrait.Category, ...)]</c>
            attributes tagging your test methods.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCadence">
            <summary>
            Identifies <b>Neon.Cadence</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonTemporal">
            <summary>
            Identifies <b>Neon.Temporal</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonModelGen">
            <summary>
            Identifies <b>Neon.ModelGen</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCommon">
            <summary>
            Identifies <b>Neon.Common</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCryptography">
            <summary>
            Identifies <b>Neon.Cryptography</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonDeployment">
            <summary>
            Identifies <b>Neon.Deployment</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonKube">
            <summary>
            Identifies <b>Neon.Kube</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCloud">
            <summary>
            Identifies <b>Neon.Cloud</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCouchbase">
            <summary>
            Identifies <b>Neon.Couchbase</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCli">
            <summary>
            Identifies <b>neon-cli</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonDesktop">
            <summary>
            Identifies <b>neon-desktop</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonService">
            <summary>
            Identifies the <b>Neon.Service</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonXunit">
            <summary>
            Identifies <b>neon-xunit</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonWeb">
            <summary>
            Identifies <b>Neon.Web</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonYugaByte">
            <summary>
            Identifies <b>Neon.YugaByte</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonPostgres">
            <summary>
            Identifies <b>Neon.Postgres</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonCassandra">
            <summary>
            Identifies <b>Neon.Cassandra</b> tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestArea.NeonIdentity">
            <summary>
            Identifies <b>Neon.Identity</b> tests.
            </summary>
        </member>
        <member name="T:Neon.Xunit.TestCollection">
            <summary>
            Enumerates the neonLIBRARY related xUnit test collections.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestCollection.NonParallel">
            <summary>
            Identifies the test collection where tests <b>are never</b> executed in parallel.
            </summary>
        </member>
        <member name="T:Neon.Xunit.TestContext">
            <summary>
            Holds information like settings and test files for unit tests.
            </summary>
            <remarks>
            <para>
            This class is pretty easy to use.  Simply construct an instance, perform any
            desired initialization such as reading files (potentionally encypted) and
            configuring variables/settings.  Then your tests can reference this via
            the static <see cref="P:Neon.Xunit.TestContext.Current"/> property.
            </para>
            <para>
            You'll generally construct one of these instances at the beginning of your
            test method or within a test fixture.  Only one <see cref="T:Neon.Xunit.TestContext"/>
            may be active at any given time, so remember to call <see cref="M:Neon.Xunit.TestContext.Dispose"/>
            when your test run is commplete.
            </para>
            <para>
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Xunit.TestContext.Current">
            <summary>
            Returns the cuurent <see cref="T:Neon.Xunit.TestContext"/> or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestContext.#ctor">
            <summary>
            Constructor.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if another <see cref="T:Neon.Xunit.TestContext"/> already exists.</exception>
            <remarks>
            <note>
            Only one <see cref="T:Neon.Xunit.TestContext"/> instance may exist at any time.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.TestContext.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Xunit.TestContext.Settings">
            <summary>
            Returns a case senstive dictionary mapping setting names to object values.
            You can use this to pass settings and other information to tests.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestContext.Files">
            <summary>
            Returns a case sensitive dictionary mapping file names to byte arrays 
            with the file contents.  You can use this to pass file data to tests.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestContext.LookupPassword(System.String)">
            <summary>
            Looks up a password from the <b>~/.neonkube/passwords</b> folder.
            </summary>
            <param name="passwordName">The password name.</param>
            <returns>The password value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the password doesn't exist.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.LoadSettings(System.String,System.Func{System.String,System.String})">
            <summary>
            <para>
            Loads settings formatted as <c>NAME=VALUE</c> from a text file into the
            <see cref="P:Neon.Xunit.TestContext.Settings"/> dictionary.  The file will be decrypted using
            <see cref="T:Neon.Cryptography.NeonVault"/> if necessary.
            </para>
            <note>
            Blank lines and lines beginning with '#' will be ignored.
            </note>
            </summary>
            <param name="path">The input file path.</param>
            <param name="passwordProvider">
            Optionally specifies the password provider function to be used to locate the
            password required to decrypt the source file when necessary.  This defaults
            to looking for the password inb <b>~/.neonkube/passwords</b> when 
            <paramref name="passwordProvider"/> is <c>null</c>.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
            <exception cref="T:System.FormatException">Thrown for file formatting problems.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.LoadEnvironment(System.String,System.Func{System.String,System.String})">
            <summary>
            <para>
            Loads environment variables formatted as <c>NAME=VALUE</c> from a text file into environment
            variables.  The file will be decrypted using <see cref="T:Neon.Cryptography.NeonVault"/> if necessary.
            </para>
            <note>
            Blank lines and lines beginning with '#' will be ignored.
            </note>
            </summary>
            <param name="path">The input file path.</param>
            <param name="passwordProvider">
            Optionally specifies the password provider function to be used to locate the
            password required to decrypt the source file when necessary.  This defaults
            to looking for the password inb <b>~/.neonkube/passwords</b> when 
            <paramref name="passwordProvider"/> is <c>null</c>.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
            <exception cref="T:System.FormatException">Thrown for file formatting problems.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.LoadFile(System.String,System.Func{System.String,System.String})">
            <summary>
            Loads a file into the <see cref="P:Neon.Xunit.TestContext.Files"/> dictionary, using the file name
            (without the directory path) as the key.  The file will be decrypted via
            <see cref="T:Neon.Cryptography.NeonVault"/> as necessary.
            </summary>
            <param name="path">The file path.</param>
            <param name="passwordProvider">
            Optionally specifies the password provider function to be used to locate the
            password required to decrypt the source file when necessary.  This defaults
            to looking for the password inb <b>~/.neonkube/passwords</b> when 
            <paramref name="passwordProvider"/> is <c>null</c>.
            </param>
            <exception cref="T:System.IO.FileNotFoundException">Thrown if the file doesn't exist.</exception>
            <exception cref="T:System.FormatException">Thrown for file formatting problems.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.GetFileBytes(System.String)">
            <summary>
            Returns the raw bytes for the named file from the <see cref="P:Neon.Xunit.TestContext.Files"/>
            dictionary.
            </summary>
            <param name="filename">The file name.</param>
            <returns>The file bytes.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the file doesn't exist.</exception>
        </member>
        <member name="M:Neon.Xunit.TestContext.GetFileText(System.String,System.Text.Encoding)">
            <summary>
            Returns the text for the named file from the <see cref="P:Neon.Xunit.TestContext.Files"/>.
            dictionary.
            </summary>
            <param name="filename">The file name.</param>
            <param name="encoding">The encoding to be used (defaults to <see cref="P:System.Text.Encoding.UTF8"/>).</param>
            <returns>The file text.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the file doesn't exist.</exception>
        </member>
        <member name="T:Neon.Xunit.TestHelper">
            <summary>
            Misc local unit test helpers.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)">
            <summary>
            Creates and populates a temporary test folder with a test file.
            </summary>
            <param name="data">The file name</param>
            <param name="filename">The file data.</param>
            <returns>The <see cref="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)"/>.</returns>
            <remarks>
            <note>
            Ensure that the <see cref="M:Neon.Xunit.TestHelper.TempFolder(System.String,System.String)"/> returned is disposed so it and
            any files within will be deleted.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Ensures that two enumerations contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order.  This uses the default equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Ensures that two enumerations do not contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order.  This uses the default equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Ensures that two enumerations contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order using an equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <param name="comparer">The comparer used to equate objects in the collection with the expected object</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Ensures that two enumerations do not contain the same items, possibly in different
            orders.  This is similar to <see cref="M:Xunit.Assert.Equal``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})"/>
            but it doesn't enforce the item order using an equality comparer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expected">The expected items.</param>
            <param name="collection">The collection being tested.</param>
            <param name="comparer">The comparer used to equate objects in the collection with the expected object</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the collections are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Ensures that two dictionaries contain the same items using the default equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Ensures that two dictionaries do not contain the same items using the default equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Ensures that two dictionaries contain the same items using an equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <param name="comparer">The equality comparer to be used.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertNotEquivalent``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Ensures that two dictionaries do not contain the same items using an equality comparer.
            </summary>
            <typeparam name="TKey">Specifies the dictionary key type.</typeparam>
            <typeparam name="TValue">Specifies the dictionary value type.</typeparam>
            <param name="expected">The expected items.</param>
            <param name="dictionary">The collection being tested.</param>
            <param name="comparer">The equality comparer to be used.</param>
            <exception cref="T:System.Exception">Various exceptions are thrown if the dictionaries are not equivalent.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertEqualLines(System.String,System.String)">
            <summary>
            Compares two strings such that platform line ending differences will be
            ignored.  This works by removing any embedded carriage returns before
            performing the comparision.
            </summary>
            <param name="expected">The expected value.</param>
            <param name="actual">The actual valut.</param>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertThrows``1(System.Action)">
            <summary>
            Verifies that an action throws a <typeparamref name="TException"/> or an
            <see cref="T:System.AggregateException"/> that contains <typeparamref name="TException"/>.
            </summary>
            <typeparam name="TException">The required exception type.</typeparam>
            <param name="action">The test action.</param>
        </member>
        <member name="M:Neon.Xunit.TestHelper.AssertThrowsAsync``1(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Verifies that an asynchronous action throws a <typeparamref name="TException"/> or an
            <see cref="T:System.AggregateException"/> that contains <typeparamref name="TException"/>.
            </summary>
            <typeparam name="TException">The required exception type.</typeparam>
            <param name="action">The test action.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHelper.RunFixture``1(System.Object[])">
            <summary>
            Used to run a <see cref="T:Neon.Xunit.TestFixture"/> outside of a unit test.
            </summary>
            <typeparam name="T">Specifies the test type.</typeparam>
            <param name="args">
            Optional parameters that will be passed to the constructor after the
            fixture parameter.  Note that the number of parameters and their types
            must match the constructor parameters after the fixture one.
            </param>
            <remarks>
            <para>
            This is often used to run a <see cref="T:Neon.Service.NeonService"/> using <see cref="T:Neon.Xunit.NeonServiceFixture`1"/>
            or a collection of <see cref="T:Neon.Service.NeonService"/> instances for debugging purposes using a combination
            of a <see cref="T:Neon.Xunit.ComposedFixture"/> with <see cref="T:Neon.Xunit.NeonServiceFixture`1"/> sub-fixtures.
            But, this can also be used for any <see cref="T:Neon.Xunit.ITestFixture"/> implementation.
            </para>
            <para>
            You'll need to implement a test class that derives from a <see cref="T:Xunit.IClassFixture`1"/>
            implementation and optionally implements <see cref="T:System.IDisposable"/>.  You'll pass
            your test type as <typeparamref name="T"/>.  Your test class must include a public
            constructor that accepts a single parameter with the test fixture type and
            a public method with no parameters called <c>public void Run()</c>.
            </para>
            <para>
            This will look something like:
            </para>
            <code language="C#">
            public class MyTestRunner : IClassFixture&lt;ComposedFixture&gt;
            {
                private ComposedFixture                     composedFixture;
                private NatsFixture                         natsFixture;
                private NeonServiceFixture&lt;QueueService&gt;    queueServiceFixture;
            
                public MyTestRunner(ComposedFixture fixture)
                {
                    this.composedFixture = fixture;
            
                    composedFixture.Start(
                        () =>
                        {
                            composedFixture.AddFixture("nats", new NatsFixture(),
                                natsFixture =>
                                {
                                   natsFixture.StartAsComposed();
                                });
            
                            composedFixture.AddServiceFixture("queue-service", new NeonServiceFixture&lt;QueueService&gt;(), () => CreateQueueService());
                        });
            
                    this.natsFixture         = (NatsFixture)composedFixture["nats"];
                    this.queueServiceFixture = (NeonServiceFixture&lt;QueueService&gt;)composedFixture["queue-service"];
                }
                
                public void Run()
                {
                    // The runner will stop when this method returns.  You can
                    // also use this as an opportunity to perform any initialization.
                    // For this example, we're just going to spin slowly forever.
                    
                    while (true)
                    {
                        System.Threading.Thread.Sleep(10000);
                    }
                }
            }
            </code>
            <para>
            This method performs these steps:
            </para>
            <list type="number">
                <item>
                Perform a runtime check to verify that <typeparamref name="T"/> has a public constructor
                that accepts a single parameter of type <typeparamref name="T"/> as well as any additional
                parameters.
                </item>
                <item>
                Perform a runtime check to ensure that <typeparamref name="T"/> has a <c>public void Run()</c>
                method.
                </item>
                <item>
                Instantiate an instance of the test fixture specified by <see cref="T:Xunit.IClassFixture`1"/>.
                </item>
                <item>
                Instantiate an instance of <typeparamref name="T"/>, passing the test fixture just created
                as the parameter.
                </item>
                <item>
                Call the <c>Run()</c> method and wait for it to return.
                </item>
                <item>
                Dispose the test fixture.
                </item>
                <item>
                Call <see cref="M:System.IDisposable.Dispose"/>, if implemented by the test class.
                </item>
                <item>
                The method returns.
                </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Xunit.TestHelper.ResetDocker(System.Type,System.Boolean)">
            <summary>
            Resets Docker state by removing all containers, volumes, networks and
            optionally the Docker image cache.  This is useful ensuring that Docker
            is in a known state.  This also disables <b>swarm mode</b>.
            </summary>
            <param name="testClass">Specifies the current test class or pass <c>null</c> to force the reset).</param>
            <param name="pruneImages">Optionally prunes the Docker image cache.</param>
            <remarks>
            <para>
            This method works by comparing the <paramref name="testClass"/> passed
            with any previous test class passed.  The method only resets the Docker
            state when the test class changes.  This prevents Docker from being reset
            when every test in the same class runs (which will probably break tests).
            </para>
            <note>
            This does not support multiple test classes performing parallel Docker operations.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Xunit.TestHttpClient">
            <summary>
            Implements a <see cref="T:System.Net.Http.HttpClient"/> compatible client with additional capabilities,
            like disabling connection reuse.  This is intended for unit testing purposes like
            verifying that load balancing actually works.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.#ctor(System.Boolean,System.Net.Http.HttpMessageHandler,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="disableConnectionReuse">Indicates whether connection reuse should be disabled.</param>
            <param name="handler">Optionally specifies a message handler.</param>
            <param name="disposeHandler">Optionally specifies that the handler should be disposed when this instance is disposed.</param>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetClient">
            <summary>
            Returns the client, ensuring that it hasn't been disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetSingleUseClient">
            <summary>
            Returns a single-use client.
            </summary>
            <returns>The client.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown when the instance is disposed.</exception>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.DefaultRequestHeaders">
            <summary>
            The headers that should be sent with each request.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.BaseAddress">
            <summary>
            The base address that to be used when sending requests.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.MaxResponseContentBufferSize">
            <summary>
            the maximum number of bytes to buffer when reading the response content.
            This defaults to 2GiB.
            </summary>
        </member>
        <member name="P:Neon.Xunit.TestHttpClient.Timeout">
            <summary>
            The maximum time allowed before a request times out.
            </summary>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.Uri)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.DeleteAsync(System.String)">
            <summary>
            Sends a <b>DELETE</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String,System.Net.Http.HttpCompletionOption)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The copmpletion options.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The copmpletion options.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri,System.Net.Http.HttpCompletionOption)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The completion option.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="completionOption">The completion option.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Sends a <b>GET</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetByteArrayAsync(System.String)">
            <summary>
            Performs a <b>GET</b> request and returns the response contents as a byte array.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The content bytes.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetByteArrayAsync(System.Uri)">
            <summary>
            Performs a <b>GET</b> request and returns the response contents as a byte array.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The content bytes.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStreamAsync(System.String)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a stream.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response stream..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStreamAsync(System.Uri)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a stream.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response stream..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStringAsync(System.String)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a string.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response string..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.GetStringAsync(System.Uri)">
            <summary>
            Performs a <b>GET</b> request and returns the response as a string.
            </summary>
            <param name="requestUri">The request URI.</param>
            <returns>The response string..</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.String,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.Uri,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PostAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>POST</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.String,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.Uri,System.Net.Http.HttpContent)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.PutAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)">
            <summary>
            Performs a <b>PUT</b> request.
            </summary>
            <param name="requestUri">The request URI.</param>
            <param name="content">The request contents.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpCompletionOption)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <param name="completionOption">The completion option.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <param name="completionOption">The completion option.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="M:Neon.Xunit.TestHttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>
            Sends a request.
            </summary>
            <param name="request">The request.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The response.</returns>
        </member>
        <member name="T:Neon.Xunit.TestOutputWriter">
             <summary>
             <para>
             Wraps an <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> with a <see cref="T:System.IO.TextWriter"/> that can
             be used generate output in unit tests that will be included in the captured test log.
             </para>
             <note>
             Only the <c>Write(...)</c> and <c>WriteLine(...)</c> methods are implemented.
             </note>
             </summary>
             <exception cref="T:System.NotImplementedException">Thrown for all methods except for <c>Write(...)</c> and <c>WriteLine(...)</c>.</exception>
             <remarks>
             <para>
             To use this class, you'll need to obtain a <see cref="T:Xunit.Abstractions.ITestOutputHelper"/> instance from Xunit via 
             dependency injection by adding a parameter to your test constructor and then creating a
             <see cref="T:Neon.Xunit.TestOutputWriter"/> from it, like:
             </para>
             <code language="c#">
             public class MyTest : IClassFixture&lt;AspNetFixture&gt;
             {
                 private AspNetFixture               fixture;
                 private TestAspNetFixtureClient     client;
                 private TestOutputWriter            testWriter;
            
                 public Test_EndToEnd(AspNetFixture fixture, ITestOutputHelper outputHelper)
                 {
                     this.fixture    = fixture;
                     this.testWriter = new TestOutputWriter(outputHelper);
            
                     fixture.Start&lt;Startup&gt;(logWriter: testWriter, logLevel: Neon.Diagnostics.LogLevel.Debug);
            
                     client = new TestAspNetFixtureClient()
                     {
                         BaseAddress = fixture.BaseAddress
                     };
                  }
             }
             </code>
             </remarks>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.#ctor(Xunit.Abstractions.ITestOutputHelper)">
            <summary>
            Constructor.
            </summary>
            <param name="outputHelper">The test output helper.</param>
        </member>
        <member name="P:Neon.Xunit.TestOutputWriter.Encoding">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.FlushAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.Write(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteAsync(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLine(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Xunit.TestOutputWriter.WriteLineAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Xunit.TestTrait">
            <summary>
            Identifies the common neonFORGE related test traits.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestTrait.Category">
            <summary>
            Identifies the <b>Category</b> test trait.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestTrait.Slow">
            <summary>
            Set this category value for slow tests.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestTrait.Buggy">
            <summary>
            Set as the category value to identify test cases that appear to have
            bugs as opposed to the thing being tested having bugs.  This also 
            covers transient environmental issues generally out of control of the
            test case developer.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestTrait.Incomplete">
            <summary>
            Set as the category value to identify test cases that are still under
            development.
            </summary>
        </member>
        <member name="F:Neon.Xunit.TestTrait.Investigate">
            <summary>
            Set as the category value to identify test cases that are failing and 
            are actively under investigation.
            </summary>
        </member>
        <member name="T:Neon.Xunit.XunitExtensions">
            <summary>
            Unit test related extensions.
            </summary>
        </member>
        <member name="M:Neon.Xunit.XunitExtensions.ValidateController``1(Neon.Data.IGeneratedServiceClient)">
            <summary>
            <para>
            Compares the service model implemented by the generated service client against
            the actual ASP.NET service controller implementation.  This ensures that the
            generated client actually matches the controller implementation.
            </para>
            <note>
            <b>IMPORTANT:</b> You should always include a call to this in your service unit
            tests to ensure that the service models used to generate the service clients 
            actually match the service as implemented.  It is very likely for definitions
            and implementations to diverge over time.
            </note>
            </summary>
            <typeparam name="TServiceController">The service controller implementation type.</typeparam>
            <param name="client">The service client implementation being tested.</param>
            <exception cref="T:Neon.Xunit.IncompatibleServiceException">Thrown when the service implementaton doesn't match the generated client.</exception>
        </member>
        <member name="M:Neon.Xunit.XunitExtensions.GetMethodSignature(System.Reflection.MethodInfo,System.String,System.String,System.Boolean)">
            <summary>
            Generates a method signature for a <see cref="T:System.Reflection.MethodInfo"/> and route template.
            </summary>
            <param name="method">The method information.</param>
            <param name="httpMethod">The HTTP method required for the method call.</param>
            <param name="routeTemplate">The route template.</param>
            <param name="requireGeneratedParamAttribute">
            Indicates that only parameters tagged with <c>[GeneratedParam]</c> will be
            included in the signature.
            </param>
            <returns>The method signature.</returns>
        </member>
        <member name="M:Neon.Xunit.XunitExtensions.NormalizeType(System.Type)">
            <summary>
            Normalizes types to strings including converting <see cref="T:System.Collections.ObjectModel.ObservableCollection`1"/> 
            types to <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <param name="type">The input type.</param>
            <returns>The normalized type rendered as a string.</returns>
        </member>
    </members>
</doc>
