//-----------------------------------------------------------------------------
// FILE:	    ListWrapper.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:	Copyright (c) 2016-2019 by neonFORGE, LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;

using Neon.Common;
using Neon.Couchbase.DynamicData;

namespace Neon.Couchbase.DynamicData.Internal
{
    /// <summary>
    /// <b>Platform use only:</b> Used by <see cref="IDynamicEntity"/> implementations 
    /// to wrap a <see cref="IList"/> of simple types around a <see cref="JArray"/>.
    /// </summary>
    /// <typeparam name="TEntity">The list item type.</typeparam>
    /// <remarks>
    /// <note>
    /// This class is intended for use only by classes generated by the 
    /// <b>entity-gen</b> build tool.
    /// </note>
    /// </remarks>
    /// <threadsafety instance="false"/>
    public class ListWrapper<TEntity> : IList<TEntity>, ICollection<TEntity>, INotifyCollectionChanged
    {
        private const string DetachedError = "The underlying [JArray] has been detached.";

        private IDynamicEntity                         parentEntity;
        private JArray                          jArray;
        private ObservableCollection<TEntity>   list;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="parentEntity">The <see cref="IDynamicEntity"/> that owns this list.</param>
        /// <param name="jArray">The underlying <see cref="jArray"/>.</param>
        /// <param name="items">The initial items or <c>null</c> to initialize from <paramref name="jArray"/>.</param>
        public ListWrapper(IDynamicEntity parentEntity, JArray jArray, IEnumerable<TEntity> items)
        {
            Covenant.Requires<ArgumentNullException>(parentEntity != null, nameof(parentEntity));
            Covenant.Requires<ArgumentNullException>(jArray != null, nameof(jArray));

            this.parentEntity = parentEntity;
            this.jArray       = jArray;
            this.list         = new ObservableCollection<TEntity>();

            // Load the items.

            if (items != null)
            {
                Covenant.Assert(jArray.Count == 0);

                foreach (var item in items)
                {
                    Add(item);
                }
            }
            else
            {
                foreach (var jToken in jArray)
                {
                    list.Add(jToken.ToObject<TEntity>());
                }
            }

            // We're going to listen to our own collection changed event to
            // bubble them up.

            list.CollectionChanged +=
                (s, a) =>
                {
                    CollectionChanged?.Invoke(this, a);
                    parentEntity._OnChanged();
                };
        }

        /// <summary>
        /// Returns <c>true</c> if the list is currently attached to a <see cref="JArray"/>.
        /// </summary>
        internal bool IsAttached
        {
            get { return jArray != null; }
        }

        /// <summary>
        /// Detaches any event listeners from the underlying <see cref="jArray"/> and then
        /// disassociates the array.
        /// </summary>
        internal void Detach()
        {
            list.Clear();

            if (jArray != null)
            {
                jArray = null;
            }
        }

        /// <summary>
        /// Converts a list item into the equivalent <see cref="JToken"/>.
        /// </summary>
        private JToken ToToken(TEntity value)
        {
            return value != null ? JToken.FromObject(value) : null;
        }

        /// <summary>
        /// Creates a copy of the list suitable for enumerating over.
        /// </summary>
        /// <returns>The new list.</returns>
        private IList<TEntity> ToList()
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            var list = new List<TEntity>(jArray.Count);

            for (int i = 0; i < jArray.Count; i++)
            {
                list.Add(this[i]);
            }

            return list;
        }

        //---------------------------------------------------------------------
        // INotifyCollectionChanged implementation.

        /// <summary>
        /// Raised when the list changes.
        /// </summary>
        public event NotifyCollectionChangedEventHandler CollectionChanged;

        //---------------------------------------------------------------------
        // IList and ICollection implementations

        /// <summary>
        /// Searches the list for a specific item.
        /// </summary>
        /// <param name="item">The item to be located.</param>
        /// <returns>The index of the first item that matches the index, if found; or -1 otherwise.</returns>
        public int IndexOf(TEntity item)
        {
            return list.IndexOf(item);
        }

        /// <summary>
        /// Returns the number of items in the list.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public int Count
        {
            get
            {
                Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);
                return list.Count;
            }
        }

        /// <summary>
        /// Indicates whether the list is read-only.  This always returns <c>false.</c>
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public bool IsReadOnly
        {
            get
            {
                Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);
                return false;
            }
        }

        /// <summary>
        /// Accesses the item at an index.
        /// </summary>
        /// <param name="index">The index.</param>
        /// <returns>The element at the index.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public TEntity this[int index]
        {
            get
            {
                Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);
                return list[index];
            }

            set
            {
                Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

                jArray[index] = ToToken(value);
                list[index]   = value;
            }
        }

        /// <summary>
        /// Inserts an item at a specified index.
        /// </summary>
        /// <param name="index">The index.</param>
        /// <param name="item">The item</param>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public void Insert(int index, TEntity item)
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            jArray.Insert(index, ToToken(item));
            list.Insert(index, item);
        }

        /// <summary>
        /// Removes the item at a specified index.
        /// </summary>
        /// <param name="index">The index.</param>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public void RemoveAt(int index)
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            jArray.RemoveAt(index);
            list.RemoveAt(index);
        }

        /// <summary>
        /// Appends an item to the list.
        /// </summary>
        /// <param name="item">The item.</param>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public void Add(TEntity item)
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            jArray.Add(ToToken(item));
            list.Add(item);
        }

        /// <summary>
        /// Removes all items from the list.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public void Clear()
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            jArray.Clear();
            list.Clear();
        }

        /// <summary>
        /// Determines whether the list contains a specific item.
        /// </summary>
        /// <param name="item">The item.</param>
        /// <returns><c>true</c> if the item exists.</returns>
        public bool Contains(TEntity item)
        {
            return list.Contains(item);
        }

        /// <summary>
        /// Copies the list items to an array. 
        /// </summary>
        /// <param name="array">The destination array.</param>
        /// <param name="arrayIndex">The destination starting index.</param>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public void CopyTo(TEntity[] array, int arrayIndex)
        {
            Covenant.Requires<ArgumentNullException>(array != null, nameof(array));
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            list.CopyTo(array, arrayIndex);
        }

        /// <summary>
        /// Removes the first occurance of a specific item from the list.
        /// </summary>
        /// <param name="item">The item to be removed.</param>
        /// <returns><c>true</c> if the item was present and was removed.</returns>
        public bool Remove(TEntity item)
        {
            var index = IndexOf(item);

            if (index == -1)
            {
                return false;
            }

            RemoveAt(index);
            return true;
        }

        /// <summary>
        /// Returns a generic enumerator over the list items.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        public IEnumerator<TEntity> GetEnumerator()
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            return ((IEnumerable<TEntity>)list).GetEnumerator();
        }

        /// <summary>
        /// Returns an enumerator over the list items.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException">Thrown if the array has been detached.</exception>
        IEnumerator IEnumerable.GetEnumerator()
        {
            Covenant.Requires<InvalidOperationException>(jArray != null, DetachedError);

            return list.GetEnumerator();
        }
    }
}
