<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Neon.Temporal</name>
    </assembly>
    <members>
        <member name="T:Neon.Temporal.Activity">
            <summary>
            Provides useful information and functionality for workflow implementations.
            This will be available via the <see cref="P:Neon.Temporal.WorkflowBase.Workflow"/> property.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Activity.#ctor(Neon.Temporal.ActivityBase)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parent">The parent activity implementation.</param>
        </member>
        <member name="P:Neon.Temporal.Activity.Client">
            <summary>
            Returns the <see cref="T:Neon.Temporal.TemporalClient"/> managing this activity.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Activity.IsLocal">
            <summary>
            Returns <c>true</c> for a local activity execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Activity.CancellationToken">
            <summary>
            Returns the activity's cancellation token.  Activities can monitor this
            to gracefully handle activity cancellation.
            </summary>
            <remarks>
            <para>
            We recommend that all non-local activities that execute for relatively long periods,
            monitor <see cref="P:Neon.Temporal.Activity.CancellationToken"/> for activity cancellation so that they
            can gracefully terminate including potentially calling <see cref="M:Neon.Temporal.Activity.RecordHeartbeatAsync(System.Byte[])"/>
            to checkpoint the current activity state.
            </para>
            <para>
            Cancelled activities should throw a <see cref="T:System.Threading.Tasks.TaskCanceledException"/> from
            their entry point method rather than returning a result so that Temporal will 
            reschedule the activity if necessary.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Temporal.Activity.Task">
            <summary>
            Returns the additional information about the activity and the workflow
            that invoked it.  Note that this is not supported for local activities.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown for local activities.</exception>
        </member>
        <member name="P:Neon.Temporal.Activity.Logger">
            <summary>
            Returns the logger to be used for logging activity related events.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Activity.RecordHeartbeatAsync(System.Byte[])">
            <summary>
            <para>
            Records a heartbeat with optional details to Temporal.
            </para>
            <note>
            <b>IMPORTANT:</b> Heartbeats are not supported for local activities.
            </note>
            </summary>
            <param name="details">Optional heartbeart details.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown for local activity executions.</exception>
            <remarks>
            <para>
            Long running activities need to send periodic heartbeats back to
            Temporal to prove that the activity is still alive.  This can also
            be used by activities to implement checkpoints or record other
            details.  This method sends a heartbeat with optional details
            encoded as a byte array.
            </para>
            <note>
            The maximum allowed time period between heartbeats is specified in 
            <see cref="T:Neon.Temporal.ActivityOptions"/> when activities are executed and it's
            also possible to enable automatic heartbeats sent by the Temporal client.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Activity.HasLastHeartbeatDetailsAsync">
            <summary>
            <para>
            Determines whether the details from the last recorded heartbeat last
            failed attempt exist.
            </para>
            <note>
            <b>IMPORTANT:</b> Heartbeats are not supported for local activities.
            </note>
            </summary>
            <returns>The details from the last heartbeat or <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown for local activity executions.</exception>
        </member>
        <member name="M:Neon.Temporal.Activity.GetLastHeartbeatDetailsAsync">
            <summary>
            <para>
            Returns the details from the last recorded heartbeat last failed attempt
            at running the activity.
            </para>
            <note>
            <b>IMPORTANT:</b> Heartbeats are not supported for local activities.
            </note>
            </summary>
            <returns>The details from the last heartbeat or <c>null</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown for local activity executions.</exception>
        </member>
        <member name="M:Neon.Temporal.Activity.DoNotCompleteOnReturn">
            <summary>
            This method may be called within the activity entry point to indicate that the
            activity will be completed externally.
            </summary>
            <remarks>
            <note>
            This method is not supported for local activities.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Activity.HeartbeatAsync(System.Func{System.Byte[]},System.Nullable{System.TimeSpan})">
            <summary>
            Used to record heartbeats at a specific interval.
            </summary>
            <param name="detailsFunc">Optionally specifies a function that returns the heartbeat details.</param>
            <param name="interval">
            Optionally specifies the interval between heartbeats.  This defaults
            to 1/2 of activity's heartbeat timeout.
            </param>
            <returns><c>true</c> if a heartbeat was recorded.</returns>
            <remarks>
            <para>
            This is a convienence method that can be used to make it easy to
            restrict how often activity heartbeats are actually recorded.
            The activity can call this as often as it likes but the method
            schedules heartbeat times and only transmits a heartbeat when
            this time has been reached.
            </para>
            <para>
            By default, the method records heartbeats at 1/2 the activity's heartbeat
            timeout, but this can be customized via the <paramref name="interval"/>
            parameter.  No heartbeat details will be recorded by default, but you
            can customize this by passing a <paramref name="detailsFunc"/>.
            </para>
            <note>
            Any <paramref name="detailsFunc"/> passed will only be called when a
            heartbeat is scheduled.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.ActivityAttribute">
            <summary>
            Used to tag activity implementations that inherit from
            <see cref="T:Neon.Temporal.ActivityBase"/> to customize the how the activity is
            registered.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Optionally specifies the activity type name used to
            register an activity implementation with Temporal.
            </param>
        </member>
        <member name="P:Neon.Temporal.ActivityAttribute.Name">
            <summary>
            The activity type name.  This defaults to the fully qualified name
            of the implemented activity interface (without an leading "I").
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityAttribute.AutoRegister">
            <summary>
            Indicates that <see cref="M:Neon.Temporal.Worker.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.Boolean)"/> will
            automatically register the tagged activity implementation for the specified assembly.
            This defaults to <c>false</c>
            </summary>
        </member>
        <member name="T:Neon.Temporal.ActivityBase">
            <summary>
            Base class that must be inherited by all implementations.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityBase.#ctor">
            <summary>
            Default protected constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityBase.Initialize(Neon.Temporal.Worker,System.Type,System.Reflection.MethodInfo,Neon.Temporal.IDataConverter,System.Int64)">
            <summary>
            Called internally to initialize the activity.
            </summary>
            <param name="worker">The worker hosting the activity.</param>
            <param name="activityType">Specifies the target activity type.</param>
            <param name="activityMethod">Specifies the target activity method.</param>
            <param name="dataConverter">Specifies the data converter to be used for parameter and result serilization.</param>
            <param name="contextId">The activity's context ID.</param>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.Activity">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.Client">
            <summary>
            Returns the <see cref="T:Neon.Temporal.TemporalClient"/> managing this activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.CancellationTokenSource">
            <summary>
            Returns the <see cref="P:Neon.Temporal.ActivityBase.CancellationTokenSource"/> for the activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.CancellationToken">
            <summary>
            Returns the <see cref="P:Neon.Temporal.ActivityBase.CancellationToken"/> for thge activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.ContextId">
            <summary>
            Returns the context ID for the activity invocation.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.IsLocal">
            <summary>
            Indicates whether the activity was executed locally.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.ActivityTask">
            <summary>
            Returns additional information about the activity and the workflow that executed it.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityBase.CompleteExternally">
            <summary>
            Indicates that the activity will be completed externally.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityBase.InvokeAsync(Neon.Temporal.TemporalClient,System.Byte[])">
            <summary>
            Executes the target activity method.
            </summary>
            <param name="client">The associated Temporal client.</param>
            <param name="argBytes">The encoded activity arguments.</param>
            <returns>The encoded activity results.</returns>
        </member>
        <member name="M:Neon.Temporal.ActivityBase.OnInvokeAsync(System.Byte[])">
            <summary>
            Called internally to execute the activity.
            </summary>
            <param name="args">The encoded activity arguments.</param>
            <returns>The activity results.</returns>
        </member>
        <member name="M:Neon.Temporal.ActivityBase.EnsureNotLocal">
            <summary>
            Ensures that the activity has an associated Temporal context and thus
            is not a local actvity.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown for local activities.</exception>
        </member>
        <member name="T:Neon.Temporal.ActivityFutureStub">
            <summary>
            Used to execute an untyped activity in parallel with other activities, child
            workflows or other operations.  Instances are created via 
            <see cref="M:Neon.Temporal.Workflow.NewActivityFutureStub(System.String,Neon.Temporal.ActivityOptions)"/>.
            </summary>
        </member>
        <member name="T:Neon.Temporal.ActivityFutureStub.AsyncFuture">
            <summary>
            Implements an activity future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.AsyncFuture.#ctor(Neon.Temporal.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.AsyncFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ActivityFutureStub.AsyncFuture`1">
            <summary>
            Implements an activity future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.AsyncFuture`1.#ctor(Neon.Temporal.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.AsyncFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.#ctor(Neon.Temporal.Workflow,System.String,Neon.Temporal.ActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="activityTypeName">
            Specifies the target activity type name.
            </param>
            <param name="options">The activity options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.StartAsync``1(System.Object[])">
            <summary>
            Starts the target activity that returns <typeparamref name="TResult"/>, passing the specified arguments.
            </summary>
            <typeparam name="TResult">The activity result type.</typeparam>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub.StartAsync(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.ActivityFutureStub`1">
            <summary>
            Used to execute a typed activity in parallel with other activities, child
            workflows or other operations.  Instances are created via 
            <see cref="M:Neon.Temporal.Workflow.NewActivityFutureStub``1(System.String,Neon.Temporal.ActivityOptions)"/>.
            </summary>
            <typeparam name="TActivityInterface">Specifies the activity interface.</typeparam>
        </member>
        <member name="T:Neon.Temporal.ActivityFutureStub`1.AsyncFuture">
            <summary>
            Implements an activity future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.AsyncFuture.#ctor(Neon.Temporal.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.AsyncFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ActivityFutureStub`1.AsyncFuture`1">
            <summary>
            Implements an activity future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.AsyncFuture`1.#ctor(Neon.Temporal.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.AsyncFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.#ctor(Neon.Temporal.Workflow,System.String,Neon.Temporal.ActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="methodName">
            Optionally identifies the target activity method by the name specified in
            the <c>[ActivityMethod]</c> attribute tagging the method.  Pass a <c>null</c>
            or empty string to target the default method.
            </param>
            <param name="options">The activity options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.StartAsync``1(System.Object[])">
            <summary>
            Starts the target activity that returns <typeparamref name="TResult"/>, passing the specified arguments.
            </summary>
            <typeparam name="TResult">The activity result type.</typeparam>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ActivityFutureStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.ActivityInterfaceAttribute">
            <summary>
            Used to tag activity interfaces and optionally specify the task queue
            identifying the workers hosting this activity.  <see cref="T:Neon.Temporal.TemporalClient"/>
            for more information on how task lists work.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityInterfaceAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityInterfaceAttribute.Namespace">
            <summary>
            Optionally specifies the Temporal namespace where the activity is registered.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityInterfaceAttribute.TaskQueue">
            <summary>
            Optionally specifies the Temporal task queue identifying the workers
            hosting this activity.
            </summary>
        </member>
        <member name="T:Neon.Temporal.ActivityMethodAttribute">
            <summary>
            Used to customize activity interface method options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityMethodAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.Name">
            <summary>
            Specifies the name to be used to identify a specific activity method.  This is optional
            for activity interfaces that have only one method but is required for interfaces with
            multiple entry points.
            </summary>
            <remarks>
            <para>
            When specified, this name will be combined with the activity type name when registering
            and executing an activity via the method.  This will look like:
            </para>
            <code>
            ACTIVITY_TYPENAME::METHODNAME
            </code>
            <para>
            where <b>ACTIVITY_TYPENAME</b> is either the activity interface's fully qualified 
            name or the name specified by <see cref="P:Neon.Temporal.ActivityAttribute.Name"/> and 
            <b>METHOD_NAME</b> is from <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/>.  This
            is the same convention implemented by the Java client.
            </para>
            <para>
            Sometimes it's useful to be able to specify a workflow type name that doesn't
            follow the convention above, for example to interoperate with workflows written
            in another language..  You can do this by setting <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/> to the
            required workflow type name and then setting <see cref="P:Neon.Temporal.ActivityMethodAttribute.IsFullName"/><c>=true</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.IsFullName">
            <summary>
            <para>
            Optionally indicates that <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/> holds the fully qualified type name for
            the workflow and that the .NET client will not add a prefix to <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/>
            when registering the workflow.
            </para>
            <para>
            This is useful when interoperating with workflows written in another language by
            providing a way to specify a specific workflow type name. 
            </para>
            <note>
            <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/> cannot be <c>null</c> or empty when this is <c>true</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.HeartbeatTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum time can wait between recording
            a heartbeat before Temporal will consider the activity to have 
            timed out.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.ScheduleToCloseTimeoutSeconds">
            <summary>
            Optionally specifies the maximum total time allowed for the activity to
            complete from the time it is scheduled.  This includes the time the 
            activity is waiting to start executing on the worker, the time it takes
            for the activity to execute on the worker, as well as any time scheduling
            and performing retries.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.ScheduleToStartTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum time the activity may remain 
            in the task queue before being assigned to a worker.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.StartToCloseTimeoutSeconds">
            <summary>
            <para>
            Optionally specifies the maximum execution time for
            an individual workflow task once it has been assigned
            to a worker.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.TaskQueue">
            <summary>
            <para>
            Optionally specifies the target task queue.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityMethodAttribute.Namespace">
            <summary>
            <para>
            Optionally specifies the target namespace.
            </para>
            </summary>
        </member>
        <member name="T:Neon.Temporal.ActivityOptions">
            <summary>
            Specifies the options used for executing an activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityOptions.Normalize(Neon.Temporal.TemporalClient,Neon.Temporal.ActivityOptions,System.Type,System.Reflection.MethodInfo)">
            <summary>
            Normalizes the options passed by creating or cloning a new instance as
            required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Temporal client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <param name="activityInterface">Optionally specifies the activity interface definition.</param>
            /// <param name="method">Optionally specifies the target workflow method.</param>
            <returns>The normalized options.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if a valid task queue is not specified.</exception>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.TaskQueue">
            <summary>
            Optionally specifies the target Temporal task queue.  This defaults to the task queue
            specified by <see cref="P:Neon.Temporal.ActivityMethodAttribute.TaskQueue"/>,
            <see cref="P:Neon.Temporal.ActivityInterfaceAttribute.TaskQueue"/>, or the parent workflow's
            task queue, in that order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.Namespace">
            <summary>
            Optionally specifies the target Temporal namespace.  This defaults to the domain
            specified by <see cref="P:Neon.Temporal.ActivityMethodAttribute.Namespace"/>, 
            <see cref="P:Neon.Temporal.ActivityInterfaceAttribute.Namespace"/>, or 
            to the parent workflow's namespace, in that order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.ScheduleToCloseTimeout">
            <summary>
            Optionally specifies the end-to-end timeout for the activity.  The 
            default <see cref="F:System.TimeSpan.Zero"/> value uses the sum of 
            <see cref="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout"/> and <see cref="P:Neon.Temporal.ActivityOptions.StartToCloseTimeout"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout">
            <summary>
            Specifies the maximum time the activity be queued, waiting to be scheduled
            on a worker.  This defaults to <see cref="P:Neon.Temporal.TemporalSettings.ActivityScheduleToStartTimeoutSeconds"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.StartToCloseTimeout">
            <summary>
            Specifies the maximum time the activity may take to run.  This defaults to
            <see cref="P:Neon.Temporal.TemporalSettings.ActivityStartToCloseTimeoutSeconds"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.HeartbeatTimeout">
            <summary>
            Optionally specifies the maximum time the activity has to send a heartbeat
            back to Temporal.  This defaults to <see cref="F:System.TimeSpan.Zero"/> which indicates
            that no heartbeating is required.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.WaitForCancellation">
            <summary>
            Optionally specifies that the cancelled activities won't be considered to be
            finished until they actually complete.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ActivityOptions.RetryPolicy">
            <summary>
            Optionally specifies the activity retry policy.  The default value is <c>null</c> which indicates
            that there will be no retry attempts.
            </summary>
            <remarks>
            <para>
            When <see cref="P:Neon.Temporal.RetryPolicy.ExpirationInterval"/> is specified and it is larger than the activity's 
            <see cref="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout"/>, then the <see cref="P:Neon.Temporal.RetryPolicy.ExpirationInterval"/> will override 
            activity's <see cref="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout"/>. This is to avoid retrying on <see cref="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout"/>
            error which only happen when worker is not picking up the task within the timeout.
            </para>
            <para>
            Retrying <see cref="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout"/> does not make sense as it just
            mark the task as failed and create a new task and put back in the queue waiting worker to pick again. Temporal
            server also make sure the <see cref="P:Neon.Temporal.ActivityOptions.ScheduleToStartTimeout"/> will not be larger than the workflow's timeout.
            The same applies to <see cref="P:Neon.Temporal.ActivityOptions.StartToCloseTimeout"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ActivityOptions.Clone">
            <summary>
            Returns a shallow clone of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Temporal.ActivityOptions"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.ActivityStub">
            <summary>
            Used to execute an untyped activity whose .NET type information is not known
            at runtime or an activity written in different languages.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityStub.#ctor(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,System.String,Neon.Temporal.ActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="parentWorkflow">Identifies the parent workflow.</param>
            <param name="activityTypeName">Specifies the target activity type name.</param>
            <param name="options">Optionally specifies custom activity options.</param>
            <remarks>
            <para>
            <paramref name="activityTypeName"/> specifies the target activity implementation type name and optionally,
            the specific activity method to be called for activity interfaces that have multiple methods.  For
            activity methods tagged by <c>ActivityMethod]</c>[ with specifying a name, the activity type name will default
            to the fully qualified interface type name or the custom type name specified by <see cref="P:Neon.Temporal.ActivityAttribute.Name"/>.
            </para>
            <para>
            For activity methods with <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/> specified, the activity type will
            look like this by default:
            </para>
            <code>
            ACTIVITY-TYPE-NAME::METHOD-NAME
            </code>
            <note>
            You may need to customize activity type name when interoperating with activities written
            in other languages.  See <a href="https://doc.neonkube.com/Neon.Temporal-CrossPlatform.htm">Temporal Cross-Platform</a>
            for more information.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ActivityStub.ExecuteAsync(System.Object[])">
            <summary>
            Executes an activity that doesn't return a result (or when the caller doesn't
            care about the result).
            </summary>
            <param name="args">The activity arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ActivityStub.ExecuteAsync``1(System.Object[])">
            <summary>
            Executes an activity by activity type name that returns the <typeparamref name="TResult"/>.
            </summary>
            <typeparam name="TResult">The activity result type. </typeparam>
            <param name="args">The activity arguments.</param>
            <returns>The activity result.</returns>
        </member>
        <member name="T:Neon.Temporal.ArchivalState">
            <summary>
            Controls archival.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ArchivalState.Unspecified">
            <summary>
            Archival unspecified.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ArchivalState.Disabled">
            <summary>
            Disables archival.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ArchivalState.Enabled">
            <summary>
            Enables archival.
            </summary>
        </member>
        <member name="T:Neon.Temporal.BadBinaries">
            <summary>
            Temporal Bad Binaries.
            </summary>
        </member>
        <member name="F:Neon.Temporal.BadBinaries.Binaries">
            <summary>
            Dictionary of string identifier to <see cref="T:Neon.Temporal.BadBinaryInfo"/>.
            </summary>
        </member>
        <member name="T:Neon.Temporal.BadBinaryInfo">
            <summary>
            Defines information about a bad binary.
            </summary>
        </member>
        <member name="P:Neon.Temporal.BadBinaryInfo.Reason">
            <summary>
            Reason for bad binary.
            </summary>
        </member>
        <member name="P:Neon.Temporal.BadBinaryInfo.Operator">
            <summary>
            The Operator of bad binary.
            </summary>
        </member>
        <member name="P:Neon.Temporal.BadBinaryInfo.CreateTime">
            <summary>
            Creation time of bad binary.
            </summary>
        </member>
        <member name="T:Neon.Temporal.ChildWorkflowFuture">
            <summary>
            Implements a child workflow future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFuture.#ctor(Neon.Temporal.Workflow,Neon.Temporal.Internal.ChildExecution)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="childExecution">The child workflow execution.</param>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowFuture.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ChildWorkflowFuture`1">
            <summary>
            Implements a child workflow future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFuture`1.#ctor(Neon.Temporal.Workflow,Neon.Temporal.Internal.ChildExecution)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="childExecution">The child workflow execution.</param>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowFuture`1.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ChildWorkflowFutureStub">
            <summary>
            <para>
            Manages starting and signalling a child workflow instance based on
            its workflow type name and arguments.  This is useful when you need
            to perform other operations in parallel with a child by separating
            workflow execution and retrieving the result into separate operations.
            </para>
            <para>
            Use this version for workflows that don't return a result.
            </para>
            </summary>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFutureStub.#ctor(Neon.Temporal.Workflow,System.String,Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="options">Optional child workflow options.</param>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowFutureStub.Options">
            <summary>
            Returns the child workflow options.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowFutureStub.WorkflowTypeName">
            <summary>
            Returns the workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowFutureStub.Execution">
            <summary>
            Returns the child workflow <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the workflow has not been started.</exception>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFutureStub.StartAsync(System.Object[])">
            <summary>
            Starts the child workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the workflow to complete.  This version doesn't return a workflow result.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Temporal.ChildWorkflowFuture"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFutureStub.StartAsync``1(System.Object[])">
            <summary>
            Starts the child workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the the workflow to complete and obtain its result.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Temporal.ChildWorkflowFuture`1"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowFutureStub.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">The signal name.</param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has not been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow signal arguments.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.UntypedChildWorkflowFutureStub`1">
            <summary>
            <para>
            Manages starting and signalling a child workflow instance based on
            its workflow type name and arguments.  This is useful when you need
            to perform other operations in parallel with a child.
            </para>
            <para>
            Use this version for workflows that return a result.
            </para>
            </summary>
            <typeparam name="TResult">Specifies the workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.UntypedChildWorkflowFutureStub`1.#ctor(Neon.Temporal.Workflow,System.String,Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="options">Optional child workflow options.</param>
        </member>
        <member name="P:Neon.Temporal.UntypedChildWorkflowFutureStub`1.Options">
            <summary>
            Returns the child workflow options.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UntypedChildWorkflowFutureStub`1.WorkflowTypeName">
            <summary>
            Returns the workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UntypedChildWorkflowFutureStub`1.Execution">
            <summary>
            Returns the child workflow <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the workflow has not been started.</exception>
        </member>
        <member name="M:Neon.Temporal.UntypedChildWorkflowFutureStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the child workflow, returning an <see cref="T:Neon.Temporal.ChildWorkflowFuture`1"/> that can be used
            to retrieve the workflow result.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Temporal.ChildWorkflowFuture`1"/> that can be used to retrieve the workflow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters and 
            result type passed are compatible with the target workflow arguments.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.UntypedChildWorkflowFutureStub`1.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">The signal name.</param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has not been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow signal arguments.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.ChildWorkflowOptions">
            <summary>
            Specifies the options to use when executing a child workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowOptions.Normalize(Neon.Temporal.TemporalClient,Neon.Temporal.ChildWorkflowOptions,System.Type,System.Reflection.MethodInfo)">
            <summary>
            <b>INTERNAL USE ONLY:</b> Normalizes the options passed by creating or cloning a new 
            instance as required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Temporal client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <param name="workflowInterface">Optionally specifies the workflow interface definition.</param>
            /// <param name="method">Optionally specifies the target workflow method.</param>
            <returns>The normalized options.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if a valid task queue is not specified.</exception>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.Namespace">
            <summary>
            Optionally specifies the target namespace.  This defaults to the namespace
            specified by <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Namespace"/>, 
            <see cref="P:Neon.Temporal.WorkflowInterfaceAttribute.Namespace"/>, or 
            to the client's default namespace as specified by <see cref="P:Neon.Temporal.TemporalSettings.Namespace"/>
            (in that order of precedence).
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.WorkflowId">
            <summary>
            Optionally specifies the workflow ID to assign to the child workflow.
            A UUID will be generated by default.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.TaskQueue">
            <summary>
            Optionally specifies the Temporal task queue where the child workflow will be
            scheduled.  This defaults to the namespace specified by <see cref="P:Neon.Temporal.WorkflowMethodAttribute.TaskQueue"/>
            or <see cref="P:Neon.Temporal.WorkflowInterfaceAttribute.TaskQueue"/>, or the parent workflow's
            domain, in that order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.WorkflowExecutionTimeout">
            <summary>
            Specifies the maximum time the child workflow may execute from start
            to finish.  This defaults to <see cref="P:Neon.Temporal.TemporalSettings.WorkflowExecutionTimeoutSeconds"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.WorkflowRunTimeout">
            <summary>
            Optionally specifies the timeout for a single run of the child workflow execution. Each retry or
            continue as new should obey this timeout. Use WorkflowExecutionTimeout to specify how long the parent
            is willing to wait for the child completion.
            Defaults to WorkflowExecutionTimeout
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.WorkflowTaskTimeout">
            <summary>
            Optionally specifies the decision task timeout for the child workflow.
            This defaults to <see cref="P:Neon.Temporal.TemporalSettings.WorkflowTaskTimeout"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.ChildPolicy">
            <summary>
            Optionally specifies what happens to the child workflow when the parent is terminated.
            This defaults to <see cref="F:Neon.Temporal.ParentClosePolicy.RequestCancel"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.WaitForCancellation">
            <summary>
            Optionally specifies whether to wait for canceled child workflow to be ended (child workflow can be ended
            as: completed/failed/timedout/terminated/canceled).
            Defaults to false.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.WorkflowIdReusePolicy">
            <summary>
            Optionally determines how Temporal handles workflows that attempt to reuse workflow IDs.
            This generally defaults to <see cref="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicate"/>
            but the default can be customized via the <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> tagging
            the workflow entry point method or <see cref="P:Neon.Temporal.TemporalSettings.WorkflowIdReusePolicy"/>
            (which also defaults to <see cref="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicate"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.RetryPolicy">
            <summary>
            Optionally specifies retry policy.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowOptions.CronSchedule">
            <summary>
            Optionally specifies a recurring schedule for the workflow.  This can be set to a string specifying
            the minute, hour, day of month, month, and day of week scheduling parameters using the standard Linux
            CRON format described here: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>
            </summary>
            <remarks>
            <para>
            Temporal accepts a CRON string formatted as a single line of text with 5 parameters separated by
            spaces.  The parameters specified the minute, hour, day of month, month, and day of week values:
            </para>
            <code>
             minute (0 - 59)
              hour (0 - 23)
               day of the month (1 - 31)
                month (1 - 12)
                 day of the week (0 - 6) (Sunday to Saturday)
                
                
            * * * * * 
            </code>
            <para>
            Each parameter may be set to one of:
            </para>
            <list type="table">
            <item>
                <term><b>*</b></term>
                <description>
                Matches any value.
                </description>
            </item>
            <item>
                <term><b>value</b></term>
                <description>
                Matches a specific integer value.
                </description>
            </item>
            <item>
                <term><b>first-last</b></term>
                <description>
                Matches a range of integer values (inclusive).
                </description>
            </item>
            <item>
                <term><b>value1,value2,...</b></term>
                <description>
                Matches a list of integer values.
                </description>
            </item>
            <item>
                <term><b>first/step</b></term>
                <description>
                Matches values starting at <b>first</b> and then succeeding incremented by <b>step</b>.
                </description>
            </item>
            </list>
            <para>
            You can use this handy CRON calculator to see how this works: <a href="https://crontab.guru">https://crontab.guru</a>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowOptions.Clone">
            <summary>
            Returns a shallow clone of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Temporal.StartWorkflowOptions"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowOptions.ToWorkflowOptions">
            <summary>
            Used internally within generated workflow stubs to convert a <see cref="T:Neon.Temporal.ChildWorkflowOptions"/>
            instance into an equivalent <see cref="T:Neon.Temporal.StartWorkflowOptions"/> as a bit of a hack.
            </summary>
            <returns>The converted <see cref="T:Neon.Temporal.StartWorkflowOptions"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.ChildWorkflowStub`1">
            <summary>
            Used to execute a child workflow in parallel with other child workflows or activities.
            Instances are created via <see cref="M:Neon.Temporal.Workflow.NewChildWorkflowFutureStub``1(System.String,Neon.Temporal.ChildWorkflowOptions)"/>.
            </summary>
            <typeparam name="TWorkflowInterface">Specifies the workflow interface.</typeparam>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowStub`1.#ctor(Neon.Temporal.Workflow,System.String,Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="methodName">Identifies the target workflow method or <c>null</c> or empty.</param>
            <param name="options">The child workflow options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowStub`1.StartAsync``1(System.Object[])">
            <summary>
            Starts the target workflow that returns <typeparamref name="TResult"/>, passing any specified arguments.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The arguments to be passed to the workflow.</param>
            <returns>The <see cref="T:Neon.Temporal.ChildWorkflowFuture`1"/> with the <see cref="M:Neon.Temporal.ChildWorkflowFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target workflow parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ChildWorkflowStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ChildWorkflowStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the target workflow that returns <c>void</c>, passing any specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the workflow.</param>
            <returns>The <see cref="T:Neon.Temporal.ChildWorkflowFuture`1"/> with the <see cref="M:Neon.Temporal.ChildWorkflowFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a future stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target workflow parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ChildWorkflowStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="P:Neon.Temporal.ChildWorkflowStub`1.Stub">
            <summary>
            <para>
            Returns the underlying <typeparamref name="TWorkflowInterface"/> stub for the child workflow.
            This includes all the workflow entrypoint, query and signal methods.
            </para>
            <note>
            The entrypoint methods won't work because the workflow will already be running but you can
            interact with the child workflow using any query and signal methods.       
            </note>
            </summary>
        </member>
        <member name="T:Neon.Temporal.ClusterReplicationConfig">
            <summary>
            Defines configuration for cluster replication.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ClusterReplicationConfig.ClusterName">
            <summary>
            The Name of the replication cluster.
            </summary>
        </member>
        <member name="T:Neon.Temporal.ContinueAsNewOptions">
            <summary>
            Specifies the options to be used when continuing a workflow as a 
            new instance.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.ExecutionStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.ScheduleToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.ScheduleToStartTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.TaskStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's decision task timeout for 
            the restarted workflow when this value is greater than <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.Workflow">
            <summary>
            Optionally overrides the name of the workflow to continue as new.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.TaskQueue">
            <summary>
            Optionally overrides the current workflow's task queue when restarting.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.Namespace">
            <summary>
            Optionally overrides the current workflow's namespace when restarting.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewOptions.RetryPolicy">
            <summary>
            Optionally overrides the current workflow's retry options when restarting.
            </summary>
        </member>
        <member name="T:Neon.Temporal.GoTimeSpanJsonConverter">
            <summary>
            <para>
            Implements a type converter for <see cref="T:System.TimeSpan"/> using the culture
            Go Language formatted time.  This serializes <see cref="T:System.TimeSpan"/> instances
            in nanoseconds as a long.  The maximum <see cref="T:System.TimeSpan"/> that this converter
            can accurately handle is about 290 year.  Any amount of time larger than 290 years
            is not suitable for this serializer.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.GoTimeSpanJsonConverter.Type">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.GoTimeSpanJsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.TimeSpan,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.GoTimeSpanJsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.TimeSpan,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.GoTimeSpanJsonConverter.ToSimpleString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.AccessDeniedException">
            <summary>
            Thrown when an operation cannot be performed to access limits.
            </summary>
        </member>
        <member name="M:Neon.Temporal.AccessDeniedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.AccessDeniedException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.AccessDeniedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ActivityHeartbeatTimeoutException">
            <summary>
            Thrown when an activity did not send a timely heartbeat to Temporal.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityHeartbeatTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.ActivityHeartbeatTimeoutException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.ActivityHeartbeatTimeoutException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ActivityTypeException">
            <summary>
            Thrown when ak activity interface or implementation is not valid.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityTypeException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ActivityTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="T:Neon.Temporal.BadRequestException">
            <summary>
            Thrown when a Temporal receives an invalid request.
            </summary>
        </member>
        <member name="M:Neon.Temporal.BadRequestException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.BadRequestException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.BadRequestException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.CancellationAlreadyRequestedException">
            <summary>
            Thrown when attempting to cancel an operation that has already been cancelled.
            </summary>
        </member>
        <member name="M:Neon.Temporal.CancellationAlreadyRequestedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.CancellationAlreadyRequestedException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.CancellationAlreadyRequestedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.CancelledException">
            <summary>
            Thrown when a Temporal operation is cancelled.
            </summary>
        </member>
        <member name="M:Neon.Temporal.CancelledException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.CancelledException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ClientVersionNotSupportedException">
            <summary>
            Thrown when the underlying GOLANG client version is not supported by the Temporal cluster.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ClientVersionNotSupportedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.ClientVersionNotSupportedException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.ClientVersionNotSupportedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ConnectException">
            <summary>
            Thrown when a Temporal connection could not be established.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ConnectException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.ConnectException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ContinueAsNewException">
            <summary>
            <b>INTERNAL USE ONLY:</b> Thrown by <see cref="M:Neon.Temporal.Workflow.ContinueAsNewAsync(Neon.Temporal.ContinueAsNewOptions,System.Object[])"/>
            or <see cref="M:Neon.Temporal.Workflow.ContinueAsNewAsync(System.Object[])"/> as well as any continue-as-new stubs to be handled 
            internally by <see cref="T:Neon.Temporal.WorkflowBase"/>.
            </summary>
            <remarks>
            <para>
            If your workflow needs a general exception handler, you should include
            a <c>catch</c> clause that catches and rethrows any <see cref="T:Neon.Temporal.TemporalInternalException"/>
            derived exceptions before your custom handler.  This will look something like:
            </para>
            <code language="c#">
            public class MyWorkflow
            {
                public Task Entrypoint()
                {
                    try
                    {
                        // Workflow implementation.
                    }
                    catch (TemporalInternalException)
                    {
                        // Rethrow so Temporal can handle these exceptions.        
            
                        throw;
                    }
                    catch (Exception e)
                    {
                        // Your exception handler.
                    }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.ContinueAsNewException.#ctor(System.Byte[],System.String,System.String,System.String,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan,Neon.Temporal.RetryPolicy)">
            <summary>
            Constructs an instance using explicit arguments.
            </summary>
            <param name="args">Optional arguments for the new execution.</param>
            <param name="workflow">Optional workflow for the new execution.</param>
            <param name="namespace">Optional namespace for the new execution.</param>
            <param name="taskQueue">Optional task queue for the new execution.</param>
            <param name="startToCloseTimeout">Optional execution to start timeout for the new execution.</param>
            <param name="scheduleToCloseTimeout">Optional schedule to close timeout for the new execution.</param>
            <param name="scheduleToStartTimeout">Optional schedule to start timeout for the new execution.</param>
            <param name="decisionTaskTimeout">Optional decision task start to close timeout for the new execution.</param>
            <param name="retryPolicy">Optional retry options for the new execution.</param>
        </member>
        <member name="M:Neon.Temporal.ContinueAsNewException.#ctor(System.Byte[],Neon.Temporal.ContinueAsNewOptions)">
            <summary>
            Constructs an instance using a <see cref="T:Neon.Temporal.ContinueAsNewOptions"/>.
            </summary>
            <param name="args">Arguments for the new execution (this may be <c>null)</c>).</param>
            <param name="options">Options for the new execution  (this may be <c>null</c>).</param>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.Args">
            <summary>
            Returns the arguments for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.Workflow">
            <summary>
            Optionally overrides the name of the workflow to continue as new.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.Namespace">
            <summary>
            Optionally specifies the new namespace for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.TaskQueue">
            <summary>
            Optionally specifies the new task queue for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.StartToCloseTimeout">
            <summary>
            Optionally specifies the new timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.ScheduleToCloseTimeout">
            <summary>
            Optionally specifies the new timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.ScheduleToStartTimeout">
            <summary>
            Optionally specifies the new timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.DecisionTaskTimeout">
            <summary>
            Optionally specifies the new decision task timeout for the next workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.ContinueAsNewException.RetryPolicy">
            <summary>
            Optionally specifies the new retry options for the next workflow execution.
            </summary>
        </member>
        <member name="T:Neon.Temporal.EntityNotExistsException">
            <summary>
            Thrown when a Temporal request references an entity that doesn't exist.
            </summary>
        </member>
        <member name="M:Neon.Temporal.EntityNotExistsException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.EntityNotExistsException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.EntityNotExistsException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ForceReplayException">
            <summary>
            Thrown internally by <see cref="M:Neon.Temporal.Workflow.ForceReplayAsync"/> to be handled internally by
            <see cref="T:Neon.Temporal.WorkflowBase"/>.
            a workflow.
            </summary>
            <remarks>
            <para>
            If your workflow needs a general exception handler, you should include
            a <c>catch</c> clause that catches and rethrows any <see cref="T:Neon.Temporal.TemporalInternalException"/>
            derived exceptions before your custom handler.  This will look something like:
            </para>
            <code language="c#">
            public class MyWorkflow
            {
                public Task Entrypoint()
                {
                    try
                    {
                        // Workflow implementation.
                    }
                    catch (TemporalInternalException)
                    {
                        // Rethrow so Temporal can handle these exceptions.        
            
                        throw;
                    }
                    catch (Exception e)
                    {
                        // Your exception handler.
                    }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.InternalServiceException">
            <summary>
            Thrown when a Temporal experienced an internal error.
            </summary>
        </member>
        <member name="M:Neon.Temporal.InternalServiceException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.InternalServiceException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.InternalServiceException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.LimitExceededException">
            <summary>
            Thrown when a Temporal workflow query failed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.LimitExceededException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.LimitExceededException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.LimitExceededException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.NamespaceAlreadyExistsException">
            <summary>
            Thrown when a Temporal namespace already exists.
            </summary>
        </member>
        <member name="M:Neon.Temporal.NamespaceAlreadyExistsException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.NamespaceAlreadyExistsException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.NamespaceAlreadyExistsException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.NamespaceNotActiveException">
            <summary>
            Thrown when a Temporal namespace has been deprecated.
            </summary>
        </member>
        <member name="M:Neon.Temporal.NamespaceNotActiveException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.NamespaceNotActiveException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.NamespaceNotActiveException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.QueryFailedException">
            <summary>
            Thrown when a Temporal workflow query failed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.QueryFailedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.QueryFailedException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.QueryFailedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.RegistrationException">
            <summary>
            Thrown for workflow and activity registration problems.
            </summary>
        </member>
        <member name="M:Neon.Temporal.RegistrationException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Specifies the exception message.</param>
        </member>
        <member name="T:Neon.Temporal.RetryTaskException">
            <summary>
            Thrown when a workflow task could not be retried.
            </summary>
        </member>
        <member name="M:Neon.Temporal.RetryTaskException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.RetryTaskException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.RetryTaskException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.ServiceBusyException">
            <summary>
            Thrown when the Temporal cluster is too busy to perform an operation.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ServiceBusyException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.ServiceBusyException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.ServiceBusyException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.StartToCloseTimeoutException">
            <summary>
            Thrown when a workflow or activity did not complete within the required time.
            </summary>
        </member>
        <member name="M:Neon.Temporal.StartToCloseTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.StartToCloseTimeoutException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.StartToCloseTimeoutException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.StubCompilerException">
            <summary>
            Thrown when there's a problem compiling a workflow or activity stub.
            </summary>
        </member>
        <member name="M:Neon.Temporal.StubCompilerException.GetMessage(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.String)">
            <summary>
            Converts compiler diagnostics into a string.
            </summary>
            <param name="diagnostics">The compiler diagnostics.</param>
            <param name="source">Optionally specifies the invalid source code.</param>
            <returns>The message string.</returns>
        </member>
        <member name="M:Neon.Temporal.StubCompilerException.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="diagnostics">The compiler diagnostics.</param>
            <param name="source">Optionally specifies the invalid source code.</param>
        </member>
        <member name="T:Neon.Temporal.SyncSignalException">
            <summary>
            Thrown when a synchronous signal sent to a workflow fails.
            </summary>
        </member>
        <member name="M:Neon.Temporal.SyncSignalException.GetError(System.Exception)">
            <summary>
            Converts an exception into a string suitable for using to construct
            a <see cref="T:Neon.Temporal.SyncSignalException"/>.
            </summary>
            <param name="e">The exception.</param>
            <returns>The formatted error string.</returns>
        </member>
        <member name="M:Neon.Temporal.SyncSignalException.GetError``1(System.String)">
            <summary>
            Converts an exception type and message into a string suitable for using to construct
            a <see cref="T:Neon.Temporal.SyncSignalException"/>.
            </summary>
            <typeparam name="TException">The exception type.</typeparam>
            <param name="message">The error message.</param>
            <returns>The formatted error string.</returns>
        </member>
        <member name="M:Neon.Temporal.SyncSignalException.GetMessage(System.String)">
            <summary>
            Extracts the message from the error string.
            </summary>
            <param name="error">The error string.</param>
            <returns>The message.</returns>
        </member>
        <member name="M:Neon.Temporal.SyncSignalException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="error">The error information as formatted by <see cref="M:Neon.Temporal.SyncSignalException.GetError(System.Exception)"/>.</param>
        </member>
        <member name="P:Neon.Temporal.SyncSignalException.ExceptionName">
            <summary>
            The fully qualified name of the exception thrown by the target signal method.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TemporalCustomException">
            <summary>
            Thrown when a Temporal <b>custom</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalCustomException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalCustomException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.TemporalException">
            <summary>
            Base class for all Temporal related exceptions.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalException.TemporalError">
            <summary>
            Returns the Temporal GOLANG client's error string corresponding to the
            exception or <c>null</c> when the exception does not map to an
            error string.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalException.TemporalErrorType">
            <summary>
            Returns the Temporal error type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalException.Reason">
            <summary>
            The Temporal error reason used for specifying non-retryable errors
            within a <see cref="T:Neon.Temporal.RetryPolicy"/> instance.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalException.ToTemporalError">
            <summary>
            Converts the exception into a <see cref="P:Neon.Temporal.TemporalException.TemporalError"/>.
            </summary>
            <returns>The <see cref="P:Neon.Temporal.TemporalException.TemporalError"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.TemporalGenericException">
            <summary>
            Thrown when a Temporal <b>generic</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalGenericException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalGenericException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.TemporalInternalException">
            <summary>
            Base class for Temporal exceptions that must not be caught and handled
            by workflow entry point methods.  The Temporal client must be allowed
            to handle these.
            </summary>
            <remarks>
            <para>
            If your workflow needs a general exception handler, you should include
            a <c>catch</c> clause that catches and rethrows any derived exceptions
            before your custom handler.  This will look something like:
            </para>
            <code language="c#">
            public class MyWorkflow
            {
                public Task Entrypoint()
                {
                    try
                    {
                        // Workflow implementation.
                    }
                    catch (TemporalInternalException)
                    {
                        // Rethrow so Temporal can handle these exceptions.        
            
                        throw;
                    }
                    catch (Exception e)
                    {
                        // Your exception handler.
                    }
                }
            }
            </code>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.TemporalPanicException">
            <summary>
            Thrown when a Temporal <b>panic</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalPanicException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalPanicException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.TemporalTimeoutException">
            <summary>
            Indicates that a Temporal operation timed out.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalTimeoutException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalTimeoutException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.TerminatedException">
            <summary>
            Thrown when a Temporal <b>terminated</b> error is encountered.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TerminatedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.TerminatedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.WaitForSignalReplyException">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Thrown by workflow synchronous signal methods when the
            signal has been marshalled to the workflow method via a <see cref="T:Neon.Temporal.WorkflowQueue`1"/>
            and the workflow method will handle the signal reply.
            </para>
            <note>
            Synchronous signals are an experimental feature that will likely be replaced
            in the coming months by a new Temporal feature.
            </note>
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowExecutionAlreadyStartedException">
            <summary>
            Thrown when attempting to cancel an operation that has already been cancelled.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowExecutionAlreadyStartedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.WorkflowExecutionAlreadyStartedException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.WorkflowExecutionAlreadyStartedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.WorkflowParallelOperationException">
            <summary>
            Thrown when an operation is requested on an executing workflow while 
            another operation is already pending.  Workflows cannot have multiple
            operations running in parallel because this will likely break 
            workflow determinism.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowParallelOperationException.#ctor(System.String[])">
            <summary>
            Consutuctor.
            </summary>
            <param name="otherStackTraces">
            Optionally specifies the stack traces for the other pending operations
            that triggered this exception.
            </param>
        </member>
        <member name="P:Neon.Temporal.WorkflowParallelOperationException.OtherStackTraces">
            <summary>
            Returns the stack traces for the other pending operations when <see cref="P:Neon.Temporal.TemporalSettings.Debug"/>
            is set to <c>true</c>.  You can use this to discover where the other pending operations that
            triggered this exception were initiated.  The current operation stack trace will be available
            as <see cref="P:System.Exception.StackTrace"/> property on this exception.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowQueueClosedException">
            <summary>
            Indicates that a Temporal <see cref="M:Neon.Temporal.WorkflowQueue`1.DequeueAsync(System.TimeSpan)"/> operation
            failed because the queue has been closed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueueClosedException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies the inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.WorkflowQueueClosedException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.WorkflowRunningException">
            <summary>
            Thrown when a workflow cannot be started because another workflow with
            the same ID is already running.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowRunningException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">Optionally specifies a message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="P:Neon.Temporal.WorkflowRunningException.TemporalError">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.WorkflowRunningException.TemporalErrorType">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.WorkflowTypeException">
            <summary>
            Thrown when ak workflow interface or implementation is not valid.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowTypeException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">Optionally specifies an inner exception.</param>
        </member>
        <member name="T:Neon.Temporal.ExternalWorkflowFuture">
            <summary>
            Implements an external workflow future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowFuture.#ctor(Neon.Temporal.TemporalClient,Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="execution">The workflow execution.</param>
            /// <param name="namespace">Optionally specifies the target namespace.  This defaults to the default client namespace.</param>
        </member>
        <member name="P:Neon.Temporal.ExternalWorkflowFuture.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowFuture.GetAsync">
            <summary>
            Waits for the workflow to complete.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.ExternalWorkflowFuture`1">
            <summary>
            Implements an external workflow future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowFuture`1.#ctor(Neon.Temporal.TemporalClient,Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="execution">The workflow execution.</param>
            /// <param name="namespace">Optionally specifies the target namespace.  This defaults to the default client namespace.</param>
        </member>
        <member name="P:Neon.Temporal.ExternalWorkflowFuture`1.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowFuture`1.GetAsync">
            <summary>
            Waits for the workflow to complete.
            </summary>
            <returns>The workflow result.</returns>
        </member>
        <member name="T:Neon.Temporal.ExternalWorkflowStub">
            <summary>
            Supports signalling and cancelling any workflow.  This is useful when an
            external workflow interface type is not known at compile time or to manage 
            workflows written in another language.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.ILocalOperations.CancelAsync(Neon.Temporal.WorkflowExecution)">
            <summary>
            Cancels the specified workflow.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.ILocalOperations.GetResultAsync(Neon.Temporal.WorkflowExecution)">
            <summary>
            Waits for the specified workflow to complete.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.ILocalOperations.GetResultBytesAsync(Neon.Temporal.WorkflowExecution)">
            <summary>
            Waits for the specified workflow to complete and then returns the
            workflow result.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <returns>The workflow result.</returns>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.ILocalOperations.SignalAsync(Neon.Temporal.WorkflowExecution,System.String,System.Object[])">
            <summary>
            Signals the specified workflow.
            </summary>
            <param name="execution">The target workflow execution.</param>
            <param name="signalName">The signal name.</param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.#ctor(Neon.Temporal.TemporalClient,Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Internal constructor for use outside of a workflow.
            </summary>
            <param name="client">Specifies the associated client.</param>
            <param name="execution">Specifies the target workflow execution.</param>
            <param name="namespace">Optionally specifies the target namespace (defaults to the client's default namespace).</param>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.#ctor(Neon.Temporal.Workflow,Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Internal constructor for use within a workflow.
            </summary>
            <param name="parentWorkflow">Specifies the parent workflow.</param>
            <param name="execution">Specifies the target workflow execution.</param>
            <param name="namespace">Optionally specifies the target namespace (defaults to the client's default namespace).</param>
        </member>
        <member name="P:Neon.Temporal.ExternalWorkflowStub.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.CancelAsync">
            <summary>
            Cancels the workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">Specifies the signal name.</param>
            <param name="args">Specifies the signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.GetResultAsync">
            <summary>
            Waits for the workflow complete if necessary, without returning the result.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.ExternalWorkflowStub.GetResultAsync``1">
            <summary>
            Returns the workflow result, waiting for the workflow to complete if necessary.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <returns>The workflow result.</returns>
        </member>
        <member name="T:Neon.Temporal.IActivity">
            <summary>
            All activity interfaces must derive from this interface.
            </summary>
        </member>
        <member name="T:Neon.Temporal.IDataConverter">
            <summary>
            Used by <see cref="T:Neon.Temporal.Worker"/> instances to manage serialization of method parameters and results
            for workflow and activity methods to/from byte arrays for persistence in the Temporal cluster
            database.
            </summary>
        </member>
        <member name="M:Neon.Temporal.IDataConverter.FromData``1(System.Byte[])">
            <summary>
            Deserializes a single value from a byte array as the specified generic type parameter.
            </summary>
            <typeparam name="T">Specifies the result type.</typeparam>
            <param name="content">The input bytes.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:Neon.Temporal.IDataConverter.FromData(System.Type,System.Byte[])">
            <summary>
            Deserializes a single value from a byte array as the specified type.
            </summary>
            <param name="type">The result type.</param>
            <param name="content">The input bytes.</param>
            <returns>The deserialized value returned as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.IDataConverter.FromDataArray(System.Byte[],System.Type[])">
            <summary>
            Deserializes an array of values from a byte array.
            </summary>
            <param name="content">The input bytes.</param>
            <param name="valueTypes">Specifies the expected number of array elements and their types.</param>
            <returns>The deserialized values.</returns>
        </member>
        <member name="M:Neon.Temporal.IDataConverter.ToData(System.Object)">
            <summary>
            Serializes a value into a byte array
            </summary>
            <param name="value">The value being serialized.</param>
            <returns>The serialized bytes.</returns>
        </member>
        <member name="M:Neon.Temporal.IDataConverter.ToDataArray(System.Object[])">
            <summary>
            Serializes an array of values into a byte array.  This is typically
            used to serialize arguments passed to workflow and acrivity methods.
            </summary>
            <param name="values">The values being serialized (or <c>null</c>).</param>
            <returns>The serialized bytes.</returns>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityInfo">
            <summary>
            Holds information about an executing activity.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.TaskToken">
            <summary>
            The opaque base-64 encoded activity task token.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.WorkflowType">
            <summary>
            The parent workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.WorkflowNamespace">
            <summary>
            The parent workflow namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.WorkflowExecution">
            <summary>
            The parent workflow execution details.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.ActivityId">
            <summary>
            The activity ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.ActivityType">
            <summary>
            The activity type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.TaskQueue">
            <summary>
            The activity task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.HeartbeatTimeout">
            <summary>
            The maximum time between heartbeats.  <see cref="F:System.TimeSpan.Zero"/> 
            indicates that no heartbeating is required.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.ScheduledTime">
            <summary>
            Time when the activity was scheduled.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.StartedTime">
            <summary>
            Time when the activity was started.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.Deadline">
            <summary>
            Time when the activity will timeout.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInfo.Attempt">
            <summary>
            Indicates how many times the activity was been restarted.  This will be zero
            for the first execution, 1 for the second, and so on.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityCompleteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityCompleteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityCompleteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityCompleteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityCompleteReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityCompleteRequest">
            <summary>
            <b>client --> proxy:</b> Sent to complete an activity externally.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityCompleteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.TaskToken">
            <summary>
            The opaque activity task token.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.Namespace">
            <summary>
            The target namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.WorkflowId">
            <summary>
            The target workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.RunId">
            <summary>
            The target run ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.ActivityId">
            <summary>
            The target activity ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.Result">
            <summary>
            The activity result.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityCompleteRequest.Error">
            <summary>
            The activity error.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityCompleteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityCompleteRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityExecuteLocalReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityExecuteLocalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteLocalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteLocalReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteLocalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteLocalReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityExecuteLocalRequest">
            <summary>
            <b>client --> proxy:</b> Starts a local workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteLocalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteLocalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteLocalRequest.ActivityId">
            <summary>
            Used to identify the activity.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteLocalRequest.ActivityTypeId">
            <summary>
            Identifies the .NET type that implements the local activity. 
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteLocalRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteLocalRequest.Options">
            <summary>
            The local activity start options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteLocalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteLocalRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityExecuteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityExecuteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityExecuteRequest">
            <summary>
            <b>client --> proxy:</b> Starts a (non-local) workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteRequest.Activity">
            <summary>
            Specifies the activity to execute
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityExecuteRequest.Options">
            <summary>
            The activity start options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityExecuteRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsReply.Details">
            <summary>
            Returns the activity heartbeat details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for the last heartbeat 
            recorded for a failed previous run of the activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetHeartbeatDetailsRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetInfoReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityGetInfoRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetInfoReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetInfoReply.Info">
            <summary>
            Returns the activity information.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetInfoReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetInfoReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetInfoRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for the last heartbeat 
            recorded for a failed previous run of the activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetInfoRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetInfoRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetInfoRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetInfoRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetLocalResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityGetLocalResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetLocalResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetLocalResultReply.Result">
            <summary>
            Returns the activity result encoded as bytes.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetLocalResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetLocalResultReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetLocalResultRequest">
            <summary>
            <b>client --> proxy:</b> Requests the results from a <see cref="T:Neon.Temporal.Internal.ActivityStartLocalRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetLocalResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetLocalResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetLocalResultRequest.ActivityId">
            <summary>
            Identifies the target activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetLocalResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetLocalResultRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityGetResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetResultReply.Result">
            <summary>
            Returns the activity result encoded as bytes.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetResultReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityGetResultRequest">
            <summary>
            <b>client --> proxy:</b> Requests the results from a <see cref="T:Neon.Temporal.Internal.ActivityStartRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityGetResultRequest.ActivityId">
            <summary>
            Identifies the target activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityGetResultRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsReply.HasDetails">
            <summary>
            Indicates whether heartbeat details are available.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Determines whether a previous failed run on an
            activity recorded heartbeat details.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityHasHeartbeatDetailsRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityInvokeLocalReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityInvokeLocalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeLocalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeLocalReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeLocalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeLocalReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityInvokeLocalRequest">
            <summary>
            <b>proxy --> client:</b> Sent to a worker, instructing it to begin executing
            a local workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeLocalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeLocalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeLocalRequest.ActivityContextId">
            <summary>
            Identifies the activity context.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeLocalRequest.ActivityTypeId">
            <summary>
            Identifies the .NET type that implements the local activity. 
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeLocalRequest.Args">
            <summary>
            Optionally specifies the activity arguments encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeLocalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeLocalRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityInvokeReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeReply.Result">
            <summary>
            Returns the activity results encoded as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeReply.Pending">
            <summary>
            Indicates that the activity will be completed externally.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Sent to a worker, instructing it to begin executing
            a workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeRequest.Activity">
            <summary>
            Identifies the registered activity type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityInvokeRequest.Args">
            <summary>
            Optionally specifies the activity arguments encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityInvokeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityRecordHeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRecordHeartbeatReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatReply.Details">
            <summary>
            Returns the activity heartbeat details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRecordHeartbeatReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRecordHeartbeatReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Records an activity heartbeat.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.TaskToken">
            <summary>
            <para>
            Overrides the <see cref="P:Neon.Temporal.Internal.ActivityRequest.ContextId"/> message property when
            non-null, indicating that the activity heartbeat is being sent externally.
            </para>
            <note>
            Only one of <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.TaskToken"/> or <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Namespace"/> may be non-null
            within a given message.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Namespace">
            <summary>
            <para>
            Overrides the <see cref="P:Neon.Temporal.Internal.ActivityRequest.ContextId"/> message property when
            non-null, indicating that the activity heartbeat is being sent externally.
            </para>
            </summary>
            <note>
            Only one of <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.TaskToken"/> or <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Namespace"/> may be non-null
            within a given message.  The <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.WorkflowId"/> and <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.RunId"/>
            will be valid only when <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Namespace"/> is non-null.
            </note>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.WorkflowId">
            <summary>
            <para>
            The target workflow ID.
            </para>
            <note>
            This is required when <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Namespace"/> is non-null.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.RunId">
            <summary>
            <para>
            The target run ID.
            </para>
            <note>
            This is optional when <see cref="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Namespace"/> is non-null.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.ActivityId">
            <summary>
            The target activity ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Details">
            <summary>
            The activity heartbeat details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRecordHeartbeatRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityRegisterReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowRegisterRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRegisterReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRegisterReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRegisterReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers a workflow handler by name.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRegisterRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRegisterRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRegisterRequest.Name">
            <summary>
            Identifies the activity implementation (AKA the activity type name).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRegisterRequest.DisableAlreadyRegisteredCheck">
            <summary>
            Disables checks for duplicate registrations.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRegisterRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRegisterRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityReply">
            <summary>
            Base class for all activity replies.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityReply.ActivityContextId">
            <summary>
            Uniquely identifies the activity context associated with this reply.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityRequest">
            <summary>
            Base class for all activity requests.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityRequest.ContextId">
            <summary>
            Uniquely identifies the activity context associated with this request.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityStartLocalReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityStartLocalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartLocalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartLocalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartLocalReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityStartLocalRequest">
            <summary>
            <b>client --> proxy:</b> Starts a local activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartLocalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartLocalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartLocalRequest.ActivityId">
            <summary>
            Used to identify the activity.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartLocalRequest.ActivityTypeId">
            <summary>
            Identifies the .NET type that implements the local activity. 
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartLocalRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartLocalRequest.Options">
            <summary>
            The local activity options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartLocalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartLocalRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityStartReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityStartRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityStartRequest">
            <summary>
            <b>client --> proxy:</b> Starts an activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartRequest.Activity">
            <summary>
            Specifies the activity to execute.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartRequest.Args">
            <summary>
            Optionally specifies the arguments to be passed to the activity encoded
            as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartRequest.Options">
            <summary>
            The activity options.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStartRequest.ActivityId">
            <summary>
            Used to identify the activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStartRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityStoppingReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Temporal.Internal.ActivityStoppingRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStoppingReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStoppingReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStoppingReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityStoppingRequest">
            <summary>
            <b>proxy --> client:</b> Indicates that a worker is being stopped.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStoppingRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStoppingRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityStoppingRequest.ActivityId">
            <summary>
            Specifies the activity being stopped.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStoppingRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ActivityStoppingRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ActivityType">
            <summary>
            ActivityType identifies a Temporal activity type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ActivityType.Name">
            <summary>
            The <see cref="T:System.String"/> Name of the activity type.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.ProxyMessage">
            <summary>
            The base class for all messages transferred between the .NET Temporal client
            and the <b>temporal-proxy</b>.
            </summary>
            <remarks>
            <para>
            This class is designed to be a very simple and flexible way of communicating
            operations and status between the Temporal client and proxy.  The specific 
            message type is identified via the <see cref="P:Neon.Temporal.Internal.ProxyMessage.Type"/> property (one of the 
            <see cref="T:Neon.Temporal.Internal.InternalMessageTypes"/> values.  The <see cref="P:Neon.Temporal.Internal.ProxyMessage.Properties"/> dictionary will be
            used to pass named values.  Binary attachments may be passed using the 
            <see cref="P:Neon.Temporal.Internal.ProxyMessage.Attachments"/> property, a list of binary arrays.
            </para>
            <para>
            This is serialized to bytes using a simple structure consisting of 32-bit
            integers, UTF-8 encoded strings, and raw bytes with all integers encoded 
            using little-endian byte ordering.  Strings are encoded as a 32-bit 
            byte length, followed by that many UTF-8 encoded string bytes.  A ZERO
            byte length indicates an empty string and a length of -1 indicates a
            NULL string.  Encoded strings will look like:
            </para>
            <code>
            +------------------+
            |      LENGTH      |   32-bit (little endian)
            +------------------+
            |                  |
            |      UTF-8       |
            |      BYTES       |
            |                  |
            +------------------+
            </code>
            <para>
            A full encoded message will look like:
            </para>
            <code>
            +------------------+
            |   MESSAGE-TYPE   |   32-bit
            +------------------+
            |   PROPERTY-COUNT |   32-bit
            +------------------+
            |                  |
            |  +------------+  |
            |  |   NAME     |  |
            |  +------------+  |
            |  |   VALUE    |  |
            |  +------------+  |
            |       ...        |
            |                  |
            +------------------+
            |   ATTACH-COUNT   |   32-bit
            +------------------+
            |                  |
            |  +------------+  |
            |  |   LENGTH   |  |   32-bit
            |  +------------+  |
            |  |            |  |
            |  |            |  |
            |  |   BYTES    |  |
            |  |            |  |
            |  |            |  |
            |  +------------+  |
            |       ...        |
            |                  |
            +------------------+
            </code>
            <para>
            The message starts out with the 32-bit message type followed by the
            number of properties to follow.  Each argument consists of an encoded
            string for the argument name followed by an encoded string for the value.
            </para>
            <para>
            After the properties will be a 32-bit integer specifying the
            number of binary attachment with each encoded as its length in bytes
            followed by that actual attachment bytes.  An attachment with length
            set to -1 will be considered to be NULL.
            </para>
            <para>
            Proxy messages will be passed between the Temporal client and proxy
            via <b>PUT</b> requests using the <b>application/x-neon-temporal-proxy</b>
            content-type.  Note that request responses in both directions never
            include any content.
            </para>
            <para>
            Note that more complex message property may be passed as JSON strings
            that can be serialized and deserialized via the <see cref="M:Neon.Temporal.Internal.ProxyMessage.GetJsonProperty``1(Neon.Temporal.Internal.PropertyNameUtf8)"/>
            and <see cref="M:Neon.Temporal.Internal.ProxyMessage.SetJsonProperty``1(Neon.Temporal.Internal.PropertyNameUtf8,``0)"/> helper methods.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.Internal.ProxyMessage.PropertyNameBytes">
            <summary>
            The return value of <see cref="M:Neon.Temporal.Internal.ProxyMessage.ReadPropertyNameBytes(System.IO.BinaryReader)"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.ProxyMessage.ContentType">
            <summary>
            The content type to used for HTTP requests encapsulating a <see cref="T:Neon.Temporal.Internal.ProxyMessage"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.Deserialize``1(System.IO.Stream,System.Boolean)">
            <summary>
            Deserializes the message from a stream.
            </summary>
            <typeparam name="TMessage">The expected message type.</typeparam>
            <param name="input">The input stream.</param>
            <param name="ignoreTypeCode">Optionally ignore unspecified message types (used for unit testing).</param>
            <returns>The decoded message.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.ReadString(System.IO.BinaryReader)">
            <summary>
            Deserialzes a string.
            </summary>
            <param name="reader">The input reader.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.ReadPropertyNameBytes(System.IO.BinaryReader)">
            <summary>
            Deserialzes a string as UTF-8 bytes allocated from a local pool.
            The value returned should be added back to the pool when you're
            donw with it.
            </summary>
            <param name="reader">The input reader.</param>
            <returns>The UTF-8 encoded string bytes.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.WriteString(System.IO.BinaryWriter,System.String)">
            <summary>
            Serialize a string.
            </summary>
            <param name="writer">The output writer.</param>
            <param name="value">The string being serialized.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.WriteString(System.IO.BinaryWriter,Neon.Temporal.Internal.PropertyNameUtf8)">
            <summary>
            Serialize a string from a <see cref="T:Neon.Temporal.Internal.PropertyNameUtf8"/>.
            </summary>
            <param name="writer">The output writer.</param>
            <param name="value">The string being serialized.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyMessage.Type">
            <summary>
            Indicates the message type, one of the <see cref="T:Neon.Temporal.Internal.InternalMessageTypes"/> values.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyMessage.Properties">
            <summary>
            Returns a case insensitive dictionary that maps argument names to value strings.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyMessage.Attachments">
            <summary>
            Returns the list of binary attachments.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SerializeAsStream(System.Boolean)">
            <summary>
            Serializes the message to a pooled <see cref="T:System.IO.MemoryStream"/>.  Be sure to
            add the stream returned back to the <see cref="T:Neon.Temporal.Internal.MemoryStreamPool"/> when you've 
            finished with it.
            </summary>
            <param name="ignoreTypeCode">Optionally ignore unspecified message types (used for unit testing).</param>
            <returns>A <see cref="T:System.IO.MemoryStream"/> holding the serialized message.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SerializeAsBytes(System.Boolean)">
            <summary>
            <para>
            Serializes the message to bytes.
            </para>
            <note>
            This method is intended for testing purposes.  Use <see cref="M:Neon.Temporal.Internal.ProxyMessage.SerializeAsStream(System.Boolean)"/>
            for production since that method will perform better by not needing to allocate a
            byte array with the message contents for every call.
            </note>
            </summary>
            <param name="ignoreTypeCode">Optionally ignore unspecified message types (used for unit testing).</param>
            <returns>The serialized byte array.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.Clone">
            <summary>
            Implemented by derived classes to make a copy of themselves for echo testing
            purposes.  Note that this is not implemented for the base <see cref="T:Neon.Temporal.Internal.ProxyMessage"/>
            class.
            </summary>
            <returns>The cloned message.</returns>
            <exception cref="T:System.NotImplementedException">Thrown by this base class.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <summary>
            Implemented by derived classes to copy message properties to another
            message instance during a <see cref="M:Neon.Temporal.Internal.ProxyMessage.Clone"/> operation.
            </summary>
            <param name="target">The target message.</param>
            <remarks>
            <note>
            The method implementation can safely assume that the <paramref name="target"/>
            message can be cast into the implementation's message type.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetStringProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.String)">
            <summary>
            Helper method for retrieving a string property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The string value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetIntProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Int32)">
            <summary>
            Helper method for retrieving a 32-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The integer value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetLongProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Int64)">
            <summary>
            Helper method for retrieving a 64-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The long value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetBoolProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Boolean)">
            <summary>
            Helper method for retrieving a boolean property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The long value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetEnumProperty``1(Neon.Temporal.Internal.PropertyNameUtf8,``0)">
            <summary>
            Helper method for retrieving an enumeration property.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The long value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetDoubleProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Double)">
            <summary>
            Helper method for retrieving a double property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The double value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetDateTimeProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.DateTime)">
            <summary>
            Helper method for retrieving a date/time property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The double value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetTimeSpanProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.TimeSpan)">
            <summary>
            Helper method for retrieving a timespan property.
            </summary>
            <param name="key">The property key.</param>
            <param name="def">The default value to be returned if the named property doesn't exist.</param>
            <returns>The double value.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetJsonProperty``1(Neon.Temporal.Internal.PropertyNameUtf8)">
            <summary>
            Helper method for retrieving a complex property serialized as a JSON string.
            </summary>
            <typeparam name="T">The property type.</typeparam>
            <param name="key">The property key.</param>
            <returns>The parsed value if the property exists or <c>null</c>.</returns>
            <remarks>
            <note>
            <para>
            <b>IMPORTANT:</b> Be very careful when referencing properties that use this
            method because the behavior will probably be unexepected.  You should:
            </para>
            <list type="bullet">
                <item>
                When you need to access multiple subfields of the property value,
                dereference the property once, save the value to a variable and
                then use the variable to access the subproperty.  Not doing this
                will result in the JSON being parsed again for each property
                reference.
                </item>
                <item>
                Dereferencing the property and changing a subproperty value won't
                actually persist the change back to the underlying property.  You'll
                need to dereference the property to a variable, change the subproperty,
                and then use <see cref="M:Neon.Temporal.Internal.ProxyMessage.SetJsonProperty``1(Neon.Temporal.Internal.PropertyNameUtf8,``0)"/> to persist the
                change. 
                </item>
            </list>
            <para>
            These restrictions are a bit odd but we're not actually expecting to 
            be doing any of these things within the <b>temporal-client</b> code.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.GetBytesProperty(Neon.Temporal.Internal.PropertyNameUtf8)">
            <summary>
            Helper method for retrieving a byte array property.
            </summary>
            <param name="key">The property key.</param>]
            <returns>The byte array or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetStringProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.String)">
            <summary>
            Helper method for setting a string property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetIntProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Int32)">
            <summary>
            Helper method for setting a 32-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetLongProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Int64)">
            <summary>
            Helper method for setting a 64-bit integer property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetBoolProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Boolean)">
            <summary>
            Helper method for setting a boolean property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetEnumProperty``1(Neon.Temporal.Internal.PropertyNameUtf8,``0)">
            <summary>
            Helper method for setting an enumeration property.
            </summary>
            <typeparam name="TEnum">The enumeration type.</typeparam>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetDoubleProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Double)">
            <summary>
            Helper method for setting a double property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetDateTimeProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.DateTime)">
            <summary>
            Helper method for setting a date/time property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetTimeSpanProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.TimeSpan)">
            <summary>
            Helper method for setting a timespan property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetJsonProperty``1(Neon.Temporal.Internal.PropertyNameUtf8,``0)">
            <summary>
            Helper method for setting a complex property as JSON.
            </summary>
            <typeparam name="T">The property type.</typeparam>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyMessage.SetBytesProperty(Neon.Temporal.Internal.PropertyNameUtf8,System.Byte[])">
            <summary>
            Helper method for setting a byte array property.
            </summary>
            <param name="key">The property key.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyMessage.ClientId">
            <summary>
            Identifies the Temporal service client the request references.  This will
            be zero for the few messages that don't reference a client.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyMessage.WorkerId">
            <summary>
            Optionally identifies a client specific worker.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.ProxyReply">
            <summary>
            Base class for all proxy requests.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyReply.RequestId">
            <summary>
            Uniquely identifies the request this reply answers.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyReply.Error">
            <summary>
            Optionally indicates that the request failed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyReply.ThrowOnError">
            <summary>
            Throws the related exception if the reply is reporting an error.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.ProxyRequest">
            <summary>
            Base class for all proxy requests.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyRequest.RequestId">
            <summary>
            Uniquely identifies this request.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyRequest.IsCancellable">
            <summary>
            Optionally indicates that the operation may be cancelled by the 
            workflow application.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ProxyRequest.ReplyType">
            <summary>
            Derived request types must return the type of the expected
            <see cref="T:Neon.Temporal.Internal.ProxyReply"/> message.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ProxyRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ChildExecution">
            <summary>
            <b>INTERNAL USE ONLY:</b> Holds information about a child workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ChildExecution.#ctor(Neon.Temporal.WorkflowExecution,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="execution">The child workflow's execution information.</param>
            <param name="childId">
            The child workflow's local ID.  This is used to identify the 
            child when communicating with <b>temporal-proxy</b>.
            </param>
        </member>
        <member name="P:Neon.Temporal.Internal.ChildExecution.Execution">
            <summary>
            The child workflow's execution information.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ChildExecution.ChildId">
            <summary>
            The child workflow's local ID.  This is used to identify the 
            child when communicating with <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.CancelReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="T:Neon.Temporal.Internal.CancelRequest"/>
            indicating that the operation was canceled, has already completed or doesn't
            exist.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.CancelReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.CancelReply.WasCancelled">
            <summary>
            Set to <c>true</c> if the operation was actually cancelled or <c>false</c>
            if the operation had already completed, doesn't exist, or if cancellation
            is not appropriate for the operation and no action was performed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.CancelReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.CancelReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.CancelRequest">
            <summary>
            <b>client --> proxy:</b> Sent periodically to confirm that the proxy is
            still healthy.  The proxy should send a <see cref="T:Neon.Temporal.Internal.CancelReply"/>
            optionally indicating that there's a problem by specifying an error.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.CancelRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.CancelRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.CancelRequest.TargetRequestId">
            <summary>
            The ID of the request being cancelled.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.CancelRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.CancelRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ConnectReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.ConnectRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ConnectReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ConnectReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ConnectReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ConnectRequest">
            <summary>
            <b>client --> proxy:</b> Requests the proxy establish a connection with a Temporal cluster.
            This maps to a <c>NewClient()</c> in the proxy.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ConnectRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.HostPort">
            <summary>
            Specifies the Temporal server host and port being connected.  This is typically formatted
            as <b>host:port</b> where <b>host</b> is the IP address or hostname for the
            Temporal server.  Alternatively, this can be formatted as <b>dns:///host:port</b>
            to enable DNS round-robin lookups.  This defaults to <b>localhost:7233</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.Identity">
            <summary>
            Optionally identifies the client application.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.ClientTimeout">
            <summary>
            The default client timeout.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.Namespace">
            <summary>
            The default Temporal namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.CreateNamespace">
            <summary>
            Indicates whether the Temporal <see cref="P:Neon.Temporal.Internal.ConnectRequest.Namespace"/> should be created 
            when it doesn't already exist.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.Retries">
            <summary>
            Specifies the number of time the client will attempt to connect
            to the Temporal cluster.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ConnectRequest.RetryDelay">
            <summary>
            Specifies the time to delay before retrying to connect to the cluster.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ConnectRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.ConnectRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.DescribeTaskQueueReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.DescribeTaskQueueRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DescribeTaskQueueReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.DescribeTaskQueueReply.Result">
            <summary>
            The task queue details.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DescribeTaskQueueReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.DescribeTaskQueueReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.DescribeTaskQueueRequest">
            <summary>
            <b>client --> proxy:</b> Requests a list of the Temporal namespaces.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DescribeTaskQueueRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.DescribeTaskQueueRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.DescribeTaskQueueRequest.Name">
            <summary>
            Identifies the task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.DescribeTaskQueueRequest.Namespace">
            <summary>
            Identifies the target namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.DescribeTaskQueueRequest.TaskQueueType">
            <summary>
            Identifies the type of task queue being requested: decision (AKA workflow or activity).
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DescribeTaskQueueRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.DescribeTaskQueueRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.DisconnectReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.DisconnectRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DisconnectReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DisconnectReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.DisconnectReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.DisconnectRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy disconnect from a Temporal cluster.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DisconnectRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.DisconnectRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.DisconnectRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.DisconnectRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.HeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.HeartbeatRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.HeartbeatReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.HeartbeatReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.HeartbeatReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.HeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Sent periodically to confirm that the proxy is
            still healthy.  The proxy should send a <see cref="T:Neon.Temporal.Internal.HeartbeatReply"/>,
            possibly indicating that there's a problem by specifying an error.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.HeartbeatRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.HeartbeatRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.HeartbeatRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.HeartbeatRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.InitializeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.InitializeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InitializeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InitializeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.InitializeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.InitializeRequest">
            <summary>
            <b>client --> proxy:</b> Informs the proxy of the network endpoint
            where the client is listening for proxy messages.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InitializeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InitializeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.InitializeRequest.LibraryAddress">
            <summary>
            The IP address where the Temporal client is listening for proxy messages
            send by the <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InitializeRequest.LibraryPort">
            <summary>
            The port where the Temporal client is listening for messages
            sent by the <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InitializeRequest.LogLevel">
            <summary>
            Specifies the log level <b>temporal-proxy</b> should use when deciding
            which log events to forward to the <b>temporal-client</b>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InitializeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.InitializeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.LogReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="T:Neon.Temporal.Internal.CancelRequest"/>
            indicating that the operation was canceled, has already completed or doesn't
            exist.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.LogReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.LogReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.LogReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.LogRequest">
            <summary>
            <b>proxy --> client:</b> Sent by <b>temporal-proxy</b> to log Temporal and temporal-proxy
            events to the host's event stream.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.LogRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.LogRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.LogRequest.TimeUtc">
            <summary>
            Identifies when the event being logged occurred (UTC).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.LogRequest.LogLevel">
            <summary>
            Identifies the log level.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.LogRequest.FromTemporal">
            <summary>
            Specifies the source of the event veing logged.  Set this to <c>true</c>
            for events coming from the GOLANG Temporal client or <c>false</c> for
            events coming from the <b>temporal-proxy</b> wrapper.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.LogRequest.LogMessage">
            <summary>
            The message being logged.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.LogRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.LogRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceDeprecateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.NamespaceDeprecateRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDeprecateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDeprecateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDeprecateReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceDeprecateRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy register a Temporal namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDeprecateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDeprecateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDeprecateRequest.Name">
            <summary>
            Name of the namespace to be depreciated.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDeprecateRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDeprecateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDeprecateRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceDescribeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.NamespaceDescribeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDescribeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeReply.NamespaceInfo">
            <summary>
            The namespace info.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeReply.NamespaceConfig">
            <summary>
            The namespace configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeReply.NamespaceReplicationConfig">
            <summary>
            The namespace replication configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeReply.FailoverVersion">
            <summary>
            The failover version for the namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeReply.IsGlobalNamespace">
            <summary>
            Indicates whether the namespace is a global namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDescribeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDescribeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceDescribeRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for a named namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDescribeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescribeRequest.Name">
            <summary>
            <para>
            The target Temporal namespace name. (or <c>null</c>).
            </para>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDescribeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceDescribeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceListReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.NamespaceListRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceListReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceListReply.Namespaces">
            <summary>
            Lists information about the Temporal namespaces.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceListReply.NextPageToken">
            <summary>
            Returns an opaque token that can be used in a subsequent <see cref="T:Neon.Temporal.Internal.NamespaceListRequest"/>
            to obtain the next page of results.  This will be <c>null</c> when there are no
            remaining results.  This should be considered to be an opaque value.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceListReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceListReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceListRequest">
            <summary>
            <b>client --> proxy:</b> Requests a list of the Temporal namespaces.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceListRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceListRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceListRequest.PageSize">
            <summary>
            Specifies the maximum number of items to be returned in the reponse.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceListRequest.NextPageToken">
            <summary>
            Optionally specifies the next page of results.  This will be <c>null</c>
            for the first page of results and can be set to the the value returned
            as <see cref="P:Neon.Temporal.Internal.NamespaceListReply.NextPageToken"/> to retrieve the next page
            of results.  This should be considered to be an opaque value.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceListRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceListRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceRegisterReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.NamespaceRegisterRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceRegisterReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceRegisterReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceRegisterReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy register a Temporal namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceRegisterRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceRegisterRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceRegisterRequest.Name">
            <summary>
            Name for the new namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceRegisterRequest.Description">
            <summary>
            Human readable description for the namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceRegisterRequest.OwnerEmail">
            <summary>
            Owner email address.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceRegisterRequest.WorkflowExecutionRetentionPeriod">
            <summary>
            The complete workflow history retention period in days.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceRegisterRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceRegisterRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceRegisterRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceUpdateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.NamespaceDescribeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceUpdateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceUpdateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceUpdateReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceUpdateRequest">
            <summary>
            <b>client --> proxy:</b> Requests the details for a named namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceUpdateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.Name">
            <summary>
            Name of the namespace to update.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.UpdateNamespaceInfo">
            <summary>
            Specifies the updated namespace info.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.NamespaceConfig">
            <summary>
            Specifies the updated namespace config.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.NamespaceReplicationConfig">
            <summary>
            Specifies the updated namespace replication config.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.DeleteBadBinary">
            <summary>
            Optional delete bad binary.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceUpdateRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceUpdateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NamespaceUpdateRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NewWorkerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.NewWorkerRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NewWorkerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NewWorkerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NewWorkerReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.NewWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Creates a new worker but doesn't start it.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NewWorkerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NewWorkerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.NewWorkerRequest.Namespace">
            <summary>
            Optionally specifies the Temporal namespace for the worker.  This defaults to
            <see cref="P:Neon.Temporal.TemporalSettings.Namespace"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NewWorkerRequest.TaskQueue">
            <summary>
            <para>
            Optionally specifies the Temporal task queue for the worker.  This defaults to
            <see cref="P:Neon.Temporal.TemporalSettings.TaskQueue"/>.
            </para>
            <note>
            You must ensure that this is not <c>null</c> or empty.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NewWorkerRequest.Options">
            <summary>
            The worker options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.NewWorkerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.NewWorkerRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.PingReply">
            <summary>
            Sent in response to a <see cref="T:Neon.Temporal.Internal.PingRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PingReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PingReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.PingReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.PingRequest">
            <summary>
            Sent by either the client or proxy for measuring transaction throughput.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PingRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PingRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.PingRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.PingRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.StartWorkerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.StartWorkerRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StartWorkerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StartWorkerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.StartWorkerReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.StartWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Starts a worker.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StartWorkerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StartWorkerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.StartWorkerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.StartWorkerRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.StopWorkerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.StopWorkerRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StopWorkerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StopWorkerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.StopWorkerReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.StopWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Stops a Temporal worker.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StopWorkerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StopWorkerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.StopWorkerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.StopWorkerRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.TerminateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.TerminateRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TerminateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TerminateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.TerminateReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.TerminateRequest">
            <summary>
            <b>client --> proxy:</b> Signals the proxy that it should terminate gracefully.  The
            proxy should send a <see cref="T:Neon.Temporal.Internal.TerminateReply"/> back to the client and
            then exit, terminating the process.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TerminateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TerminateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.TerminateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.TerminateRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.DynamicActivityStub">
            <summary>
            Manages a dynamically generated type safe activity stub class for an activity interface.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicActivityStub.#ctor(System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="activityInterface">Specifies the activity interface.</param>
            <param name="assembly">The assembly holding the generated stub class.</param>
            <param name="className">The fully qualified stub class name.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicActivityStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,System.String,Neon.Temporal.ActivityOptions,System.Type)">
            <summary>
            Creates a normal (non-local) activity stub instance suitable for executing a non-local activity.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="workflow">The parent workflow.</param>x
            <param name="activityTypeName">Specifies the activity type name.</param>
            <param name="options">Specifies the <see cref="T:Neon.Temporal.ActivityOptions"/> or <c>null</c>.</param>
            <param name="activityInterface">Specifies the activity interface definition.</param>
            <returns>The activity stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicActivityStub.CreateLocal(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,System.Type,Neon.Temporal.LocalActivityOptions)">
            <summary>
            Creates a local activity stub instance suitable for executing a non-local activity.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="workflow">The parent workflow.</param>
            <param name="activityType">The activity implementation type.</param>
            <param name="options">Specifies the <see cref="T:Neon.Temporal.LocalActivityOptions"/> or <c>null</c>.</param>
            <returns>The activity stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.Internal.DynamicWorkflowStub">
            <summary>
            Manages a dynamically generated type safe workflow stub class for a workflow interface.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.#ctor(System.Type,System.Reflection.Assembly,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="workflowInterface">Specifies the workflow interface.</param>
            <param name="assembly">The assembly holding the generated stub class.</param>
            <param name="className">The fully qualified stub class name.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,System.String,Neon.Temporal.StartWorkflowOptions,System.Type)">
            <summary>
            Creates a workflow stub instance suitable for starting a new external workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Specifies the <see cref="T:Neon.Temporal.StartWorkflowOptions"/> or <c>null</c>.</param>
            <param name="workflowInterface">Specifies the workflow interface definition.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,System.String,System.String,System.String)">
            <summary>
            Creates a workflow stub instance suitable for connecting to an existing external workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="workflowId">Specifies the workflow ID.</param>
            <param name="runId">Optionally specifies the workflow run ID.</param>
            <param name="namespace">Optionally specifies the namespace.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,Neon.Temporal.Workflow,System.String,Neon.Temporal.ChildWorkflowOptions,System.Type)">
            <summary>
            Creates a workflow stub instance suitable for starting a new child workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Specifies the child workflow options or <c>null</c>.</param>
            <param name="workflowInterface">Specifies the workflow interface definition.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,Neon.Temporal.Workflow,System.String,Neon.Temporal.Internal.ChildExecution)">
            <summary>
            Creates a workflow stub instance mapping to an already started child workflow.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="childExecution">The child execution information.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,Neon.Temporal.Workflow,Neon.Temporal.WorkflowExecution)">
            <summary>
            Creates a stub for an existing child workflow specified by a <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="execution">The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,Neon.Temporal.Workflow,System.String,System.String)">
            <summary>
            Creates a stub for an existing child workflow specified by its workflow ID and optional namespace.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowId">The workflow ID.</param>
            <param name="namespace">Optionally overrides the default client namespace.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.Create(Neon.Temporal.TemporalClient,Neon.Temporal.IDataConverter,System.String,Neon.Temporal.ContinueAsNewOptions)">
            <summary>
            Creates a workflow stub instance suitable for continuing a workflow as new.
            </summary>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="dataConverter">The data converter.</param>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Optionally specifies the continuation options.</param>
            <returns>The workflow stub as an <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.DynamicWorkflowStub.ToUntypedAsync">
            <summary>
            <para>
            Creates a new untyped <see cref="T:Neon.Temporal.WorkflowStub"/> from the dynamic stub.
            </para>
            <note>
            The workflow must have already been started via the stub.
            </note>
            </summary>
            <returns>The new <see cref="T:Neon.Temporal.WorkflowStub"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the stub passed is not external (e.g. it's a child stub).</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the stubbed workflow has not been started yet.</exception>
        </member>
        <member name="T:Neon.Temporal.Internal.Failure">
            <summary>
            Defines a workflow execution failure.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Failure.Message">
            <summary>
            The failure message.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Failure.Source">
            <summary>
            The source of failure.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Failure.StackTrace">
            <summary>
            The failure stack trace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Failure.Cause">
            <summary>
            The cause of failure.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.InternalMessageTypes">
            <summary>
            <b>INTERNAL USE ONLY:</b> Enumerates the possible message types.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.Unspecified">
            <summary>
            Indicates a message with an unspecified type.  This normally indicates an error.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.InitializeRequest">
            <summary>
            <b>client --> proxy:</b> Informs the proxy of the network endpoint where the
            client is listening for proxy messages.  The proxy should respond with an
            <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.InitializeReply"/> when it's ready to begin receiving inbound
            proxy messages.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.InitializeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.InitializeRequest"/> message
            to indicate that the proxy ready to begin receiving inbound proxy messages.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ConnectRequest">
            <summary>
            client --> proxy: Requests that the proxy establish a connection to a Temporal
            cluster.  This maps to a <c>NewClient()</c> in the proxy.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ConnectReply">
            <summary>
            proxy --> client: Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ConnectRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.TerminateRequest">
            <summary>
            <b>client --> proxy:</b> Signals the proxy that it should terminate gracefully.  The
            proxy should send a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.TerminateReply"/> back to the client and
            then exit, terminating the process.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.TerminateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.TerminateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy register a Temporal namespace.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceRegisterReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceRegisterRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceDescribeRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy return the details for a Temporal namespace.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceDescribeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceDescribeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceUpdateRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy update a Temporal namespace.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceUpdateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceUpdateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.HeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Sent periodically (every second) by the client to the
            proxy to verify that it is still healthy.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.HeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.HeartbeatRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.CancelRequest">
            <summary>
            <b>client --> proxy:</b> Sent to request that a pending operation be cancelled.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.CancelReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.CancelRequest"/> message,
            indicating that the operation was canceled or that it already completed or no longer
            exists.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NewWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Creates a new worker but doesn't start it.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NewWorkerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.NewWorkerRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.StopWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Stops a Temporal worker.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.StopWorkerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.StopWorkerRequest"/> message,
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.PingRequest">
            <summary>
            Sent from either the client or proxy mainly for measuring the raw throughput of 
            client/proxy transactions.  The receiver simply responds immediately with a
            <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.PingReply"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.PingReply">
            <summary>
            Sent by either side in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.PingRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceDeprecateRequest">
            <summary>
            <b>client --> proxy:</b> Requests that the proxy deprecate a Temporal namespace.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceDeprecateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceDeprecateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.DisconnectRequest">
            <summary>
             <b>client --> proxy:</b> Sent to have the proxy disconnect from a Temporal cluster.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.DisconnectReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.DisconnectRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.LogRequest">
            <summary>
            <b>proxy --> client:</b> Sent by <b>temporal-proxy</b> to log Temporal and temporal-proxy
            events to the host's event stream.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.LogReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.LogRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceListRequest">
            <summary>
            <b>client --> proxy:</b> Sent to list the Temporal namespaces.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceListReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.NamespaceListRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.DescribeTaskQueueRequest">
            <summary>
            <b>client --> proxy:</b> Sent to obtain details for a task queue.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.DescribeTaskQueueReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.DescribeTaskQueueRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.StartWorkerRequest">
            <summary>
            <b>client --> proxy:</b> Starts a worker so that it can begin executing workflows and activities.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.StartWorkerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.StartWorkerRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers a workflow handler.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowRegisterReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowRegisterRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteRequest">
            <summary>
            <b>client --> proxy:</b> Starts a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalRequest">
            <summary>
            <b>client --> proxy:</b> Signals a running workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalWithStartRequest">
             <summary>
            <b>client --> proxy:</b> Signals a workflow, starting it first if necessary.
             </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalWithStartReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalWithStartRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowCancelRequest">
            <summary>
            <b>client --> proxy:</b> Cancels a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowCancelReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowCancelRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowTerminateRequest">
            <summary>
            <b>client --> proxy:</b> Terminates a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowTerminateReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowTerminateRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetHistoryRequest">
            <summary>
            <b>client --> proxy:</b> Requests a workflow's history.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetHistoryReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetHistoryRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowListClosedRequest">
            <summary>
            <b>client --> proxy:</b> Requests the list of closed workflows.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowListClosedReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowListClosedRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowListOpenExecutionsRequest">
            <summary>
            <b>client --> proxy:</b> Requests the list of open workflows.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowListOpenExecutionsReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowListOpenExecutionsRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueryRequest">
            <summary>
            <b>client --> proxy:</b> Queries a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueryReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueryRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowDescribeExecutionRequest">
            <summary>
            <b>client --> proxy:</b> Returns information about a worflow execution.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowDescribeExecutionReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowDescribeExecutionRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.Unused0">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.Unused1">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Commands the client client and associated .NET application
            to process a workflow instance.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowInvokeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteChildRequest">
            <summary>
            <b>client --> proxy:</b> Initiates execution of a child workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteChildReply">
            <summary>
            <b>proxy --> cl;ient:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteChildRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalSubscribeRequest">
            <summary>
            <b>client --> proxy:</b> Indicates that .NET application wishes to consume signals from
            a named channel.  Any signals received by the proxy will be forwarded to the
            client via <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalInvokeRequest"/> messages.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalSubscribeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalSubscribeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Sent when a signal is received by the proxy on a subscribed channel.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalInvokeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowMutableRequest">
            <summary>
            <b>client --> proxy:</b> Implements the standard Temporal <i>side effect</i> behavior
            by including the mutable result being set.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowMutableReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowMutableRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetVersionRequest">
            <summary>
            <b>client --> proxy:</b> Manages workflow versioning.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetVersionReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetVersionRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSetCacheSizeRequest">
            <summary>
            <b>client --> proxy:</b> Sets the maximum number of bytes the client will use
            to cache the history of a sticky workflow on a workflow worker as a performance
            optimization.  When this is exceeded for a workflow, its full history will
            need to be retrieved from the Temporal cluster the next time the workflow
            instance is assigned to a worker. 
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSetCacheSizeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSetCacheSizeRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetResultRequest">
            <summary>
            <b>client --> proxy:</b> Requests the workflow result encoded as a byte array, waiting
            for the workflow to complete if it is still running.  Note that this request will fail
            if the workflow did not run to completion.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetResultRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowHasLastResultRequest">
            <summary>
             <b>client --> proxy:</b> Determines whether the last execution of the workflow has
             a completion result.  This can be used by CRON workflows to determine whether the
             last execution returned a result.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowHasLastResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowHasLastResultRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetLastResultRequest">
            <summary>
             <b>client --> proxy:</b> Returns the result from the last execution of the workflow.
             This can be used by CRON workflows to retrieve state from the last workflow execution.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetLastResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetLastResultRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowDisconnectContextRequest">
            <summary>
             <b>client --> proxy:</b> Commands the proxy to replace the current workflow context
             with a new disconnected context.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowDisconnectContextReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowDisconnectContextRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetTimeRequest">
            <summary>
            <b>client --> proxy:</b> Request the current workflow time.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetTimeReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowGetTimeRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSleepRequest">
            <summary>
            <b>client --> proxy:</b> Sent to have the workflow sleep for a period of time.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSleepReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSleepRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowWaitForChildRequest">
            <summary>
            <b>client --> proxy:</b> Waits for a workflow that has already been started
            by a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowExecuteChildRequest"/> to finish.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowWaitForChildReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowWaitForChildRequest"/> message
            after the child is finish.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalChildRequest">
            <summary>
            <b>client --> proxy:</b> Sends a signal to a child workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalChildReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSignalChildRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowCancelChildRequest">
            <summary>
            <b>client --> proxy:</b> Cancels a child workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowCancelChildReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowCancelChildRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowFutureReadyRequest">
            <summary>
            <b>client --> proxy:</b> Sent for workflow operations that are implemented in GOLANG as futures 
            and may be executed in parallel.  <b>temporal-proxy</b> will send this message after it has 
            submitted the operation to Temporal but before the future actually completes.  The .NET client 
            uses this as an indication that another Temporal operation may be started.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowFutureReadyReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowFutureReadyRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSetQueryHandlerRequest">
            <summary>
            <b>client --> proxy:</b> Registers a query handler by name.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSetQueryHandlerReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowSetQueryHandlerRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueryInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a query on a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueryInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueryInvokeRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueNewRequest">
            <summary>
            <b>proxy --> client:</b> Creates a new workflow queue.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueNewReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueNewRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueWriteRequest">
            <summary>
            <b>proxy --> client:</b> Writes data to a queue.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueWriteReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueWriteRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueReadRequest">
            <summary>
            <b>proxy --> client:</b> Reads data from a queue.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueReadReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueReadRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.Unused2">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.Unused3">
            <summary>
            <b>UNUSED</b>
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueCloseRequest">
            <summary>
            <b>proxy --> client:</b> Closes a queue.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueCloseReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.WorkflowQueueCloseRequest"/>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityExecuteRequest">
            <summary>
            <b>client --> proxy:</b> Executes an activity within the context of a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityExecuteReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityExecuteRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Invokes an activity on an activity worker. 
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityInvokeReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityInvokeRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Requests the heartbeat details from the last failed activity execution.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetHeartbeatDetailsRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityLogRequest">
            <summary>
            <b>client --> proxy:</b> Logs a message for an activity.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityLogReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityLogRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityRecordHeartbeatRequest">
            <summary>
            <b>client --> proxy:</b> Records a heartbeat message for an activity.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityRecordHeartbeatReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityRecordHeartbeatRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityHasHeartbeatDetailsRequest">
            <summary>
            <b>client --> proxy:</b> Determines whether an activity execution has any heartbeat details.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityHasHeartbeatDetailsReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityHasHeartbeatDetailsRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStoppingRequest">
            <summary>
            <b>proxy --> client:</b> Signals the client that an activity is being stopped. 
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStoppingReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStoppingRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityExecuteLocalRequest">
            <summary>
            <b>client --> proxy:</b> Executes a local activity within the context of a workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityExecuteLocalReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityExecuteLocalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityInvokeLocalRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a local activity on an activity worker. 
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityInvokeLocalReply">
            <summary>
            <b>client --> proxy:</b> Sent in response to a <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityInvokeLocalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers an activity handler.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityRegisterReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityRegisterRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetInfoRequest">
            <summary>
            <b>client --> proxy:</b> Requests information about an activity.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetInfoReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetInfoRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityCompleteRequest">
            <summary>
            <b>client --> proxy:</b> Requests that an activity be completed externally.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityCompleteReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityCompleteRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartRequest">
            <summary>
            <b>client --> proxy:</b> Starts an activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetResultRequest">
            <summary>
            <b>client --> proxy:</b> Waits for an activity started via <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartRequest"/>
            to complete and returns the result.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetResultRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartLocalRequest">
            <summary>
            <b>client --> proxy:</b> Starts a local activity but doesn't wait for it to complete.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartLocalReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartLocalRequest"/> message.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetLocalResultRequest">
            <summary>
            <b>client --> proxy:</b> Waits for an activity started via <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityStartLocalRequest"/>
            to complete and returns the result.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetLocalResultReply">
            <summary>
            <b>proxy --> client:</b> Sent in response to an <see cref="F:Neon.Temporal.Internal.InternalMessageTypes.ActivityGetLocalResultRequest"/> message.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.InternalProxyMessageAttribute">
            <summary>
            <b>INTERNAL USE ONLY:</b> Used to tag proxy message class implementations 
            and also associate the message class with the message type code.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InternalProxyMessageAttribute.#ctor(Neon.Temporal.Internal.InternalMessageTypes)">
            <summary>
            Constructor.
            </summary>
            <param name="type">Specifies the message type to be used when serializing the tagged message.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalProxyMessageAttribute.Type">
            <summary>
            Returns the associated message type code.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.InternalRegisterNamespaceRequest">
            <summary>
            Namespace registration details.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalRegisterNamespaceRequest.Name">
            <summary>
            The namespace name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalRegisterNamespaceRequest.Description">
            <summary>
            The namespace description.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalRegisterNamespaceRequest.OwnerEmail">
            <summary>
            The namespace owner's email address.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalRegisterNamespaceRequest.WorkflowExecutionRetentionPeriod">
            <summary>
            The number of days to retain the history for workflowws
            completed in this namespace.  This defaults to <b>7 days</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalRegisterNamespaceRequest.EmitMetrics">
            <summary>
            Enables metric generation.  This defaults to <c>false.</c>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalRegisterNamespaceRequest.SecurityToken">
            <summary>
            Optional security token.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.InternalReplayStatus">
            <summary>
            Indicates a workflow's current replay status.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalReplayStatus.Unspecified">
            <summary>
            Indicates that the corresponding operation cannot determine the replay
            status (e.g. because the it didn't relate to an executing workflow).
            This is the default value.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalReplayStatus.NotReplaying">
            <summary>
            The related workflow is not replaying.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.InternalReplayStatus.Replaying">
            <summary>
            The related workflow is replaying.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.InternalWorkflowExecution">
            <summary>
            Describes the state of an executed workflow.  Used
            for serialization in a set of message types.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InternalWorkflowExecution.#ctor">
            <summary>
            Defaulty constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InternalWorkflowExecution.#ctor(Neon.Temporal.WorkflowExecution)">
            <summary>
            Internal constructor.
            </summary>
            <param name="execution">The workflow's execution information.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalWorkflowExecution.WorkflowId">
            <summary>
            Returns the current ID for workflow execution.  This will be different
            than <see cref="P:Neon.Temporal.Internal.InternalWorkflowExecution.RunId"/> when the workflow has been continued as new
            or potentially restarted.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.InternalWorkflowExecution.RunId">
            <summary>
            The original ID assigned to the workflow when it was started.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.InternalWorkflowExecution.ToWorkflowExecution">
            <summary>
            Converts the instance to the equivalant <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <returns>The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.Internal.ITypedWorkflowStub">
            <summary>
            <b>INTERNAL USE ONLY:</b> Interface implemented by generated typed workflow stubs.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ITypedWorkflowStub.ToUntypedAsync">
            <summary>
            Creates an untyped <see cref="T:Neon.Temporal.WorkflowStub"/> from a typed stub.
            </summary>
            <returns>The untyped stub.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.ITypedWorkflowStub.GetExecutionAsync">
            <summary>
            Obtains the workflow execution for stubs that have been started.  This
            fails for unstarted workflows.
            </summary>
            <returns>The workflow <see cref="T:Neon.Temporal.WorkflowExecution"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the stub has not been started.</exception>
        </member>
        <member name="P:Neon.Temporal.Internal.ITypedWorkflowStub.HasExecution">
            <summary>
            Returns <c>true</c> if the stub has already ontained its workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.ITypedWorkflowStub.WaitForExecutionAsync">
            <summary>
            Waits for the workflow stub to be assigned an external or child workflow
            execution.  This is useful for ensuring that the workflow method execution
            has proceeded far enough to have actually submitted the workflow to Temporal.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.Internal.LocalActivityAction">
            <summary>
            Holds information about the activity type to be instantiated and the
            method to be called when a local activity is invoked.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.LocalActivityAction.#ctor(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo)">
            <summary>
            Constructor.
            </summary>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityType">The target activity type.</param>
            <param name="activityMethod">The target activity method.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.LocalActivityAction.ActivityType">
            <summary>
            The target activity type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.LocalActivityAction.ActivityConstructor">
            <summary>
            The target activity constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.LocalActivityAction.ActivityMethod">
            <summary>
            The target activity method.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.Memo">
            <summary>
            Describers a temporal workflow execution memo.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Memo.Fields">
            <summary>
            The key-value map of string fields to data payload.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.MemoryStreamPool">
            <summary>
            Manages a pool of <see cref="T:System.IO.MemoryStream"/> instances used for serializing
            and deserializing proxy messages.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.MemoryStreamPool.Alloc">
            <summary>
            Allocates a stream from the pool.
            </summary>
            <returns>The allocated stream.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.MemoryStreamPool.Free(System.IO.MemoryStream)">
            <summary>
            Frees the stream by adding it back to the pool.
            </summary>
            <param name="stream">The stream being freed.</param>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceDescription">
            <summary>
            Information returned by <see cref="M:Neon.Temporal.TemporalClient.DescribeNamespaceAsync(System.String)"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescription.NamespaceInfo">
            <summary>
            The namespace information.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescription.Config">
            <summary>
            The namespace configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescription.ReplicationConfig">
            <summary>
            The namespace replication configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescription.FailoverVersion">
            <summary>
            The namespace failover version.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceDescription.IsGlobalNamespace">
            <summary>
            Indicates whether the namespace is global.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceInfo">
            <summary>
            Information about a Temporal namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceInfo.Name">
            <summary>
            The namespace name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceInfo.Id">
            <summary>
            The namespace UUID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceInfo.State">
            <summary>
            The namespace status.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceInfo.Description">
            <summary>
            Ths namespace description.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceInfo.OwnerEmail">
            <summary>
            The namespace owner's email address.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.NamespaceInfo.Data">
            <summary>
            A dictionary of named string data that can be attached to namespace
            and that can be used for any purpose.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.NamespaceState">
            <summary>
            Indicates a Temporal namespace status.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.NamespaceState.Unspecified">
            <summary>
            The namespace state is unspecified.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.NamespaceState.Registered">
            <summary>
            The namespace is registered and active.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.NamespaceState.Deprecated">
            <summary>
            The namespace is closed for new workflows but will remain
            until already running workflows are completed and the
            history retention period for the last executed workflow
            has been satisified.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.NamespaceState.Deleted">
            <summary>
            The namespace is deleted.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.Payload">
            <summary>
            Defines a temporal data payload.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Payload.Metadata">
            <summary>
            Payload metadata.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Payload.Data">
            <summary>
            The payload byte[] data.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.Payloads">
            <summary>
            Data payloads.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.Payloads.DataPayloads">
            <summary>
            List of data payloads with metadata.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.PendingActivityInfo">
            <summary>
            Describes the current state of a scheduled or executing activity.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.Client">
            <summary>
            The associated Temporal client.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.ActivityId">
            <summary>
            The activity ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.ActivityType">
            <summary>
            The activiy type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.State">
            <summary>
            The activity state.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.HeartbeatDetails">
            <summary>
            Details from the last activity heartbeart.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.LastHeartbeatTime">
            <summary>
            Time when the last activity heartbeat was received.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.LastStartedTime">
            <summary>
            Time when the activity was most recently started.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.Attempt">
            <summary>
            The number of times the activity has been started/restarted.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.MaximumAttempts">
            <summary>
            The maximum times the activity may be started.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.ScheduledTime">
            <summary>
            Time when the activity is scheduled to run.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.ExpirationTime">
            <summary>
            Time when the activity must complete.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.LastFailure">
            <summary>
            The last failure.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingActivityInfo.LastWorkerIdentity">
            <summary>
            The identity of the last worker that processed this activity.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.PendingActivityState">
            <summary>
            Enumerates the state of an activity.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.PendingActivityState.Unspecified">
            <summary>
            The activity state is unspecified.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.PendingActivityState.Scheduled">
            <summary>
            The activity is waiting to be started.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.PendingActivityState.Started">
            <summary>
            The activity is running.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.PendingActivityState.CancelRequested">
            <summary>
            The activity has a cancellation request pending.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.PendingChildExecutionInfo">
            <summary>
            Decribes the current state of a pending; child workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PendingChildExecutionInfo.#ctor">
            <summary>
            Internal constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingChildExecutionInfo.WorkflowId">
            <summary>
            Returns the workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingChildExecutionInfo.RunId">
            <summary>
            Returns the workflow run ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingChildExecutionInfo.WorkflowTypeName">
            <summary>
            Returns the workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingChildExecutionInfo.InitiatedId">
            <summary>
            $todo(jefflill): What is this?
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PendingChildExecutionInfo.ParentClosePolicy">
            <summary>
            Returns policy used to close this child when its parent is closed.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.PollerInfo">
            <summary>
            Describes the status of a poller (AKA worker) listening to a task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PollerInfo.LastAccessTime">
            <summary>
            The last time the poller accessed Temporal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PollerInfo.Identity">
            <summary>
            Identifies the poller.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PollerInfo.RatePerSecond">
            <summary>
            Operations per second from the poller.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.PropertyNames">
            <summary>
            Enumerates the Temporal proxy message property names as <see cref="T:Neon.Temporal.Internal.PropertyNameUtf8"/>
            values that have the UTF-8 encodings pre-computed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNames.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNames.Add(Neon.Temporal.Internal.PropertyNameUtf8)">
            <summary>
            Adds a property name to the internal hash table.
            </summary>
            <param name="propertyName">The property name.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNames.Lookup(System.Span{System.Byte})">
            <summary>
            Looks up a property name from a <c>byte</c> <see cref="T:System.Span`1"/>.
            </summary>
            <param name="byteSpan">The byte span.</param>
            <returns>The <see cref="T:Neon.Temporal.Internal.PropertyNameUtf8"/>.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the requested property name does not exist.</exception>
        </member>
        <member name="T:Neon.Temporal.Internal.PropertyNameUtf8">
            <summary>
            Maps a property name string to its UTF-8 form.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNameUtf8.ComputeHash(System.Byte[])">
            <summary>
            Computes the hash code for a byte array.
            </summary>
            <param name="bytes">The byte array.</param>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNameUtf8.ComputeHash(System.Span{System.Byte})">
            <summary>
            Computes the hash code for a <c>byte</c> <see cref="T:System.Span`1"/>.
            </summary>
            <param name="bytes">The byte array.</param>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNameUtf8.Equal(System.Span{System.Byte},System.Byte[])">
            <summary>
            Compares a <b>byte</b> <see cref="T:System.Span`1"/> against a <c>byte</c> array
            for equality.
            </summary>
            <param name="byteSpan">The byte span.</param>
            <param name="byteArray">The byte array.</param>
            <returns><c>true</c> if the items are equal.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNameUtf8.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">The property name string.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.PropertyNameUtf8.Name">
            <summary>
            Returns the property name as a string.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.PropertyNameUtf8.NameUtf8">
            <summary>
            Returns the property name encoded as IUTF-8 bytes.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNameUtf8.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.PropertyNameUtf8.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.ResetPointInfo">
            <summary>
            Defines workflow execution reset points.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPointInfo.BinaryChecksum">
            <summary>
            The binary checksum of the reset point.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPointInfo.RunId">
            <summary>
            The run id of the workflow exeuction.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPointInfo.FirstWorkflowTaskCompletedId">
            <summary>
            The id of the first completed workflow task.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPointInfo.CreateTime">
            <summary>
            The create time of the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPointInfo.ExpireTime">
            <summary>
            The expire time of the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPointInfo.Resettable">
            <summary>
            Indicates if the workflow exeuction is resettable.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.ResetPoints">
            <summary>
            Defines a payload of reset points.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.ResetPoints.Points">
            <summary>
            Set of info about a workflow's reset points.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.SearchAttributes">
            <summary>
            Describes workflow execution search attributes.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SearchAttributes.IndexedFields">
            <summary>
            Key-value mapping of string index field to data payload.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.StubManager">
            <summary>
            Manages the dynamic generation of workflow and activity stub classes.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.StubManager.WorkflowMethodKind">
            <summary>
            Describes what a workflow interface method does.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.StubManager.WorkflowMethodKind.Query">
            <summary>
            The method implements a query.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.StubManager.WorkflowMethodKind.Signal">
            <summary>
            The method implements a signal.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.StubManager.WorkflowMethodKind.Workflow">
            <summary>
            The method is a workflow entry point.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails">
            <summary>
            Holds additional information about a workflow interface method.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.Kind">
            <summary>
            The workflow method type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.SignalMethodAttribute">
            <summary>
            The signal attributes for signal methods
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.QueryMethodAttribute">
            <summary>
            The query attributes for query methods.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.WorkflowMethodAttribute">
            <summary>
            The workflow attributes for workflow methods.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.IsVoid">
            <summary>
            Indicates whether the workflow result is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.ReturnType">
            <summary>
            The workflow result type, not including the wrapping <see cref="T:System.Threading.Tasks.Task"/>.
            This will be <see cref="T:System.Void"/> for methods that don't return a value.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.WorkflowMethodDetails.Method">
            <summary>
            The low-level method information.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.StubManager.ActivityMethodDetails">
            <summary>
            Holds additional information about an activity method.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.ActivityMethodDetails.ActivityMethodAttribute">
            <summary>
            The activity method attribute (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.ActivityMethodDetails.IsVoid">
            <summary>
            Indicates whether the activity result is <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.ActivityMethodDetails.ReturnType">
            <summary>
            The activity result type, not including the wrapping <see cref="T:System.Threading.Tasks.Task"/>.
            This will be <see cref="T:System.Void"/> for methods that don't return a value.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.StubManager.ActivityMethodDetails.Method">
            <summary>
            The low-level method information.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.StubManager.debugSourceFolder">
            <summary>
            Set this to folder path where generate stub source files should be
            written when debugging stub generation.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.LogDebug(System.Text.StringBuilder,System.String)">
            <summary>
            Used to insert debug logging code into a generated workflow or activity
            stub.  This code will append a line of text to the [log.txt] file in
            the debug stub source folder.
            </summary>
            <param name="sb">The generated source string builder.</param>
            <param name="text">The text to be logged.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NormalizeTypeName(System.Type)">
            <summary>
            Returns C# compatible fully qualified type name for a type.
            </summary>
            <param name="type">The type.</param>
            <returns>The fully qualified type name.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.AppendStubHelper(System.Text.StringBuilder)">
            <summary>
            Generates the static <b>___StubHelper</b> class that exposes internal methods
            and constructors from <see cref="T:Neon.Temporal.TemporalClient"/> and other types that are
            required by generated workflow and activity stubs.  The generated class uses
            reflection to gain access these members.
            </summary>
            <param name="sbSource">The builder used to generated C# source.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.GetWorkflowStub(System.Type,System.Boolean)">
            <summary>
            Returns the <see cref="T:Neon.Temporal.Internal.DynamicWorkflowStub"/> for a workflow interface, dynamically generating code
            to implement the stub if necessary.
            </summary>
            <param name="workflowInterface">The workflow interface type.</param>
            <param name="isChild">Indicates whether an external or child workflow stub is required.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <paramref name="workflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewWorkflowStub``1(Neon.Temporal.TemporalClient,System.String,System.String,System.String)">
            <summary>
            Creates a dynamically generated stub to be used to connect to an existing an external workflow.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="workflowId">Specifies the workflow ID.</param>
            <param name="runId">Optionally specifies the workflow's run ID.</param>
            <param name="namespace">Optionally specifies a namespace that overrides the the client settings.</param>
            <returns>The stub instance.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewWorkflowStub``1(Neon.Temporal.TemporalClient,Neon.Temporal.StartWorkflowOptions,System.String)">
            <summary>
            Creates a dynamically generated stub to be used to create an external workflow with the
            specified workflow interface.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="options">Optionally specifies the workflow options.</param>
            <param name="workflowTypeName">Optionally specifies the workflow type name.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewChildWorkflowStub``1(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,Neon.Temporal.ChildWorkflowOptions,System.String)">
            <summary>
            Creates a dynamically generated stub for the specified child workflow interface.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="options">Optionally specifies the workflow options.</param>
            <param name="workflowTypeName">Optionally specifies the workflow type name.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewChildWorkflowStub``1(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,System.String,Neon.Temporal.Internal.ChildExecution)">
            <summary>
            Creates a dynamically generated stub for the specified child workflow interface.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">Optionally specifies the workflow type name.</param>
            <param name="childExecution">The child execution.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewChildWorkflowStubById``1(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,System.String,System.String)">
            <summary>
            Creates a dynamically generated external stub for an existing child workflow using the
            workflow ID and optional namespace.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowId">The child workflow ID.</param>
            <param name="namespace">Optionally overrides the parent workflow namespace.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewChildWorkflowStubById``1(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,Neon.Temporal.WorkflowExecution)">
            <summary>
            Creates a dynamically generated external stub for an existing child workflow using the
            workflow execution.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="execution">The child's external workflow execution.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewContinueAsNewStub``1(Neon.Temporal.TemporalClient,Neon.Temporal.ContinueAsNewOptions)">
            <summary>
            Creates a dynamically generated stub that when called will continue the workflow as new.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="options">Optionally continuation options.</param>
            <returns>The stub instance.</returns>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when there are problems with the <typeparamref name="TWorkflowInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.GetActivityStub(System.Type)">
            <summary>
            Returns a <see cref="T:Neon.Temporal.Internal.DynamicActivityStub"/> wrapping the specified activity interface for
            a workflow, dynamically generating the required type if required.
            </summary>
            <param name="activityInterface">The activity interface type.</param>
            <returns>The activity stub instance.</returns>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown when there are problems with the <paramref name="activityInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewActivityStub``1(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,Neon.Temporal.ActivityOptions)">
            <summary>
            Creates a dynamically generated normal (non-local) activity stub for the specified activity interface.
            </summary>
            <typeparam name="TActivityInterface">The activity interface.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="workflow">The parent workflow.</param>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The activity stub instance.</returns>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown when there are problems with the <typeparamref name="TActivityInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.NewLocalActivityStub``2(Neon.Temporal.TemporalClient,Neon.Temporal.Workflow,Neon.Temporal.LocalActivityOptions)">
            <summary>
            Creates a dynamically generated local activity stub for the specified activity interface.
            </summary>
            <typeparam name="TActivityInterface">The activity interface type.</typeparam>
            <typeparam name="TActivityImplementation">The activity implementation.</typeparam>
            <param name="client">The associated <see cref="T:Neon.Temporal.TemporalClient"/>.</param>
            <param name="workflow">The parent workflow.</param>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The activity stub instance.</returns>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown when there are problems with the <typeparamref name="TActivityInterface"/>.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.SerializeArgsExpression(System.Reflection.ParameterInfo[])">
            <summary>
            Returns the C# expression that uses the stub's data converter to
            serialize workflow method parameters to a byte array.
            </summary>
            <param name="args">The parameters.</param>
            <returns>The C# expression.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.SerializeMethodParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Renders the parameter types for a method into an array definition suitable for
            including in generated source code.
            </summary>
            <param name="method">The target method information.</param>
            <returns>The array source code.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.StubManager.StringLiteral(System.String)">
            <summary>
            Renders the string passed as a C# literal, escaping any double quotes.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.SyncSignalCall">
            <summary>
            <b>INTERNAL USE ONLY:</b> Holds information necessary to implement synchronous 
            signals.  This is used internally for transmitting synchronous signals 
            to workflows.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.SyncSignalCall.#ctor(System.String,System.String,System.Byte[])">
            <summary>
            Constructor.
            </summary>
            <param name="targetSignal">Identifies the target signal.</param>
            <param name="signalId">The globally unique signal ID.</param>
            <param name="userArgs">The encoded user arguments being passed to the signal.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalCall.TargetSignal">
            <summary>
            Identifies the signal method targeted by the user.  We need this because the 
            the signal will be sent to <see cref="P:Neon.Temporal.Internal.SyncSignalCall.TargetSignal"/> and the internal handler
            will need this to identify the actual user single method to be called.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalCall.SignalId">
            <summary>
            Specifies a globally unique ID for the signal request operation.  The
            target worker will manage the current state of the signal request and
            the client will use this to poll the worker for the current state.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalCall.UserArgs">
            <summary>
            The encoded user arguments being passed to the signal.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.SyncSignalStatus">
            <summary>
            Holds the status of a synchronous signal execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalStatus.Args">
            <summary>
            Returns the dictionary of signal method arguments keyed by parameter name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalStatus.Completed">
            <summary>
            Returns <c>true</c> if the workflow has finished executing the signal
            and that the result is available (for non-void signals).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalStatus.Error">
            <summary>
            <para>
            Returns potential error information when <see cref="P:Neon.Temporal.Internal.SyncSignalStatus.Completed"/><c>=true</c>.  This
            will return <c>null</c> if the signal completed without error or else an error
            string describing the exception thrown by the signal method.
            </para>
            <note>
            This string must be formatted by <see cref="M:Neon.Temporal.SyncSignalException.GetError(System.Exception)"/>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalStatus.Result">
            <summary>
            Returns the encoded result for signals that return results.  This will be <c>null</c> for 
            signals that don't return a result.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalStatus.Acknowledged">
            <summary>
            Returns <c>true</c> after the workflow has returned the result of the
            completed signal operation to a polling query.  This is used internally
            to delay returning from the workflow while there remain outstanding
            synchronous signals that have not been answered.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalStatus.AcknowledgeTime">
            <summary>
            Returns the time when the signal was acknowledged.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.TaskQueue">
            <summary>
            Represents a Temporal task queue with a <see cref="T:System.String"/> Name
            and <see cref="T:Neon.Temporal.TaskQueueKind"/> kind.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueue.Name">
            <summary>
            Identifies the name of the task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueue.Kind">
            <summary>
            Identifies the kind of task queue (normal/sticky).
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.TaskQueueDescription">
            <summary>
            Describes the current status of a Temporal task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueueDescription.Pollers">
            <summary>
            Lists the pollers (AKA workers) that have communicated with the Temporal cluster over
            the past few minutes.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.TaskQueueStatus">
            <summary>
            Describes the status of a temporal task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueueStatus.BackLogCountHint">
            <summary>
            Task queue back log count hint.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueueStatus.ReadLevel">
            <summary>
            Task queue read level.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueueStatus.AckLevel">
            <summary>
            Task queue ack level.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueueStatus.RatePerSecond">
            <summary>
            Task queue rate per seconds.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TaskQueueStatus.TaskIdBlock">
            <summary>
            Task queue task id block.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.TemporalError">
            <summary>
            <b>INTERNAL USE ONLY:</b> Describes a Temporal error.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.StringToErrorType(System.String)">
            <summary>
            Converts an error type string into an <see cref="T:Neon.Temporal.Internal.TemporalErrorType"/>.
            </summary>
            <param name="typeString">The error string to be converted.</param>
            <returns>The converted error type.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.ErrorTypeToString(Neon.Temporal.Internal.TemporalErrorType)">
            <summary>
            Converts an <see cref="T:Neon.Temporal.Internal.TemporalErrorType"/> into a error string.
            </summary>
            <param name="type">the error type.</param>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.#ctor(System.String,Neon.Temporal.Internal.TemporalErrorType)">
            <summary>
            Constructs an error from parameters.
            </summary>
            <param name="error">The GOLANG error string.</param>
            <param name="type">Optionally specifies the error type. This defaults to <see cref="F:Neon.Temporal.Internal.TemporalErrorType.Generic"/>.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.#ctor(System.Exception)">
            <summary>
            Constructs an error from a .NET exception.
            </summary>
            <param name="e">The exception.</param>
        </member>
        <member name="P:Neon.Temporal.Internal.TemporalError.String">
            <summary>
            Specifies the GOLANG error string.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TemporalError.Type">
            <summary>
            Optionally specifies the GOLANG error type.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.GetErrorType">
            <summary>
            Returns the error type.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.SetErrorType(Neon.Temporal.Internal.TemporalErrorType)">
            <summary>
            Sets the error type.
            </summary>
            <param name="type">The new type.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.ToException">
            <summary>
            Converts the instance into an <see cref="T:Neon.Temporal.TemporalException"/>.
            </summary>
            <returns>One of the exceptions derived from <see cref="T:Neon.Temporal.TemporalException"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalError.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.TemporalErrorType">
            <summary>
            <b>INTERNAL USE ONLY:</b> Enumerates the Temporal error types.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalErrorType.Cancelled">
            <summary>
            An operation was cancelled.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalErrorType.Custom">
            <summary>
            Custom error.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalErrorType.Generic">
            <summary>
            Generic error.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalErrorType.Panic">
            <summary>
            Panic error.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalErrorType.Terminated">
            <summary>
            Terminated error.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalErrorType.Timeout">
            <summary>
            Timeout error.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowCallContext">
            <summary>
            Enumerates the possible contexts workflow code may be executing within.
            This is used to limit what code can do (i.e. query methods shouldn't be
            allowed to execute activities).  This is also used in some situations to
            modify how workflow code behaves.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowCallContext.None">
            <summary>
            The current task is not executing within the context
            of any workflow method.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowCallContext.Entrypoint">
            <summary>
            The current task is executing within the context of
            a workflow entrypoint.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowCallContext.Signal">
            <summary>
            The current task is executing within the context of a
            workflow signal method.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowCallContext.Query">
            <summary>
            The current task is executing within the context of a
            workflow query method.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowCallContext.Activity">
            <summary>
            The current task is executing within the context of a
            normal or local activity.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowDescription">
            <summary>
            Describes a workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescription.ExecutionConfig">
            <summary>
            Describes the workflow's configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescription.WorkflowExecutionInfo">
            <summary>
            Describes the workflow's execution details.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescription.PendingActivities">
            <summary>
            Describes the workflow's scheduled and executing activities.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescription.PendingChildren">
            <summary>
            Describes the workflow's scheduled and executing child workflows.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecutionConfig">
            <summary>
            Describes a workflow's configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionConfig.TaskQueue">
            <summary>
            Identifies the task queue where the workflow was scheduled.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionConfig.WorkflowExecutionTimeout">
            <summary>
            Maximum time the entire workflow may take to complete end-to-end.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionConfig.WorkflowRunTimeout">
            <summary>
            Maximum time a single workflow run may take to complete.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionConfig.DefaultWorkflowTaskTimeout">
            <summary>
            Maximum time a workflow task/decision may take to complete.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecutionInfo">
            <summary>
            Describes the current state of a workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.Execution">
            <summary>
            Describes the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.Type">
            <summary>
            Identifies the workflow implementation.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.StartTime">
            <summary>
            Workflow start time or <c>null</c> if the workflow hasn't started yet.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.CloseTime">
            <summary>
            Workflow close time or <c>null</c> if the workflow hasn't completed yet.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.HasStarted">
            <summary>
            Returns <c>true</c> if the workflow has been started and is still running
            or has already completed.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.Status">
            <summary>
            Workflow execution status describing the state of the workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.IsClosed">
            <summary>
            Returns <c>true</c> if the workflow has been completed.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.IsRunning">
            <summary>
            Returns <c>true</c> if the workflow is currently running.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.HistoryLength">
            <summary>
            Workflow history length.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.ParentNamespaceId">
            <summary>
            Identifies the namespece where the parent workflow is running
            (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.ParentExecution">
            <summary>
            Identfies the parent workflow (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.ExecutionTime">
            <summary>
            The workflow execution time.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.Memo">
            <summary>
            Optional workflow metadata.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.SearchAttributes">
            <summary>
            Workflow execution search attributes.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.AutoResetPoints">
            <summary>
            The auto reset points of the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecutionInfo.TaskQueue">
            <summary>
            The Task Queue the worker is running on.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecutionStatus">
            <summary>
            Used to identify the status of a Temporal workflow.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.Unspecified">
            <summary>
            Workflow has an unspecified status.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.Running">
            <summary>
            Workflow is running.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.Completed">
            <summary>
            Workflow is completed.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.Failed">
            <summary>
            Workflow has failed.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.CANCELED">
            <summary>
            Workflow canceled.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.Terminated">
            <summary>
            Workflow has been terminated.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.ContinuedAsNew">
            <summary>
            Workflow has continued as new.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.WorkflowExecutionStatus.TimedOut">
            <summary>
            Workflow timed out.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowInfo">
            <summary>
            Returns information about an executing workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInfo.Namespace">
            <summary>
            Returns the workflow namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInfo.WorkflowId">
            <summary>
            Returns the workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInfo.RunId">
            <summary>
            Returns the workflow's current run ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInfo.WorkflowType">
            <summary>
            Returns the workflow's workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInfo.TaskQueue">
            <summary>
            Returns the workflow task queue.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowCancelChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowCancelChildRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelChildReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowCancelChildRequest">
            <summary>
            <b>client --> proxy:</b> Cancels a child workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowCancelChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowCancelChildRequest.ChildId">
            <summary>
            Identifies the child workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelChildRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowCancelReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowCancelRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowCancelRequest">
            <summary>
            <b>proxy --> client:</b> Cancels a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowCancelRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowCancelRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowCancelRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowCancelRequest.Namespace">
            <summary>
            Optionally overrides the current client namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowCancelRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowDescribeExecutionReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDescribeExecutionReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescribeExecutionReply.Details">
            <summary>
            The workflow execution details.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDescribeExecutionReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDescribeExecutionReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest">
            <summary>
            <b>proxy --> client:</b> Describes an executing workflow instance.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.Namespace">
            <summary>
            Optionally identifies the target namespace when <see cref="P:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.RunId"/> isn't passed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDescribeExecutionRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowDisconnectContextReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowDisconnectContextRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDisconnectContextReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDisconnectContextReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDisconnectContextReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowDisconnectContextRequest">
            <summary>
            <b>client --> proxy:</b> Commands temporal-proxy to replace the current workflow
            context with context that is disconnected from the parent context.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDisconnectContextRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowDisconnectContextRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDisconnectContextRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowDisconnectContextRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecuteChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowExecuteChildReply"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteChildReply.ChildId">
            <summary>
            The child workflow identifier.  This will be used in other messages such 
            as <see cref="T:Neon.Temporal.Internal.WorkflowSignalChildRequest"/>, <see cref="T:Neon.Temporal.Internal.WorkflowWaitForChildRequest"/>,
            and <see cref="T:Neon.Temporal.Internal.WorkflowCancelChildRequest"/> to identify the target child workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteChildReply.Execution">
            <summary>
            Returns details identifying the child workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteChildReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecuteChildRequest">
            <summary>
            <b>client --> proxy:</b> Begins execution of a child workflow returning the
            new workflow IDs.  A subsequent <see cref="T:Neon.Temporal.Internal.WorkflowWaitForChildRequest"/> message
            will be sent to wait for the workflow to actually finish.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteChildRequest.Workflow">
            <summary>
            Specifies the child workflow to be executed.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteChildRequest.Args">
            <summary>
            Specifies the child workflow arguments.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteChildRequest.Options">
            <summary>
            Specifies the child workflow options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteChildRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecuteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowExecuteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteReply.Execution">
            <summary>
            Returns details identifying the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowExecuteRequest">
            <summary>
            <b>proxy --> client:</b> Starts a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteRequest.Workflow">
            <summary>
            Identifies the workflow implementation to be started.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteRequest.Args">
            <summary>
            Optionally specifies the workflow arguments encoded as a byte array.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteRequest.Options">
            <summary>
            Optionally specifies the workflow start options.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowExecuteRequest.Namespace">
            <summary>
            Specifies the Temporal namespace where the workflow will run.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowExecuteRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowFutureReadyReply">
            <summary>
            <para>
            <b>proxy --> client:</b> This is a special reply message sent for workflow operations that
            are implemented in GOLANG as futures and may be executed in parallel.  <b>temporal-proxy</b>
            will send this message after it has submitted the operation to Temporal but before the future
            actually completes.  The .NET client uses this reply as an indication that another Temporal
            operation may be started.
            </para>
            <note>
            This message does not have a corresponding request message (which is why the name doesn't end with "Reply".
            </note>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowFutureReadyReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowFutureReadyReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowFutureReadyReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowFutureReadyRequest">
            <summary>
            <b>proxy --> client:</b> Sent for workflow operations that are implemented in GOLANG as futures 
            and may be executed in parallel.  <b>temporal-proxy</b> will send this message after it has 
            submitted the operation to Temporal but before the future actually completes.  The .NET client 
            uses this as an indication that another Temporal operation may be started.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowFutureReadyRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowFutureReadyRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowFutureReadyRequest.FutureOperationId">
            <summary>
            The ID of the original operation what has been submitted to Temporal
            and who's future has been returned.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowFutureReadyRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowFutureReadyRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetLastLastReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowGetLastResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetLastLastReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetLastLastReply.Result">
            <summary>
            Indicates the workflow's last completion result.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetLastLastReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetLastLastReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetLastResultRequest">
            <summary>
            <b>client --> proxy:</b> Returns the result from the last execution of the workflow.
             This can be used by CRON workflows to retrieve state from the last workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetLastResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetLastResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetLastResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetLastResultRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowGetResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetResultReply.Result">
            <summary>
            The query result bytes or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetResultReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetResultRequest">
            <summary>
            <b>proxy --> client:</b> Requests the results from a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetResultRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetResultRequest.RunId">
            <summary>
            Identifies the specific workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetResultRequest.Namespace">
            <summary>
            Identifies the target namespace.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetResultRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetTimeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowGetTimeReply"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetTimeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetTimeReply.Time">
            <summary>
            The current workflow time expressed as 100 nanosecond ticks
            since 01/01/0001 00:00.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetTimeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetTimeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetTimeRequest">
            <summary>
            <b>client --> proxy:</b> Requests the current workflow time.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetTimeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetTimeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetTimeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetTimeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetVersionReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowGetVersionRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetVersionReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetVersionReply.Version">
            <summary>
            Returns the workflow implementation version. 
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetVersionReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetVersionReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowGetVersionRequest">
            <summary>
            <b>client --> proxy:</b> Manages workflow versioning.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetVersionRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetVersionRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetVersionRequest.ChangeId">
            <summary>
            Identifies change from one workflow implementation version to another.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetVersionRequest.MinSupported">
            <summary>
            Specifies the minimum supported workflow implementation version.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowGetVersionRequest.MaxSupported">
            <summary>
            Specifies the maximum supported workflow implementation version.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetVersionRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowGetVersionRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowHasLastResultReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowHasLastResultRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowHasLastResultReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowHasLastResultReply.HasResult">
            <summary>
            Indicates whether the workflow has a last completion result.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowHasLastResultReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowHasLastResultReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowHasLastResultRequest">
            <summary>
            <b>client --> proxy:</b> Determines whether the last execution of the workflow has
             a completion result.  This can be used by CRON workflows to determine whether the
             last execution returned a result.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowHasLastResultRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowHasLastResultRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowHasLastResultRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowHasLastResultRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowInvokeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.Result">
            <summary>
            The workflow execution result or <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNew">
            <summary>
            Indicates whether the workflow should be exited and then restarted,
            with an empty history.  This is useful for very long running looping
            workflows that would otherwise end up with very long task histories.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewArgs">
            <summary>
            Specifies the arguments to use for the new workflow when 
            <see cref="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNew"/> is <c>true</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewExecutionStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewScheduleToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewScheduleToStartTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewStartToCloseTimeout">
            <summary>
            Optionally overrides the current workflow's timeout for the restarted
            workflow when this value is greater than zero.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewWorkflow">
            <summary>
             Optionally overrides the current workflow scheduled for 
             execution upon restart when this value is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewTaskQueue">
            <summary>
            Optionally overrides the current workflow's task queue for the restarted
            workflow when this value is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ContinueAsNewNamespace">
            <summary>
            Optionally overrides the current workflow's namespace for the restarted
            workflow when this value is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeReply.ForceReplay">
            <summary>
            Optionally indicates that the workflow should be aborted such that it
            will be restarted with decision tasks being replayed as required.  The
            <b>temporal-proxy</b> should do this via a GOLANG <b>panic("force-replay")</b>
            within the workflow function.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowInvokeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a workflow instance.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.Name">
            <summary>
            Identifies the workflow implementation to be started.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.Args">
            <summary>
            The workflow arguments encoded into a byte array (or <c>null</c>).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.Namespace">
            <summary>
            The namespace hosting the workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.WorkflowId">
            <summary>
            The original workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.RunId">
            <summary>
            The workflow run ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.WorkflowType">
            <summary>
            The workflow type name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.TaskQueue">
            <summary>
            The task queue where the workflow is executing.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.ExecutionStartToCloseTimeout">
            <summary>
            The maximum duration the workflow is allowed to run.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowInvokeRequest.ReplayStatus">
            <summary>
            Indicates the current workflow replay state.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowInvokeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowMutableReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowMutableRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowMutableReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowMutableReply.Result">
            <summary>
            Holds the mutable result.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowMutableReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowMutableReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowMutableRequest">
            <summary>
            <b>proxy --> client:</b> Invokes a workflow instance.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowMutableRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowMutableRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowMutableRequest.MutableId">
            <summary>
            Identifies the mutable value.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowMutableRequest.Result">
            <summary>
            The mutable value to be returned.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowMutableRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowMutableRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueryInvokeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowQueryInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryInvokeReply.Result">
            <summary>
            The query result bytes or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryInvokeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueryInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Queries a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.QueryName">
            <summary>
            Identifies the query.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.QueryArgs">
            <summary>
            Optionally specifies the query arguments.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.ReplayStatus">
            <summary>
            Indicates the current workflow replay state.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryInvokeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueryReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowQueryRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryReply.Result">
            <summary>
            The query result bytes or <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueryRequest">
            <summary>
            <b>proxy --> client:</b> Queries a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be queried.  The latest run
            will be queried when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryRequest.Namespace">
            <summary>
            Identifies the target namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryRequest.QueryName">
            <summary>
            Identifies the query.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueryRequest.QueryArgs">
            <summary>
            Optionally specifies the query arguments.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueryRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueCloseReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowQueueNewRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueCloseReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueCloseReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueCloseReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueCloseRequest">
            <summary>
            <b>proxy --> client:</b> Closes a workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueCloseRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueCloseRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueCloseRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueCloseRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueCloseRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueNewReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowQueueNewRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueNewReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueNewReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueNewReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueNewRequest">
            <summary>
            <b>proxy --> client:</b> Creates a new workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueNewRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueNewRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueNewRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueNewRequest.Capacity">
            <summary>
            Specifies the capacity of the queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueNewRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueNewRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueReadReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowQueueReadRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueReadReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueReadReply.IsClosed">
            <summary>
            Set to <c>true</c> when the queue has been closed.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueReadReply.Data">
            <summary>
            The data item read from the queue or <c>null</c> if the operation
            timed out or the queue has been closed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueReadReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueReadReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueReadRequest">
            <summary>
            <b>proxy --> client:</b> Reads data from a workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueReadRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueReadRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueReadRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueReadRequest.Timeout">
            <summary>
            The maximum time to wait for a data item or <see cref="F:System.TimeSpan.Zero"/> to 
            wait indefinitiely.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueReadRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueReadRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueWriteReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowQueueWriteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueWriteReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueWriteReply.IsFull">
            <summary>
            Indicates when the queue is full and the item could not be written.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueWriteReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueWriteReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowQueueWriteRequest">
            <summary>
            <b>proxy --> client:</b> Writes data to a workflow queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueWriteRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueWriteRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueWriteRequest.QueueId">
            <summary>
            Identifies the queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueWriteRequest.NoBlock">
            <summary>
            Indicates whether the write operation should not block when
            the queue is full.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowQueueWriteRequest.Data">
            <summary>
            The data to be written to the queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueWriteRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowQueueWriteRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowRegisterReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowRegisterRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRegisterReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRegisterReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRegisterReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowRegisterRequest">
            <summary>
            <b>client --> proxy:</b> Registers a workflow handler by name.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRegisterRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowRegisterRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowRegisterRequest.Name">
            <summary>
            Identifies the workflow implementation (AKA the workflow type name).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowRegisterRequest.DisableAlreadyRegisteredCheck">
            <summary>
            Disables checks for duplicate registrations.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRegisterRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRegisterRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowReply">
            <summary>
            Base class for all workflow related replies.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowReply.ContextId">
            <summary>
            <para>
            Uniquely identifies the workflow context associated with this request.
            </para>
            <note>
            Not all derived classes actually require this property.  In those cases,
            this can remain as its default zero value.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowReply.ReplayStatus">
            <summary>
            For workflow requests related to an executing workflow, this will indicate
            the current history replay state.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowRequest">
            <summary>
            Base class for all workflow related requests.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowRequest.ContextId">
            <summary>
            <para>
            Uniquely identifies the workflow context associated with this request.
            </para>
            <note>
            Not all derived classes actually require this property.  In those cases,
            this can remain as its default zero value.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSetCacheSizeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetCacheSizeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetCacheSizeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetCacheSizeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest">
            <summary>
            <b>client --> proxy:</b> Sets the maximum number of bytes the client will use
            to cache the history of a sticky workflow on a workflow worker as a performance
            optimization.  When this is exceeded for a workflow, its full history will
            need to be retrieved from the Temporal cluster the next time the workflow
            instance is assigned to a worker. 
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest.Size">
            <summary>
            Specifies the maximum number of bytes used for caching sticky workflows.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetCacheSizeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSetQueryHandlerReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowExecuteRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetQueryHandlerReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetQueryHandlerReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetQueryHandlerReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSetQueryHandlerRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetQueryHandlerRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSetQueryHandlerRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSetQueryHandlerRequest.QueryName">
            <summary>
            Identifies the query.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetQueryHandlerRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSetQueryHandlerRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSignalChildRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalChildReply.Result">
            <summary>
            Returns the result of signaling a child workflow
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalChildReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalChildRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a child workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalChildRequest.ChildId">
            <summary>
            Identifies child workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalChildRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalChildRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalChildRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalInvokeReply">
            <summary>
            <b>client --> proxy:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSignalInvokeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalInvokeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalInvokeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalInvokeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalInvokeRequest">
            <summary>
            <b>proxy --> client:</b> Sends a received signal to a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.ReplayStatus">
            <summary>
            Indicates the current workflow replay state.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalInvokeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSignalRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a running workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalRequest.Namespace">
            <summary>
            Identifies the target namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalSubscribeReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalSubscribeReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalSubscribeReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalSubscribeReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest">
            <summary>
            <b>proxy --> client:</b> Subscribes a workflow to a named signal.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest.SignalName">
            <summary>
            Identifies the signal being subscribed.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalSubscribeRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalWithStartReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSignalWithStartRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalWithStartReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartReply.Execution">
            <summary>
            Returns details identifying the workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalWithStartReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalWithStartReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSignalWithStartRequest">
            <summary>
            <b>proxy --> client:</b> Sends a signal to a workflow, starting the
            workflow if it doesn't exist.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.Workflow">
            <summary>
            Identifies the workflow to be executed if the workflow instance
            idntified by <see cref="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.WorkflowId"/> is not currently running.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.Namespace">
            <summary>
            Identifies the target namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.SignalName">
            <summary>
            Identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.SignalArgs">
            <summary>
            Optionally specifies the signal arguments.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.Options">
            <summary>
            Optionally specifies the workflow start options.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.WorkflowArgs">
            <summary>
            Optionally specifies the workflow arguments.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSignalWithStartRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSleepReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowSleepRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSleepReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSleepReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSleepReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowSleepRequest">
            <summary>
            <b>client --> proxy:</b> Commands the workflow to sleep for a period of time.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSleepRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSleepRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowSleepRequest.Duration">
            <summary>
            Specifies the time to sleep.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSleepRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowSleepRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowTerminateReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowTerminateRequest"/>
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowTerminateReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowTerminateReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowTerminateReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowTerminateRequest">
            <summary>
            <b>proxy --> client:</b> Terminates a workflow execution.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowTerminateRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowTerminateRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowTerminateRequest.WorkflowId">
            <summary>
            Identifies the workflow by ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowTerminateRequest.RunId">
            <summary>
            Identifies the specific workflow execution to be cancelled.  The latest run
            will be cancelled when this is <c>null</c> or empty.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowTerminateRequest.Namespace">
            <summary>
            Identifies the target namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowTerminateRequest.Reason">
            <summary>
            Optionally indicates the termination reason.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowTerminateRequest.Details">
            <summary>
            Optionally includes additional termination details encoded as a byte array.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowTerminateRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowTerminateRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowWaitForChildReply">
            <summary>
            <b>proxy --> client:</b> Answers a <see cref="T:Neon.Temporal.Internal.WorkflowWaitForChildRequest"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowWaitForChildReply.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowWaitForChildReply.Result">
            <summary>
            The child workflow results encoded as bytes.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowWaitForChildReply.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowWaitForChildReply.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowWaitForChildRequest">
            <summary>
            <b>client --> proxy:</b> Waits for a child workflow to complete.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowWaitForChildRequest.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowWaitForChildRequest.ReplyType">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowWaitForChildRequest.ChildId">
            <summary>
            Identifies the child workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowWaitForChildRequest.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.Internal.WorkflowWaitForChildRequest.CopyTo(Neon.Temporal.Internal.ProxyMessage)">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.Internal.WorkflowType">
            <summary>
            WorkflowType identifies a Temporal workflow type
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.WorkflowType.Name">
            <summary>
            The <see cref="T:System.String"/> Name of the workflow type.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.SyncSignalReply">
            <summary>
            Holds the internal reply for synchronous signals.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalReply.Error">
            <summary>
            Used to indicate that an exception was thrown by the signal method.
            This will be set to the exception name and error message.  This will
            be <c>null</c> when the signal method completed successfully.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.SyncSignalReply.Result">
            <summary>
            This holds the result for signals that return result and will be
            <c>null</c> for signals that don't return a result.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Internal.TemporalHelper">
            <summary>
            Temporal helper methods and constants.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Internal.TemporalHelper.NanosecondsPerSecond">
            <summary>
            Number of nanoseconds per second (spoiler alert: it's 1 billion).
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TemporalHelper.MaxTimespan">
            <summary>
            Returns the maximum timespan supported by Temporal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Internal.TemporalHelper.MinTimespan">
            <summary>
            Returns the minimum timespan supported by Temporal.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.IsTask(System.Type)">
            <summary>
            Determines whether the type passed is a <see cref="T:System.Threading.Tasks.Task"/>.
            </summary>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if the type is a <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.IsTaskT(System.Type)">
            <summary>
            Determines whether the type passed is a <see cref="T:System.Threading.Tasks.Task`1"/>.
            </summary>
            <param name="type">The type being tested.</param>
            <returns><c>true</c> if the type is a <see cref="T:System.Threading.Tasks.Task`1"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.TypeNameToSource(System.String)">
            <summary>
            Converts a .NET type name into a form suitable for using in generated C# source code.
            This handles the replacement of any embedded <b>(+)</b> characters that indicate
            a nested type into <b>(.)</b> characters compatible with C#. 
            </summary>
            <param name="typeName">The type name.</param>
            <returns>The normalized type name.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.TypeNameToSource(System.Type)">
            <summary>
            Returns the fully qualified name of the type passed, converting it into a form 
            suitable for using in generated C# source code. This handles the replacement of 
            any embedded <b>(+)</b> characters that indicate a nested type into <b>(.)</b> 
            characters compatible with C#. 
            </summary>
            <param name="type">The type.</param>
            <returns>The normalized fully qualified type name.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetWorkflowTypeName(System.Type,Neon.Temporal.WorkflowMethodAttribute)">
            <summary>
            Returns the Temporal workflow type name to be used for a workflow interface or
            implementation class and optionally, a specific workflow method.
            </summary>
            <param name="workflowType">The workflow interface or implementation type.</param>
            <param name="workflowMethodAttribute">Optionally specifies the <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> for the target method.</param>
            <returns>The fully qualifed workflow type name.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetWorkflowTypeName``1(System.String)">
            <summary>
            Returns the Temporal workflow type name for a workflow interface and target method.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[WorkflowMethod]</c>
            attribiute tagging the workflow method within the interface.
            </param>
            <returns>The workflow type name for the workflow interface and target method.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default workflow method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetActivityTypeName(System.Type,Neon.Temporal.ActivityAttribute)">
            <summary>
            Returns the Temporal activity type name to be used for an activity interface or
            implementation class.
            </summary>
            <param name="activityType">The activity interface or implementation type.</param>
            <param name="activityAttribute">Optionally specifies the <see cref="T:Neon.Temporal.ActivityAttribute"/>.</param>
            <returns>The fully qualifed activity type name.</returns>
            <remarks>
            <para>
            If <paramref name="activityAttribute"/> is passed and <see cref="P:Neon.Temporal.ActivityAttribute.Name"/>
            is not <c>null</c> or empty, then the name specified in the attribute is returned.
            </para>
            <para>
            Otherwise, we'll return the fully qualified name of the activity interface
            with the leadting "I" removed.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetActivityTypeName``1(System.String)">
            <summary>
            Returns the Temporal activity type name for an activity interface and target method.
            </summary>
            <typeparam name="TActivityInterface">The workflow interface.</typeparam>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[WorkflowMethod]</c>
            attribiute tagging the workflow method within the interface.
            </param>
            <returns>The workflow type name for the workflow interface and target method.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default workflow method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ValidateWorkflowInterface(System.Type)">
            <summary>
            Ensures that the type passed is a valid workflow interface.
            </summary>
            <param name="workflowInterface">The type being tested.</param>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ValidateWorkflowImplementation(System.Type)">
            <summary>
            Ensures that the type passed is a valid workflow implementation.
            </summary>
            <param name="workflowType">The type being tested.</param>
            <exception cref="T:Neon.Temporal.WorkflowTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetWorkflowInterface(System.Type)">
            <summary>
            Returns the workflow interface for a workflow implementation class.
            </summary>
            <param name="workflowType">The workflow implementation class.</param>
            <returns>The workflow interface type.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ValidateActivityTypeName(System.String)">
            <summary>
            Ensures that an activity type name is valid.
            </summary>
            <param name="name">The activity type name being checked.</param>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown if the name passed is not valid.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ValidateActivityInterface(System.Type)">
            <summary>
            Ensures that the type passed is a valid activity interface.
            </summary>
            <param name="activityInterface">The type being tested.</param>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ValidateActivityImplementation(System.Type)">
            <summary>
            Ensures that the type passed is a valid activity implementation.
            </summary>
            <param name="activityType">The type being tested.</param>
            <exception cref="T:Neon.Temporal.ActivityTypeException">Thrown when the interface is not valid.</exception>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetActivityInterface(System.Type)">
            <summary>
            Returns the activity interface for an activity implementation class.
            </summary>
            <param name="activityType">The activity implementation class.</param>
            <returns>The activity interface type.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.Normalize(System.TimeSpan)">
            <summary>
            Ensures that the timespan passed doesn't exceed the minimum or maximum
            supported by Temporal/GOLANG.
            </summary>
            <param name="timespan">The input.</param>
            <returns>The adjusted output.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetWorkflowMethod(System.Type,System.String)">
            <summary>
            Searches a workflow interface for a method with a <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> 
            with a matching name.
            </summary>
            <param name="workflowInterface">The workflow interface.</param>
            <param name="methodName">The method name to be matched.</param>
            <returns>The method information or <c>null</c> when there's no matching method.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetActivityMethod(System.Type,System.String)">
            <summary>
            Searches an activity interface for a method with a <see cref="T:Neon.Temporal.ActivityMethodAttribute"/> 
            with a matching name.
            </summary>
            <param name="activityInterface">The activity interface.</param>
            <param name="methodName">The method name to be matched.</param>
            <returns>The method information or <c>null</c> when there's no matching method.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ToTemporal(System.TimeSpan)">
            <summary>
            Converts a .NET <see cref="T:System.TimeSpan"/> into a Temporal/GOLANG duration
            (aka a <c>long</c> specifying the interval in nanoseconds.
            </summary>
            <param name="timespan">The input .NET timespan.</param>
            <returns>The duration in nanoseconds.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ParseTemporalTimestamp(System.String)">
            <summary>
            Parses a Temporal timestamp string and converts it to a UTC
            <see cref="T:System.DateTime"/>.
            </summary>
            <param name="timestamp">The timestamp string.</param>
            <returns>The parsed <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.UnixNanoToDateTimeUtc(System.Int64)">
            <summary>
            Converts UNIX nano time (UTC) to a <see cref="T:System.DateTime"/>.
            </summary>
            <param name="nanoseconds">Nano seconds from midnight 1-1-1970 (UTC)</param>
            <returns>The corresponding <see cref="T:System.DateTime"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetTypeName(System.Type)">
            <summary>
            Returns the name we'll use for a type when generating type references.
            </summary>
            <param name="type">The type.</param>
            <returns>The type name.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.TypeToCSharp(System.Type)">
            <summary>
            Resolves the type passed into a nice string taking generic types 
            and arrays into account.  This is used when generating workflow
            and activity stubs.
            </summary>
            <param name="type">The referenced type.</param>
            <returns>The type reference as a string or <c>null</c> if the type is not valid.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.LoadAssembly(System.IO.Stream)">
            <summary>
            Loads the assembly from a stream into current <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> or
            <see cref="T:System.AppDomain"/>, depending on whether we're running on .NET Core or
            .NET Frtamework.
            </summary>
            <param name="stream">The stream with the assembly bytes.</param>
            <returns>The loaded <see cref="T:System.Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.LoadAssemblyNetCore(System.IO.Stream)">
            <summary>
            <b>.NET CORE ONLY:</b> Loads the assembly from a stream into the current <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/>.
            </summary>
            <param name="stream">The stream with the assembly bytes.</param>
            <returns>The loaded <see cref="T:System.Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.LoadAssemblyNetFramework(System.IO.Stream)">
            <summary>
            <b>.NET FRAMEWORK ONLY:</b> Loads the assembly from a stream into the current <see cref="T:System.AppDomain"/>.
            </summary>
            <param name="stream">The stream with the assembly bytes.</param>
            <returns>The loaded <see cref="T:System.Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ToTemporalLogLevel(Neon.Diagnostics.LogLevel)">
            <summary>
            Converts a Neon <see cref="T:Neon.Diagnostics.LogLevel"/> value into a <b>temporal-proxy</b> compatible
            log level string.
            </summary>
            <param name="logLevel">The input log level.</param>
            <returns>The <b>temporal-proxy</b> compatable level string.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetActivityTarget(System.Type,System.String)">
            <summary>
            Returns the activity type and method information for an activity interface and 
            an optional target method name.
            </summary>
            <param name="activityInterface">The target activity interface.</param>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[ActivityMethod]</c>
            attribiute tagging the activity method within the interface.
            </param>
            <returns>The activity type name for the activity interface as well as the method information and attribute.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default activity method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.GetWorkflowTarget(System.Type,System.String)">
            <summary>
            Returns the workflow type and method information for a workflow interface and 
            an optional target method name.
            </summary>
            <param name="workflowInterface">The target workflow interface.</param>
            <param name="methodName">
            Optionally specifies the target method name (as specified in the <c>[WorkflowMethod]</c>
            attribiute tagging the workflow method within the interface.
            </param>
            <returns>The workflow type name for the workflow interface as well as the method information and attribute.</returns>
            <exception cref="T:System.ArgumentException">Thrown if target method does not exist.</exception>
            <remarks>
            <paramref name="methodName"/> is optional.  When this is passed as <c>null</c>
            or empty, the default workflow method will be targeted (if any).
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ConvertArg(System.Type,System.Object)">
            <summary>
            <para>
            Used to convert an argument value being passed to a workflow or activity from
            its current type to the target parameter type.  For example, if an <c>int</c>
            argument is being passed to a <c>double</c> parameter, this method will convert
            the <c>int</c> to a <c>double</c> and return the <c>double</c>.
            </para>
            <para>
            This mimics the behavior of the C# complier which which will also perform these
            implicit conversions so the workflow developer won't have to do this explicitly
            (which would be really annoying).
            </para>
            </summary>
            <param name="parameterType">The parameter type we'll be casting <paramref name="arg"/> to.</param>
            <param name="arg">The argument value being passed.</param>
            <returns>The converted argument.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.DebugLog(System.String)">
            <summary>
            <b>INTERNAL USE ONLY:</b> Appends a line of text to the debug log which is
            used internally to debug generated code like stubs.  This hardcodes its
            output to <b>C:\Temp\temporal-debug.log</b> so this currently only works
            on Windows.
            </summary>
            <param name="text">The line of text to be written.</param>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.ArgsToBytes(Neon.Temporal.IDataConverter,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            <b>INTERNAL USE ONLY:</b> Serializes an array of argument objects to bytes using
            Temporal argument serialization conventions and the specified <see cref="T:Neon.Temporal.IDataConverter"/>.
            </summary>
            <param name="converter">The data converter.</param>
            <param name="args">The arguments.</param>
            <returns>The serialized bytes or <c>null</c> when there are no arguments.</returns>
        </member>
        <member name="M:Neon.Temporal.Internal.TemporalHelper.BytesToArgs(Neon.Temporal.IDataConverter,System.Byte[],System.Type[])">
            <summary>
            <b>INTERNAL USE ONLY:</b> Deserializes encoded bytes (or <c>null</c>) into an array of 
            arguments using Temporal argument conventions and the specified <see cref="T:Neon.Temporal.IDataConverter"/>.
            </summary>
            <param name="converter">The data converter.</param>
            <param name="bytes">The serialized bytes or <c>null</c> when there are no arguments.</param>
            <param name="argTypes">The expected argument types.</param>
            <returns>The deserialized arguments as an array.</returns>
        </member>
        <member name="T:Neon.Temporal.IWorkflow">
            <summary>
            All workflow interfaces must derive from this interface.
            </summary>
        </member>
        <member name="T:Neon.Temporal.JsonDataConverter">
            <summary>
            <para>
            Implements <see cref="T:Neon.Temporal.IDataConverter"/> by serializing data to/from
            UTF-8 encoded JSON text.
            </para>
            <note>
            This converter uses the Newtonsoft <a href="https://www.newtonsoft.com/json">JSON.NET</a>
            package so you can decorate your data types with attributes such as <c>[JsonProperty]</c>,
            <c>[JsonIgnore]</c>,... to control how your data is serialized.
            </note>
            <note>
            This implementation also supports values that implement <see cref="T:Neon.Data.IRoundtripData"/> to make
            it easier to manage data schema changes. 
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.JsonDataConverter.Instance">
            <summary>
            Returns a global <see cref="T:Neon.Temporal.JsonDataConverter"/> instance.  This is used
            internally by <b>Neon.Temporal</b> library.
            </summary>
        </member>
        <member name="M:Neon.Temporal.JsonDataConverter.FromData``1(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.JsonDataConverter.FromData(System.Type,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.JsonDataConverter.FromDataArray(System.Byte[],System.Type[])">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.JsonDataConverter.ToData(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.JsonDataConverter.ToDataArray(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.LocalActivityFutureStub`2">
            <summary>
            Used to execute a local activity in parallel with other activities or child workflows.
            Instances are created via <see cref="M:Neon.Temporal.Workflow.NewLocalActivityStub``2(Neon.Temporal.LocalActivityOptions)"/>.
            </summary>
            <typeparam name="TActivityInterface">Specifies the activity interface.</typeparam>
            <typeparam name="TActivityImplementation">Specifies the local activity implementation class.</typeparam> 
        </member>
        <member name="T:Neon.Temporal.LocalActivityFutureStub`2.AsyncFuture">
            <summary>
            Implements the activity future that returns <c>void</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.AsyncFuture.#ctor(Neon.Temporal.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.AsyncFuture.GetAsync">
            <inheritdoc/>
        </member>
        <member name="T:Neon.Temporal.LocalActivityFutureStub`2.AsyncFuture`1">
            <summary>
            Implements an activity future that returns a value.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.AsyncFuture`1.#ctor(Neon.Temporal.Workflow,System.Int64)">
            <summary>
            Constructor.
            </summary>
            <param name="parentWorkflow">Identifies the parent workflow context.</param>
            <param name="activityId">The workflow local activity ID.</param>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.AsyncFuture`1.GetAsync">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.#ctor(Neon.Temporal.Workflow,System.String,Neon.Temporal.LocalActivityOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The associated parent workflow.</param>
            <param name="methodName">
            Optionally identifies the target activity method by the name specified in
            the <c>[ActivityMethod]</c> attribute tagging the method.  Pass a <c>null</c>
            or empty string to specify the default method.
            </param>
            <param name="options">The activity options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.StartAsync``1(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <typeparam name="TResult">The local activity result type.</typeparam>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.LocalActivityFutureStub`2.StartAsync(System.Object[])">
            <summary>
            Starts the target activity that returns <c>void</c>, passing the specified arguments.
            </summary>
            <param name="args">The arguments to be passed to the activity.</param>
            <returns>The <see cref="T:Neon.Tasks.IAsyncFuture`1"/> with the <see cref="M:Neon.Tasks.IAsyncFuture`1.GetAsync"/> that can be used to retrieve the workfow result.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when attempting to start a stub more than once.</exception>
            <remarks>
            <para>
            You must take care to pass parameters that are compatible with the target activity parameters.
            These are checked at runtime but not while compiling.
            </para>
            <note>
            Any given <see cref="T:Neon.Temporal.ActivityFutureStub`1"/> may only be executed once.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.LocalActivityOptions">
            <summary>
            Specifies options used when running a local workflow activity.
            </summary>
        </member>
        <member name="M:Neon.Temporal.LocalActivityOptions.Normalize(Neon.Temporal.TemporalClient,Neon.Temporal.LocalActivityOptions)">
            <summary>
            Normalizes the options passed by creating or cloning a new instance as
            required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Temporal client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <returns>The normalized options.</returns>
        </member>
        <member name="M:Neon.Temporal.LocalActivityOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.LocalActivityOptions.ScheduleToCloseTimeout">
            <summary>
            Optionally specifies the maximum time the activity can run.
            </summary>
        </member>
        <member name="P:Neon.Temporal.LocalActivityOptions.RetryPolicy">
            <summary>
            The activity retry options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.LocalActivityOptions.Clone">
            <summary>
            Returns a shallow copy of the instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Temporal.LocalActivityOptions"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.NamespaceConfig">
            <summary>
            Namespace configuration options.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceConfig.WorkflowExecutionRetentionTtl">
            <summary>
            The workflow history retention Ttl.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceConfig.BadBinaries">
            <summary>
            Set of Bad Binaries.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceConfig.HistoryArchivalState">
            <summary>
            Archival state of namespace history.  If unspecified then 
            default server configuration is used.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceConfig.HistoryArchivalUri">
            <summary>
            Uri of archived history.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceConfig.VisibilityArchivalState">
            <summary>
            Archival state of namespace visibility.  If unspecified then 
            default server configuration is used.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceConfig.VisibilityArchivalUri">
            <summary>
            Uri of archived namespace visibility.
            </summary>
        </member>
        <member name="T:Neon.Temporal.NamespaceDoc">
            <summary>
            This namespace defines the Neon .NET client for the Uber Temporal workflow service.
            </summary>
        </member>
        <member name="T:Neon.Temporal.NamespaceListPage">
            <summary>
            Holds a page of namespace information listed from Temporal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceListPage.Namespaces">
            <summary>
            Lists the namespace information.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceListPage.NextPageToken">
            <summary>
            Indicates that there's at least one more page of namespace information
            to be returned from Temporal when this is not <c>null</c>.  Otherwise,
            this is an opaque token that may be passed to <see cref="M:Neon.Temporal.TemporalClient.ListNamespacesAsync(System.Int32,System.Byte[])"/>
            to retrieve the next page of namespace information.
            </summary>
        </member>
        <member name="T:Neon.Temporal.NamespaceReplicationConfig">
            <summary>
            Defines configuration for namespace replication.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceReplicationConfig.ActiveClusterName">
            <summary>
            The string name of the active cluster.
            </summary>
        </member>
        <member name="P:Neon.Temporal.NamespaceReplicationConfig.Clusters">
            <summary>
            List of configurations for replication clusters.
            </summary>
        </member>
        <member name="T:Neon.Temporal.NonDeterministicPolicy">
            <summary>
            Enumerates how a decision task handler deals with mismatched history events 
            (presumably arising from non-deterministic workflow definitions). 
            </summary>
        </member>
        <member name="F:Neon.Temporal.NonDeterministicPolicy.BlockWorkflow">
            <summary>
            This policy logs an error to the console but does not reply to the server.  This is
            the default policy.
            </summary>
        </member>
        <member name="F:Neon.Temporal.NonDeterministicPolicy.FailWorkflow">
            <summary>
            This policy signals Temporal to fail the workflow.
            </summary>
        </member>
        <member name="T:Neon.Temporal.NonRetriableErrors">
            <summary>
            Used in conjunction with <see cref="T:Neon.Temporal.RetryPolicy"/> to specify errors that
            <b>will not</b> cause a workflow related operation to be retried.
            </summary>
        </member>
        <member name="M:Neon.Temporal.NonRetriableErrors.Custom(System.String)">
            <summary>
            Returns the non-retriable error string for a <b>custom error</b>.
            </summary>
            <param name="reason">The reason string.</param>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Temporal.NonRetriableErrors.Panic">
            <summary>
            Returns the non-retriable error string for a <b>panic error</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Temporal.NonRetriableErrors.Generic">
            <summary>
            Returns the non-retriable error string for a <b>generic error</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Temporal.NonRetriableErrors.StartToCloseTimeout">
            <summary>
            Returns the non-retriable error string for a <b>start-to-close timeout</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="M:Neon.Temporal.NonRetriableErrors.HeartbeatTimeout">
            <summary>
            Returns the non-retriable error string for a <b>heartbeat timeout</b>.
            </summary>
            <returns>The error string.</returns>
        </member>
        <member name="T:Neon.Temporal.ParentClosePolicy">
            <summary>
            Enumerates the possible child workflow behaviors when the parent
            workflow is closed.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ParentClosePolicy.Unspecified">
            <summary>
            Unspecified parent close policy.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ParentClosePolicy.Terminate">
            <summary>
            All open child workflows will be terminated when parent workflow is closed.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ParentClosePolicy.RequestCancel">
            <summary>
            Cancel requests will be sent to all open child workflows to all open child 
            workflows when parent workflow is closed.    This is the <b>default policy</b>.
            </summary>
        </member>
        <member name="F:Neon.Temporal.ParentClosePolicy.Abandon">
            <summary>
            Child workflow execution will continue unaffected when parent workflow is closed,
            essentially becoming orphaned.
            </summary>
        </member>
        <member name="T:Neon.Temporal.QueryMethodAttribute">
            <summary>
            Used to identify a workflow interface method as a query.
            </summary>
        </member>
        <member name="M:Neon.Temporal.QueryMethodAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Specifies the Temporal query type.</param>
        </member>
        <member name="P:Neon.Temporal.QueryMethodAttribute.Name">
            <summary>
            Returns the query name. 
            </summary>
        </member>
        <member name="T:Neon.Temporal.RetryPolicy">
            <summary>
            Describes a Temporal retry policy.
            </summary>
        </member>
        <member name="M:Neon.Temporal.RetryPolicy.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.RetryPolicy.#ctor(Neon.Retry.LinearRetryPolicy)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Retry.LinearRetryPolicy"/>.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="M:Neon.Temporal.RetryPolicy.#ctor(Neon.Retry.ExponentialRetryPolicy)">
            <summary>
            Constructs an instance from a <see cref="T:Neon.Retry.ExponentialRetryPolicy"/>,
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="P:Neon.Temporal.RetryPolicy.InitialInterval">
            <summary>
            Specifies the backoff interval for the first retry.  If coefficient is 1.0 then
            it is used for all retries.  Required, no default value.
            </summary>
        </member>
        <member name="P:Neon.Temporal.RetryPolicy.BackoffCoefficient">
            <summary>
            Specifies the coefficient used to calculate the next retry backoff interval.  
            The next retry interval is previous interval multiplied by this coefficient. 
            This must be 1 or larger. Default is 2.0.
            </summary>
        </member>
        <member name="P:Neon.Temporal.RetryPolicy.MaximumInterval">
            <summary>
            Specifies the maximim retry interval.  Retries intervals will start at <see cref="P:Neon.Temporal.RetryPolicy.InitialInterval"/>
            and then be multiplied by <see cref="P:Neon.Temporal.RetryPolicy.BackoffCoefficient"/> for each retry attempt until the
            interval reaches or exceeds <see cref="P:Neon.Temporal.RetryPolicy.MaximumInterval"/>, at which point point each
            retry will use <see cref="P:Neon.Temporal.RetryPolicy.MaximumInterval"/> for all subsequent attempts.
            </summary>
        </member>
        <member name="P:Neon.Temporal.RetryPolicy.ExpirationInterval">
            <summary>
            Maximum time to retry.  Either <see cref="P:Neon.Temporal.RetryPolicy.ExpirationInterval"/> or <see cref="P:Neon.Temporal.RetryPolicy.MaximumAttempts"/> is 
            required.  Retries will stop when this is exceeded even if maximum retries is not been reached.
            </summary>
        </member>
        <member name="P:Neon.Temporal.RetryPolicy.MaximumAttempts">
            <summary>
            Maximum number of attempts.  When exceeded the retries stop.  If not set or set to 0, it means 
            unlimited, and the policy will rely on <see cref="P:Neon.Temporal.RetryPolicy.ExpirationInterval"/> to decide when to stop
            retrying.  Either <see cref="P:Neon.Temporal.RetryPolicy.MaximumAttempts"/> or <see cref="P:Neon.Temporal.RetryPolicy.MaximumInterval"/>"/> is required.
            </summary>
        </member>
        <member name="P:Neon.Temporal.RetryPolicy.NonRetriableErrors">
            <summary>
            <para>
            Specifies Temporal errors that <b>should not</b> trigger a retry. This is optional.  Temporal server 
            will stop retrying if error reason matches this list.  Use the <see cref="T:Neon.Temporal.NonRetriableErrors"/>
            class methods to initialize this list as required.
            </para>
            <note>
            Cancellation is not a failure, so that won't be retried.
            </note>
            </summary>
            <remarks>
            <para>
            You can specify non-retryable error reasons directly here or use the <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry(System.String)"/> method
            to append a specific reason string or <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry``1"/> to specify the error reason for an
            exception type.
            </para>
            <para>
            We recommend that you use <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry``1"/> most of the time and reserve
            <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry(System.String)"/> for interop situations where you need to integrate 
            with something written in another language.
            </para>
            <para>
            For native Temporal exceptions like <see cref="T:Neon.Temporal.TemporalTimeoutException"/>, <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry``1"/> is smart
            enough to append the proper error reason.  For other exception types, this method will use the fully qualified
            exception type name as the reason.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.RetryPolicy.DoNotRetry``1">
            <summary>
            <para>
            Appends the error reason corresponding to an exception type.  For built-in Temporal exceptions, this
            will append the apporpriate reason string and for other exception type, this will append the fully
            qualified exception type name.
            </para>
            <note>
            We generally recommend that you use <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry``1"/> by default and
            reserve this for situations where you need to specify a specific reason, probably for interoperating
            with workflows and activities written in other lanagues, etc.
            </note>
            </summary>
            <typeparam name="ExceptionType">The exception type.</typeparam>
        </member>
        <member name="M:Neon.Temporal.RetryPolicy.DoNotRetry(System.String)">
            <summary>
            <para>
            Appends the string passed to <see cref="P:Neon.Temporal.RetryPolicy.NonRetriableErrors"/> as a reason not to be retried.
            </para>
            <note>
            We generally recommend that you use <see cref="M:Neon.Temporal.RetryPolicy.DoNotRetry``1"/> by default and
            reserve this for situations where you need to specify a specific reason, probably for interoperating
            with workflows and activities written in other lanagues, etc.
            </note>
            </summary>
            <param name="reason">The reason string.</param>
        </member>
        <member name="T:Neon.Temporal.SignalMethodAttribute">
            <summary>
            Used to identify a workflow interface methods as a signal.
            </summary>
        </member>
        <member name="M:Neon.Temporal.SignalMethodAttribute.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Specifies the Temporal signal name.</param>
        </member>
        <member name="P:Neon.Temporal.SignalMethodAttribute.Name">
            <summary>
            Returns the signal name. 
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalMethodAttribute.Synchronous">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Indicates whether the tagged signal method should be generated 
            as a synchronous method rather than as a fire-and-forget asynchronous call, which is
            the Temporal default.  This property defaults to <c>false</c>.
            </para>
            <note>
            Synchronous signals are considered experimental which means that this feature will 
            probably have a limited lifespan.  Temporal will introduce new <b>update</b>
            semantics at some point that will ultimately obsolete synchronous signals.
            </note>
            </summary>
            <remarks>
            <para>
            Normal Temporal signals are sent to workflows asynchronously.  This means that the
            signal method being called by the application will return ragardless of whether the
            workflow has actually received and processed the signal or not.  This is quite
            efficient and has the advantage of not requring the sending application to wait
            for a somewhat indeterminate period of time for the workflow to receive and process
            the signal.
            </para>
            <para>
            Sometimes though, you calling applications really need to know that the workflow
            actually handled a signal before moving on.  Applications may also need information
            back from the workflow, such as whether the workflow was able to process the signal
            request sucessfully.  So it would be nice if workflow signals could also return a
            result.
            </para>
            <para>
            The Neon Temporal client supports synchronous signals by setting this property to
            <c>true</c>.  When you do this, the Temporal client allows the signal method to
            return a result as a <see cref="T:System.Threading.Tasks.Task`1"/> as well returning just a simple
            <see cref="T:System.Threading.Tasks.Task"/>.  For both cases, the Temporal client will generate a signal
            stub that waits for the signal to be processed by the target workflow before
            returning.
            </para>
            <para>
            This is an experimental feature.  Temporal server doesn't currently have a 
            synchronous way to interact with a running workflow, so the Neon Temporal client emulates
            this behavior using a combination of internal signals and queries.  As a developer, 
            you couild have done something like this yourself, but we felt this was going to be 
            such a useful  pattern that it was worth building into the client.  This will ultimately
            be replaced by upcoming Temporal server features.
            </para>
            <para>
            See the documentation site for more information: <a href="https://doc.neonkube.com/Neon.Temporal-Workflow-SyncSignals.htm">Synchronous Signals</a>
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.SignalRequest">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Used to relay a received synchronous signal's 
            arguments to the workflow logic via a <see cref="T:Neon.Temporal.WorkflowQueue`1"/> allowing
            the workflow handle the signal by executing activities, child workflows, etc.
            This class also provides a way for the workflow to specify the signal reply. 
            </para>
            <para>
            This non-generic version of the class is intended for signals that return <c>void</c>.
            Use <see cref="T:Neon.Temporal.SignalRequest`1"/> for signals that return a result.
            </para>
            <note>
            This synchronous signals are considered experimental which means that this feature will 
            probably have a limited lifespan.  Temporal will introduce new <b>update</b>
            semantics at some point that will ultimately obsolete synchronous signals.
            </note>
            </summary>
            <remarks>
            <para>
            The <see cref="P:Neon.Temporal.SignalRequest.Args"/> property returns a dictionary that is intialized with the
            signal arguments keyed by parameter name.  Your signal method should queue this
            request to a workflow queue your workflow logic is listening on and then return
            from your signal method.
            </para>
            <para>
            Your workflow logic will dequeue the signal request, extract the signal arguments 
            cast them to the appropriate types, and then perform any necessary operations.
            Then call <see cref="M:Neon.Temporal.SignalRequest.ReplyAsync"/> which indicates that signal processing
            is finished.
            </para>
            <para>
            See the documentation site for more information: <a href="https://doc.neonkube.com/Neon.Temporal-Workflow-SynchronousSignals.htm">Synchronous Signals</a>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.SignalRequest.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalRequest.SignalId">
            <summary>
            Uniquely identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalRequest.SignalStatus">
            <summary>
            Returns the signal status for this signal request.
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalRequest.Args">
            <summary>
            Returns the dictionary holding the signal arguments keyed by parameter name.  You can
            access the arguments here, casting the <see cref="T:System.Object"/> values as required or
            you can use the generic <see cref="M:Neon.Temporal.SignalRequest.Arg``1(System.String)"/> method, which is a bit nicer.
            </summary>
        </member>
        <member name="M:Neon.Temporal.SignalRequest.Arg``1(System.String)">
            <summary>
            Returns the named argument cast into the specified type.
            </summary>
            <typeparam name="T">The argument type.</typeparam>
            <param name="name">The argument name.</param>
            <returns>The argument value cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.SignalRequest.ReplyAsync">
            <summary>
            Called by your workflow logic to indicate that processing for the synchronous
            signal is complete.  This method also waits for a period of time before
            returning to help ensure that the signal result can be delivered back to
            the calling client before the workflow terminates.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.SignalRequest`1">
            <summary>
            <para>
            <b>EXPERIMENTAL:</b> Used to relay a received synchronous signal's 
            arguments to the workflow logic via a <see cref="T:Neon.Temporal.WorkflowQueue`1"/> allowing
            the workflow handle the signal by executing activities, child workflows, etc.
            This class also provides a way for the workflow to specify the signal reply. 
            </para>
            <para>
            This generic version of the class is intended for signals that return results.
            Use <see cref="T:Neon.Temporal.SignalRequest"/> for signals that return <c>void</c>.
            </para>
            <note>
            This synchronous signals are considered experimental which means that this feature will 
            probably have a limited lifespan.  Temporal will introduce new <b>update</b>
            semantics at some point that will ultimately obsolete synchronous signals.
            </note>
            </summary>
            <typeparam name="TResult">The signal result type.</typeparam>
            <remarks>
            <para>
            The <see cref="P:Neon.Temporal.SignalRequest`1.Args"/> property returns a dictionary that is intialized with the
            signal arguments keyed by parameter name.  Your signal method should queue this
            request to a workflow queue your workflow logic is listening on and then return
            from the signal method.  The value your return will be ignore in this case and
            the actual value returned to the calling client will be specified by your workflow
            logic via a <see cref="M:Neon.Temporal.SignalRequest`1.ReplyAsync(`0)"/> call.
            </para>
            <para>
            Your workflow logic will dequeue the signal request, extract the signal arguments,
            casting them to the appropriate types, and then perform any necessary operations
            before calling <see cref="M:Neon.Temporal.SignalRequest`1.ReplyAsync(`0)"/> which indicates that signal processing
            is finished was well as specifying the value to be returned as the signal result.
            </para>
            <para>
            See the documentation site for more information: <a href="https://doc.neonkube.com/Neon.Temporal-Workflow-SynchronousSignals.htm">Synchronous Signals</a>
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.SignalRequest`1.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalRequest`1.SignalId">
            <summary>
            Uniquely identifies the signal.
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalRequest`1.SignalStatus">
            <summary>
            Returns the signal status for this signal request.
            </summary>
        </member>
        <member name="P:Neon.Temporal.SignalRequest`1.Args">
            <summary>
            Returns the dictionary holding the signal arguments keyed by parameter name.  You can
            access the arguments here, casting the <see cref="T:System.Object"/> values as required or
            you can use the generic <see cref="M:Neon.Temporal.SignalRequest`1.Arg``1(System.String)"/> method, which is a bit nicer.
            </summary>
        </member>
        <member name="M:Neon.Temporal.SignalRequest`1.Arg``1(System.String)">
            <summary>
            Returns the named argument cast into the specified type.
            </summary>
            <typeparam name="T">The argument type.</typeparam>
            <param name="name">The argument name.</param>
            <returns>The argument value cast to <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.SignalRequest`1.ReplyAsync(`0)">
            <summary>
            Called by your workflow logic to indicate that processing for the synchronous
            signal is complete as well as specifying the signal result.
            </summary>
            <param name="result">The value to be returned by the signal.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.StartWorkflowOptions">
            <summary>
            Specifies the options to use when starting a workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.StartWorkflowOptions.Normalize(Neon.Temporal.TemporalClient,Neon.Temporal.StartWorkflowOptions,System.Type,System.Reflection.MethodInfo)">
            <summary>
            Normalizes the options passed by creating or cloning a new instance as 
            required and filling unset properties using default client settings.
            </summary>
            <param name="client">The associated Temporal client.</param>
            <param name="options">The input options or <c>null</c>.</param>
            <param name="workflowInterface">Optionally specifies the workflow interface definition.</param>
            /// <param name="method">Optionally specifies the target workflow method.</param>
            <returns>The normalized options.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if a valid task queue is not specified.</exception>
        </member>
        <member name="M:Neon.Temporal.StartWorkflowOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.Id">
            <summary>
            Optionally specifies the business ID for a workflow.  This defaults
            to a generated UUID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.Namespace">
            <summary>
            Optionally specifies the target Temporal namespace.  This defaults to the namespace
            specified by <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Namespace"/>, 
            <see cref="P:Neon.Temporal.WorkflowInterfaceAttribute.Namespace"/>, or 
            to the client's <see cref="T:Neon.Temporal.TemporalSettings"/>, in that 
            order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.TaskQueue">
            <summary>
            Optionally specifies the target Temporal task queue.  This defaults to the task queue
            specified by <see cref="P:Neon.Temporal.WorkflowMethodAttribute.TaskQueue"/> or
            <see cref="P:Neon.Temporal.WorkflowInterfaceAttribute.TaskQueue"/>or 
            to the client's <see cref="T:Neon.Temporal.TemporalSettings"/>, in that 
            order of precedence.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.WorkflowRunTimeout">
            <summary>
            Optionally specifies The timeout for duration of a single workflow run.
            The resolution is seconds.  This defaults to <see cref="P:Neon.Temporal.StartWorkflowOptions.WorkflowExecutionTimeout"/>
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.WorkflowExecutionTimeout">
            <summary>
            <para>
            Optionally specifies the maximum time the workflow may execute from start to finish.
            This defaults to 24 hours.
            </para>
            <note>
            This overrides the optional corresponding value specified in the
            <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> tagging the workflow entry 
            point method.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.WorkflowTaskTimeout">
            <summary>
            Optionally specifies the timeout for processing decision task from the time the worker
            pulled a task.  If a decision task is not completed within this interval, it will be retried 
            as specified by the retry policy.   This defaults to <b>10 seconds</b> when not specified.
            The maximum timeout is <b>60 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.WorkflowIdReusePolicy">
            <summary>
            Optionally determines how Temporal handles workflows that attempt to reuse workflow IDs.
            This generally defaults to <see cref="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicate"/>
            but the default can be customized via the <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> tagging
            the workflow entry point method or <see cref="P:Neon.Temporal.TemporalSettings.WorkflowIdReusePolicy"/>
            (which also defaults to <see cref="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicate"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.RetryPolicy">
            <summary>
            Optional retry policy for the workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.CronSchedule">
            <summary>
            Optionally specifies a recurring schedule for the workflow.  This can be set to a string specifying
            the minute, hour, day of month, month, and day of week scheduling parameters using the standard Linux
            CRON format described here: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>
            </summary>
            <remarks>
            <para>
            Temporal accepts a CRON string formatted as a single line of text with 5 parameters separated by
            spaces.  The parameters specified the minute, hour, day of month, month, and day of week values:
            </para>
            <code>
             minute (0 - 59)
              hour (0 - 23)
               day of the month (1 - 31)
                month (1 - 12)
                 day of the week (0 - 6) (Sunday to Saturday)
                
                
            * * * * * 
            </code>
            <para>
            Each parameter may be set to one of:
            </para>
            <list type="table">
            <item>
                <term><b>*</b></term>
                <description>
                Matches any value.
                </description>
            </item>
            <item>
                <term><b>value</b></term>
                <description>
                Matches a specific integer value.
                </description>
            </item>
            <item>
                <term><b>value1-value2</b></term>
                <description>
                Matches a range of values to be matched (inclusive).
                </description>
            </item>
            <item>
                <term><b>value1,value2,...</b></term>
                <description>
                Matches a list of values to be matched.
                </description>
            </item>
            <item>
                <term><b>value1/value2</b></term>
                <description>
                Matches values starting at <b>value1</b> and then those incremented by <b>value2</b>.
                </description>
            </item>
            </list>
            <para>
            You can use this handy CRON calculator to see how this works: <a href="https://crontab.guru">https://crontab.guru</a>
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Temporal.StartWorkflowOptions.Memo">
            <summary>
            <para>
            Optionally specifies workflow metadata as a dictionary of named object values.
            </para>
            <note>
            The object values will be serialized into bytes using the the client's
            <see cref="T:Neon.Temporal.IDataConverter"/>.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Temporal.StartWorkflowOptions.Clone">
            <summary>
            Returns a shallow clone of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Temporal.StartWorkflowOptions"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.TaskIdBlock">
            <summary>
            Defines a temporal task Id block
            </summary>
        </member>
        <member name="P:Neon.Temporal.TaskIdBlock.StartId">
            <summary>
            The long start id of the block.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TaskIdBlock.EndId">
            <summary>
            The long end id of the block.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TaskQueueKind">
            <summary>
            Enumerates the different kinds of task lists.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TaskQueueKind.Unspecified">
            <summary>
            Unspecified.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TaskQueueKind.Normal">
            <summary>
            Normal.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TaskQueueKind.Sticky">
            <summary>
            Sticky.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TaskQueueType">
            <summary>
            Used to distinguish between decision (AKA workflow) and activity task lists.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TaskQueueType.Unspecified">
            <summary>
            Identifies and unspecified task queue.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TaskQueueType.Workflow">
            <summary>
            Identifies decision (AKA workflow) task lists.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TaskQueueType.Activity">
            <summary>
            Identifies activity task lists.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TemporalClient">
            <summary>
            Implements a client that will be connected to a Temporal cluster and be used
            to create and manage workflows.
            </summary>
            <remarks>
            <para>
            To get started with Temporal, you'll need to deploy a Temporal cluster with
            one or more nodes and the establish a connection to the cluster from your
            workflow/activity implementations and management tools.  This is pretty
            easy to do.
            </para>
            <para>
            Temporal clusters interacts with client APIs via gRPC on <b>port 7233</b> (by default).
            Server nodes are typically configured behind a TCP load balancer or a DNS
            name is configured such that it returns the IP addresses for each server
            node.  The <see cref="P:Neon.Temporal.TemporalSettings.HostPort"/> property is used to 
            specify how to connect to the cluster.  For single node clusters or clusters
            behind a load balancer, you'll typically specify <b>HOST:7233</b> where
            <b>HOST</b> is the DNS name or IP address for the node.
            </para>
            <para>
            Alternatively, if you've configured DNS to return IP addresses for each cluster node,
            you can specify <b>dns:///host:port</b>.  In this case, the client will 
            round-robin between the node addresses returned to locate healthy nodes
            to communicate with.
            </para>
            <para>
            To establish a connection, you'll construct a <see cref="T:Neon.Temporal.TemporalSettings"/>
            and add your cluster endpoint to the <see cref="P:Neon.Temporal.TemporalSettings.HostPort"/>
            and then call the static <see cref="M:Neon.Temporal.TemporalClient.ConnectAsync(Neon.Temporal.TemporalSettings)"/>
            method to obtain a connected <see cref="T:Neon.Temporal.TemporalClient"/>.  You'll use this
            for registering workflows and activities types as well as the workers that
            indicate that workflows and activities can be executed in the current process.
            </para>
            <note>
            <b>IMPORTANT:</b> The current .NET Temporal client release supports having only
            one client open at a time.  A <see cref="T:System.NotSupportedException"/> will be thrown
            when attempting to connect a second client.  This restriction may be relaxed
            for future releases.
            </note>
            <para>
            You'll implement your workflows and activities by implementing classes that
            derive from <see cref="T:Neon.Temporal.WorkflowBase"/> and <see cref="T:Neon.Temporal.ActivityBase"/> and then
            registering these types with Temporal.  Then you'll start workflow or activity
            workers so that Temporal will begin scheduling operations for execution by your code.
            Workflows and activities are registered using the fully qualified names 
            of the derived <see cref="T:Neon.Temporal.WorkflowBase"/> and <see cref="T:Neon.Temporal.ActivityBase"/> types
            by defaut, but you can customize this if desired.
            </para>
            <para>
            Temporal supports the concept of <b>namespaces</b> and task lists.  Temporal is multi-tenant and
            namespaces are simply string names used to isolate deployments.  For example, you could
            define a <b>PROD</b> namespace for your production workflows and <b>STAGE</b> for preproduction.
            It's also often useful to organize namespaces by the teams implementing and managing their
            workflows.  Each <see cref="T:Neon.Temporal.TemporalClient"/> is assigned to a default namespace via
            <see cref="P:Neon.Temporal.TemporalSettings.Namespace"/> and this defaults to <b>"default"</b> unless you
            specify something different when connecting the client.
            </para>
            <note>
            You can override the default client namespace for specific operations via <see cref="T:Neon.Temporal.WorkerOptions"/>,
            <see cref="T:Neon.Temporal.StartWorkflowOptions"/>, <see cref="T:Neon.Temporal.ChildWorkflowOptions"/>, <see cref="T:Neon.Temporal.ActivityOptions"/> as
            well as via the <see cref="T:Neon.Temporal.WorkflowInterfaceAttribute"/>, <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>,
            <see cref="T:Neon.Temporal.ActivityInterfaceAttribute"/> and <see cref="T:Neon.Temporal.ActivityMethodAttribute"/> attributes
            decorating your workflow and activity interface definitions.
            </note>
            <para>
            Once you have a connected <see cref="T:Neon.Temporal.TemporalClient"/>, you can create and manage Temporal namespaces
            via methods like <see cref="M:Neon.Temporal.TemporalClient.RegisterNamespaceAsync(System.String,System.String,System.String,System.Int32,System.Boolean)"/>,
            <see cref="M:Neon.Temporal.TemporalClient.DescribeNamespaceAsync(System.String)"/>, and <see cref="M:Neon.Temporal.TemporalClient.UpdateNamespaceAsync(System.String,Neon.Temporal.UpdateNamespaceRequest)"/>.
            </para>
            <para>
            Workflows and activities are implemented by creating a <see cref="T:Neon.Temporal.Worker"/> via 
            <see cref="M:Neon.Temporal.TemporalClient.NewWorkerAsync(System.String,System.String,Neon.Temporal.WorkerOptions)"/>, registering your workflow and 
            activity implementations with the worker and then starting the worker via <see cref="M:Neon.Temporal.Worker.StartAsync"/>.  
            Temporal will begin scheduling pending workflows and activities on workers after they've been started.
            </para>
            <para>
            The <see cref="T:Neon.Temporal.Worker"/> class provides methods for registering individual workflow and
            activity implementations, including <see cref="M:Neon.Temporal.Worker.RegisterWorkflowAsync``1(System.Boolean)"/> 
            and <see cref="M:Neon.Temporal.Worker.RegisterActivityAsync``1(System.Boolean)"/> as well as methods
            that register all workflow and activity implementation discovered in an assembly:
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.Boolean)"/>,
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.Boolean)"/>, and
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyAsync(System.Reflection.Assembly,System.Boolean)"/> (which registers
            both workflow and assembly implementations).
            </para>
            <para>
            Workflows are implemented by defining an interface describing the workflow methods
            and then writing a class the implements your interface and also inherits <see cref="T:Neon.Temporal.WorkflowBase"/>.  
            Your workflow interface  must define at least one entry point method tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> and
            may optionally include signal and query methods  tagged by <see cref="T:Neon.Temporal.SignalMethodAttribute"/> 
            and <see cref="T:Neon.Temporal.QueryMethodAttribute"/>.
            </para>
            <para>
            Activities are implemented in the same way by defining an activity interface and then writing a class
            that implements this  interface. and inherits <see cref="T:Neon.Temporal.ActivityBase"/>.  Your activity interface
            must define at least one entry point method.
            </para>
            <para>
            You'll generally create stub classes to start and manage workflows and activities.
            These come in various flavors with the most important being typed and untyped stubs.
            Typed stubs are nice because they implement your workflow or activity interface so
            that the C# compiler can provide compile-time type checking.  Untyped stubs provide
            a way to interact with workflows and activities written on other languages or for
            which you don't have source code.
            </para>
            <para>
            You can create typed external workflow stubs via <see cref="M:Neon.Temporal.TemporalClient.NewWorkflowStub``1(System.String,System.String,System.String)"/>
            and <see cref="M:Neon.Temporal.TemporalClient.NewWorkflowStub``1(Neon.Temporal.StartWorkflowOptions,System.String)"/>.
            </para>
            <para>
            Workflows can use their <see cref="T:Neon.Temporal.Workflow"/> property to create child workflow as
            well as activity stubs.
            </para>
            <para><b>Task Lists</b></para>
            <para>
            Task lists are used by Temporal to identify the set of workflows and activities that
            are implemented by workers.  For example, if you deploy a program called <b>payments.exe</b>
            that implements payment related workflows and activities like <b>validate</b>,
            <b>debit</b>, <b>credit</b>,... you could register these and then start a worker using
            <b>taskqueue=payments</b>.
            </para>
            <para>
            You'll need to provide the correct task queue when executing a workflow or normal (non-local)
            activity.  Temporal will schedule the workflow or activity on one of the workers that
            was started with the specified task queue.  The most convienent way to specify the task queue
            is to tag your workflow and activity interfaces with <c>[WorkflowInterface(TaskQueue = "payments")]</c>
            and <c>[ActivityInterface(TaskQueue = "payments")]</c> attributes, specifying the target task queue.
            </para>
            <note>
            You may specify a default task queue when connecting a <see cref="T:Neon.Temporal.TemporalClient"/> via
            <see cref="P:Neon.Temporal.TemporalSettings.TaskQueue"/> (which defaults to <c>null</c>).  This may
            be convienent for simple deployments.
            </note>
            <para>
            You may also specify a custom task queue in the workflow and activity options used when
            executing a workflow or activity.  A task queue specified in one of these options takes
            precedence over the task queue specified in an attribute.
            </para>
            <note>
            The .NET client will complain if a task queue is not specified in either an interface
            attribute via options and the there's no client default task queue set.
            </note>
            <note>
            <para>
            <b>IMPORTANT:</b> You need to take care to ensure that the task lists you use for your
            workers uniquely identify the set of workflows and activities implemented by your the workers.
            For example, if you start two workers, <b>worker-a</b> and <b>worker-b</b> using the same
            task queue, but <b>worker-a</b> registers the <b>foo</b> workflow and <b>worker-b</b>
            registers the <c>bar</c> activity, you're going run into trouble.
            </para>
            <para>
            The problem is that Cadence assumes that both workers implement the same workflows, both
            <b>foo</b> and <b>bar</b> in this case.  Say you start a <b>foo</b> workflow.  Temporal
            will select one of <b>worker-a</b> or <b>worker-b</b> to run the workflow.  If Temporal
            happens to select <b>worker-a</b> everything will work as expected because <b>foo</b>
            is registered there.  If Temporal selects <b>worker-b</b> the initial execution will fail
            because <b>foo</b> is not registered there.  Temporal handles this a decision task failure
            and will attempt to reschedule the workflow on another worker (hopefully <b>worker-a</b>
            this time).
            </para>
            <para>
            Temporal fault tolerance will probably end up being able to handle this sort misconfiguration,
            but at the cost of additional delays as well as unnecessary communication overhead to workers
            that will never be able to execute unregistered workflows and activities.
            </para>
            <para>
            So the moral of this store is carefully choose your task lists to match the set of workflows
            and activities implemented by your application.  One common approach is to name the task queue
            after the service or application that implements the workflow anbd activities.
            </para>
            </note>
            <note>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  This takes 
            about 500ms for each stub.  This generally works fine but may cause decision task timeouts 
            for workflows that call a lot of different child workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Temporal.TemporalClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Temporal.TemporalClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Temporal.TemporalClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </note>
            </remarks>
        </member>
        <member name="E:Neon.Temporal.TemporalClient.ActivityExecuteEvent">
            <summary>
            Raised when a normal (non-local) is executed.  This is used internally
            for unit tests that verify that activity options are configured correctly. 
            </summary>
        </member>
        <member name="E:Neon.Temporal.TemporalClient.LocalActivityExecuteEvent">
            <summary>
            Raised when a local is executed.  This is used internally for unit tests 
            that verify that activity options are configured correctly. 
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RaiseActivityExecuteEvent(Neon.Temporal.ActivityOptions)">
            <summary>
            Raises the <see cref="E:Neon.Temporal.TemporalClient.ActivityExecuteEvent"/>.
            </summary>
            <param name="options">The activity options.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RaiseLocalActivityExecuteEvent(Neon.Temporal.LocalActivityOptions)">
            <summary>
            Raises the <see cref="E:Neon.Temporal.TemporalClient.LocalActivityExecuteEvent"/>.
            </summary>
            <param name="options">The activity options.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ActivityHeartbeatByTokenAsync(System.String,System.Object,System.String)">
            <summary>
            Used to record an activity heartbeat externally by task token.
            </summary>
            <param name="taskToken">The opaque base-64 encoded activity task token.</param>
            <param name="details">Optional heartbeart details.</param>
            <param name="namespace">Optionally overrides the default <see cref="T:Neon.Temporal.TemporalClient"/> namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ActivityHeartbeatByIdAsync(Neon.Temporal.WorkflowExecution,System.String,System.Object,System.String)">
            <summary>
            Used to record an activity heartbeat externally by <see cref="T:Neon.Temporal.WorkflowExecution"/> and activity ID.
            </summary>
            <param name="execution">The workflow execution.</param>
            <param name="activityId">The activity ID.</param>
            <param name="details">Optional heartbeart details.</param>
            <param name="namespace">Optionally overrides the default <see cref="T:Neon.Temporal.TemporalClient"/> namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ActivityCompleteByTokenAsync(System.String,System.Object,System.String)">
            <summary>
            Used to externally complete an activity identified by task token.
            </summary>
            <param name="taskToken">The opaque base-64 encoded activity task token.</param>
            <param name="namespace">Optionally overrides the default <see cref="T:Neon.Temporal.TemporalClient"/> namespace.</param>
            <param name="result">Passed as the activity result for activity success.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ActivityCompleteByIdAsync(Neon.Temporal.WorkflowExecution,System.String,System.Object,System.String)">
            <summary>
            Used to externally complete an activity identified by <see cref="T:Neon.Temporal.WorkflowExecution"/> and activity ID.
            </summary>
            <param name="execution">The workflow execution.</param>
            <param name="activityId">The activity ID.</param>
            <param name="result">Passed as the activity result for activity success.</param>
            <param name="namespace">Optionally overrides the default <see cref="T:Neon.Temporal.TemporalClient"/> namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ActivityErrorByTokenAsync(System.String,System.Exception,System.String)">
            <summary>
            Used to externally fail an activity by task token.
            </summary>
            <param name="taskToken">The opaque base-64 encoded activity task token.</param>
            <param name="error">Specifies the activity error.</param>
            <param name="namespace">Optionally overrides the default <see cref="T:Neon.Temporal.TemporalClient"/> namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ActivityErrorByIdAsync(Neon.Temporal.WorkflowExecution,System.String,System.Exception,System.String)">
            <summary>
            Used to externally fail an activity by <see cref="T:Neon.Temporal.WorkflowExecution"/> and activity ID.
            </summary>
            <param name="execution">The workflowm execution.</param>
            <param name="activityId">The activity ID.</param>
            <param name="error">Specifies the activity error.</param>
            <param name="namespace">Optionally overrides the default <see cref="T:Neon.Temporal.TemporalClient"/> namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the activity no longer exists.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.PingAsync">
            <summary>
            Pings the <b>temporal-proxy</b> and waits for the reply.  This is used 
            mainly for low-level performance and load testing but can also be used
            to explicitly verify that the <b>temporal-proxy</b> is still alive.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewWorkerAsync(System.String,System.String,Neon.Temporal.WorkerOptions)">
            <summary>
            Creates a new Temporal <see cref="T:Neon.Temporal.Worker"/> attached to the current client.  You'll
            use this to register your workflow and/or activity implementations with Temporal and
            the start the worker to signal Temporal that the worker is ready for business.
            </summary>
            <param name="namespace">Optionally specifies namespace for worker.  Defaults
            to namespace set in <see cref="P:Neon.Temporal.TemporalClient.Settings"/>.</param>
            <param name="taskQueue">Optionally specifies task queue for worker.  Defaults
            to task queue set in <see cref="P:Neon.Temporal.TemporalClient.Settings"/>.</param>
            <param name="options">Optionally specifies additional worker options.</param>
            <returns>A <see cref="T:Neon.Temporal.Worker"/> identifying the worker instance.</returns>
            <remarks>
            <para>
            Each worker instance will be responsible for actually executing Temporal workflows and
            activities.  Workers are registered within a Temporal namespace and are assigned to a
            task queue which identifies the virtual queue Temporal uses to schedule work on workers.
            Workers implementing the same workflows and activities will generally be assigned to
            the same task queue (which is just an identifying string).
            </para>
            <para>
            After you have a new worker, you'll need to register workflow and/or activity implementations
            via <see cref="M:Neon.Temporal.Worker.RegisterActivityAsync``1(System.Boolean)"/>,
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.Boolean)"/>,
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyAsync(System.Reflection.Assembly,System.Boolean)"/>, or
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.Boolean)"/>.
            </para>
            <para>
            Then after completing the registrations, you'll call <see cref="M:Neon.Temporal.Worker.StartAsync"/>
            to start the worker, signalling to Temporal that the worker is ready to execute
            workflows and activities.
            </para>
            <para>
            You may call <see cref="M:Neon.Temporal.Worker.Dispose"/> to explicitly stop a worker or just
            dispose the <see cref="T:Neon.Temporal.TemporalClient"/> which automatically disposes any
            related workers.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.DescribeQueueListAsync(System.String,Neon.Temporal.TaskQueueType,System.String)">
            <summary>
            Returns information about pollers (AKA workers) that have communicated 
            with the Temporal cluster in the last few minutes.
            </summary>
            <param name="taskQueue">Identifies the task queue.</param>
            <param name="taskQueueType">
            Indicates whether to return information for decision (AKA workflow pollers)
            or activity pollers.
            </param>
            <param name="namespace">Optionally specifies the Temporal namespace.</param>
            <returns>The <see cref="T:Neon.Temporal.Internal.TaskQueueDescription"/> for the pollers.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.StartWorkerAsync(Neon.Temporal.Worker)">
            <summary>
            Signals Temporal to start a <see cref="T:Neon.Temporal.Worker"/> (returned by a previous call to
            <see cref="M:Neon.Temporal.TemporalClient.NewWorkerAsync(System.String,System.String,Neon.Temporal.WorkerOptions)"/>).
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            This method does nothing if the worker is already started.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.StopWorkerAsync(Neon.Temporal.Worker)">
            <summary>
            Signals Temporal that it should stop invoking activities and workflows 
            for the specified <see cref="T:Neon.Temporal.Worker"/> (returned by a previous call to
            <see cref="M:Neon.Temporal.TemporalClient.NewWorkerAsync(System.String,System.String,Neon.Temporal.WorkerOptions)"/>).
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            This method does nothing if the worker is already stopped.
            </remarks>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.debugProxyPort">
            <summary>
            The <b>temporal-proxy</b> listening port to use when <see cref="P:Neon.Temporal.TemporalSettings.DebugPrelaunched"/>
            mode is enabled.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.debugClientPort">
            <summary>
            The <b>temporal-client</b> listening port to use when <see cref="P:Neon.Temporal.TemporalSettings.DebugPrelaunched"/>
            mode is enabled.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.QueryStack">
            <summary>
            The signal name used to retrieve the current stack trace.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.QuerySyncSignal">
            <summary>
            The internal query name used to poll the state of a synchronous signals.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.SignalSync">
            <summary>
            The signal name used for synchronous signals.  Signals sent here will be
            handled internally by <see cref="T:Neon.Temporal.WorkflowBase"/> and forwarded on to the
            user's signal handler method.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TemporalClient.Operation">
            <summary>
            Used for tracking pending <b>temporal-proxy</b> operations.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Operation.#ctor(System.Int64,Neon.Temporal.Internal.ProxyRequest,System.TimeSpan)">
            <summary>
            Constructor.
            </summary>
            <param name="requestId">The unique request ID.</param>
            <param name="request">The request message.</param>
            <param name="timeout">
            Optionally specifies the timeout.  This defaults to the end of time.
            </param>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Operation.RequestId">
            <summary>
            The operation (aka the request) ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Operation.Request">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Operation.StartTime">
            <summary>
            The time the operation started.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Operation.Timeout">
            <summary>
            The operation timeout. 
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Operation.CompletionSource">
            <summary>
            Returns the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> that we'll use
            to signal completion when <see cref="M:Neon.Temporal.TemporalClient.Operation.SetReply(Neon.Temporal.Internal.ProxyReply)"/> is called
            with the reply message for this operation, <see cref="M:Neon.Temporal.TemporalClient.Operation.SetCanceled"/> when
            the operation has been canceled, or <see cref="M:Neon.Temporal.TemporalClient.Operation.SetException(System.Exception)"/>
            is called signalling an error.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Operation.SetReply(Neon.Temporal.Internal.ProxyReply)">
            <summary>
            Signals the awaiting <see cref="T:System.Threading.Tasks.Task"/> that a reply message 
            has been received.
            </summary>
            <param name="reply">The reply message.</param>
            <remarks>
            <note>
            Only the first call to <see cref="M:Neon.Temporal.TemporalClient.Operation.SetReply(Neon.Temporal.Internal.ProxyReply)"/>
            <see cref="M:Neon.Temporal.TemporalClient.Operation.SetException(System.Exception)"/>, or <see cref="M:Neon.Temporal.TemporalClient.Operation.SetCanceled"/>
            will actually wake the awaiting task.  Any subsequent calls will do nothing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Operation.SetCanceled">
            <summary>
            Signals the awaiting <see cref="T:System.Threading.Tasks.Task"/> that the operation has
            been canceled.
            </summary>
            <remarks>
            <note>
            Only the first call to <see cref="M:Neon.Temporal.TemporalClient.Operation.SetReply(Neon.Temporal.Internal.ProxyReply)"/>
            <see cref="M:Neon.Temporal.TemporalClient.Operation.SetException(System.Exception)"/>, or <see cref="M:Neon.Temporal.TemporalClient.Operation.SetCanceled"/>
            will actually wake the awaiting task.  Any subsequent calls will do nothing.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Operation.SetException(System.Exception)">
            <summary>
            Signals the awaiting <see cref="T:System.Threading.Tasks.Task"/> that it should fail
            with an exception.
            </summary>
            <param name="e">The exception.</param>
            <remarks>
            <note>
            Only the first call to <see cref="M:Neon.Temporal.TemporalClient.Operation.SetReply(Neon.Temporal.Internal.ProxyReply)"/>
            <see cref="M:Neon.Temporal.TemporalClient.Operation.SetException(System.Exception)"/>, or <see cref="M:Neon.Temporal.TemporalClient.Operation.SetCanceled"/>
            will actually wake the awaiting task.  Any subsequent calls will do nothing.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.TemporalClient.HttpReply">
            <summary>
            Used to specify the HTTP reply to be returned for a received HTTP request.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.HttpReply.StatusCode">
            <summary>
            The response HTTP status code.
            </summary>
        </member>
        <member name="F:Neon.Temporal.TemporalClient.HttpReply.Message">
            <summary>
            The response error message or <c>null</c>.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TemporalClient.HttpServer">
            <summary>
            Implements a simple integrated HTTP server that works for both .NET Core
            as well as .NET Framework, using Kestrel for .NET Core and WebListener
            for .NET Framework.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.HttpServer.ListenUri">
            <summary>
            Returns the URI where the server is listening.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.HttpServer.#ctor(System.Net.IPAddress,Neon.Temporal.TemporalSettings)">
            <summary>
            Constructor.
            </summary>
            <param name="address">The IP address where the service should listen.</param>
            <param name="settings">The Cadence settings.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.HttpServer.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Reset">
            <summary>
            Resets <see cref="T:Neon.Temporal.TemporalClient"/> to its initial state, by closing
            any existing connections and clearing any operation state.  This is
            called by the <b>TemporalFixture</b>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ExtractTemporalProxy(System.String)">
            <summary>
            <para>
            Writes the <b>temporal-proxy</b> binaries to the specified folder.  This is
            provided so that you can pre-provision the executable and then use the 
            <see cref="P:Neon.Temporal.TemporalSettings.BinaryPath"/> setting to reference it.
            These files will be written:
            </para>
            <list type="table">
            <item>
                <term><b>temporal-proxy.win.exe</b></term>
                <description>
                The Windows AMD64 executable
                </description>
            </item>
            <item>
                <term><b>temporal-proxy.linux</b></term>
                <description>
                The Linux AMD64 executable
                </description>
            </item>
            <item>
                <term><b>temporal-proxy.osx</b></term>
                <description>
                The OS/X AMD64 executable
                </description>
            </item>
            </list>
            <para>
            This is useful for situations where the executable must be pre-provisioned for
            security.  One example is deploying Temporal workers to a Docker container with
            a read-only file system.
            </para>
            </summary>
            <param name="folderPath">Path to the output folder.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.StartProxy(System.Net.IPEndPoint,Neon.Temporal.TemporalSettings,System.Int64)">
            <summary>
            <para>
            Writes the correct <b>temporal-proxy</b> binary for the current environment
            to the file system (if that hasn't been done already) and then launches 
            a proxy instance configured to listen at the specified endpoint.
            </para>
            <note>
            If <see cref="P:Neon.Temporal.TemporalSettings.BinaryPath"/> is not <c>null</c> or empty then
            we'll just execute that binary rather than trying to extract one.  We'll also
            assume that we already have execute permissions.
            </note>
            </summary>
            <param name="endpoint">The network endpoint where the proxy will listen.</param>
            <param name="settings">The Temporal connection settings.</param>
            <param name="clientId">The associated client ID.</param>
            <returns>The proxy <see cref="T:System.Diagnostics.Process"/>.</returns>
            <remarks>
            By default, this class will write the binary to the same directory where
            this assembly resides.  This should work for most circumstances.  On the
            odd change that the current application doesn't have write access to this
            directory, you may specify an alternative via <paramref name="settings"/>.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.GetClient(System.Int64)">
            <summary>
            Returns the client associated with a given ID.
            </summary>
            <param name="clientId">The client ID.</param>
            <returns>The <see cref="T:Neon.Temporal.TemporalClient"/> or <c>null</c> if the client doesn't exist.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ConnectAsync(Neon.Temporal.TemporalSettings)">
            <summary>
            Establishes a connection to a Temporal cluster.
            </summary>
            <param name="settings">The <see cref="T:Neon.Temporal.TemporalSettings"/>.</param>
            <returns>The connected <see cref="T:Neon.Temporal.TemporalClient"/>.</returns>
            <remarks>
            <note>
            The <see cref="T:Neon.Temporal.TemporalSettings"/> passed must specify a <see cref="P:Neon.Temporal.TemporalSettings.Namespace"/>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.OnListenerRequestAsync(Microsoft.Net.Http.Server.RequestContext)">
            <summary>
            Called when an HTTP request is received by the integrated WebListener
            (presumably sent by the associated <b>temporal-proxy</b> process).
            </summary>
            <param name="context">The request context.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.OnRootRequestAsync(Neon.Temporal.Internal.ProxyMessage)">
            <summary>
            Handles requests to the root <b>"/"</b> endpoint path.
            </summary>
            <param name="proxyMessage">The received message.</param>
            <returns>The HTTP reply information.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.BuildActivityStub``1">
            <summary>
            Prebuilds and caches the internal activity stub class backing the
            <typeparamref name="TActivity"/> interface.  Subsequent calls for the
            same activity interface can be made but actually do nothing.
            </summary>
            <typeparam name="TActivity">The target activity interface.</typeparam>
            <remarks>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  
            This takes  about 500ms for each stub.  This generally works fine but may cause 
            decision task timeouts for workflows that call a lot of different child
            workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Temporal.TemporalClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Temporal.TemporalClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Temporal.TemporalClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.BuildWorkflowStub``1">
            <summary>
            Prebuilds and caches the internal workflow stub class backing the
            <typeparamref name="TWorkflow"/> interface.  Subsequent calls for the
            same workflow interface can be made but actually do nothing.
            </summary>
            <typeparam name="TWorkflow">The target activity interface.</typeparam>
            <remarks>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  
            This takes  about 500ms for each stub.  This generally works fine but may cause 
            decision task timeouts for workflows that call a lot of different child
            workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Temporal.TemporalClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Temporal.TemporalClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Temporal.TemporalClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.BuildAssemblyStubs(System.Reflection.Assembly)">
            <summary>
            Scans the assembly passed for any workflow or activity interfaces and
            pebuilds and caches the generated internal backing classes.  Subsequent 
            calls for the same assembly can be made but actually do nothing.
            </summary>
            <param name="assembly">The target assembly.</param>
            <remarks>
            <para>
            Activity and workflow stubs are generated and compiled on demand by default.  
            This takes  about 500ms for each stub.  This generally works fine but may cause 
            decision task timeouts for workflows that call a lot of different child
            workflows or activities.
            </para>
            <para>
            The default workflow decision task timeout is 10 seconds, so a workflow
            that creates 22 stubs when its first called will have a decent chance
            of timing out due to the 500ms * 22 = 11 seconds it will take for the 
            .NET client generate and build the backing classes.
            </para>
            <note>
            This is only an issue the first time a stub classes are built, so it'll
            be very likely that the workflow will proceed the second time it's invoked
            on the same worker because the generated stub classes are cached.
            </note>
            <para>
            You can proactively address this by prebuilding stub classes before starting
            any workers by calling <see cref="M:Neon.Temporal.TemporalClient.BuildActivityStub``1"/>, 
            <see cref="M:Neon.Temporal.TemporalClient.BuildWorkflowStub``1"/>, and/or <see cref="M:Neon.Temporal.TemporalClient.BuildAssemblyStubs(System.Reflection.Assembly)"/>.
            After doing this, the specified stubs will already be generated and compiled
            when the worker starts and begins invoking workflows and activities.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.#ctor">
            <summary>
            Used for unit testing only.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.#ctor(Neon.Temporal.TemporalSettings)">
            <summary>
            Constructor.
            </summary>
            <param name="settings">The <see cref="T:Neon.Temporal.TemporalSettings"/>.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Finalize">
            <summary>
            Finalizer.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Address">
            <summary>
            Returns the IP address to be used for binding the network interface for both
            the local web server as well as that for <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.ClientId">
            <summary>
            Returns the locally unique ID for the client instance.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.Settings">
            <summary>
            Returns the settings used to create the client.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.ListenUri">
            <summary>
            Returns the URI the client is listening on for requests from the <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.ProxyUri">
            <summary>
            Returns the URI the associated <b>temporal-proxy</b> instance is listening on.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.DataConverter">
            <summary>
            <para>
            Specifies the <see cref="T:Neon.Temporal.IDataConverter"/> used for workflows and activities managed by the client.
            This defaults to <see cref="T:Neon.Temporal.JsonDataConverter"/>.
            </para>
            <note>
            When you need a custom data converter, you must set this immediately after connecting
            the client.  You must not change the converter after you've started workers.
            </note>
            </summary>
        </member>
        <member name="E:Neon.Temporal.TemporalClient.ConnectionClosed">
            <summary>
            Raised when the connection is closed.  You can determine whether the connection
            was closed normally or due to an error by examining the <see cref="T:Neon.Temporal.TemporalClientClosedArgs"/>
            arguments passed to the handler.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.DebugLog(System.String)">
            <summary>
            <para>
            <b>INTERNAL USE ONLY:</b> Appends a line of text to the debug log which is
            used internally to debug generated code like stubs.  This hardcodes its
            output to <b>C:\Temp\temporal-debug.log</b> so this currently only works
            on Windows.
            </para>
            <note>
            This method doesn't actually log anything unless <see cref="P:Neon.Temporal.TemporalSettings.Debug"/>
            is set to <c>true</c>.
            </note>
            </summary>
            <param name="text">The line of text to be written.</param>
        </member>
        <member name="P:Neon.Temporal.TemporalClient.SyncSignalRetry">
            <summary>
            <para>
            Controls how synchronous signals operations are polled until the signal operation is
            completed.  This defaults to something reasonable.
            </para>
            <note>
            The transient detector function specified by the policy passed is ignore and is
            replaced by a function that considers all exceptions to be transient.
            </note>
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.EnsureNotDisposed(System.Boolean)">
            <summary>
            Ensures that that client instance is not disposed.
            </summary>
            <param name="noClosingCheck">Optionally skip check that the connection is in the process of closing.</param>
            <exception cref="T:System.ObjectDisposedException">Thrown if the client is disposed or is no longer connected to <b>temporal-proxy</b>.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RaiseConnectionClosed(System.Exception)">
            <summary>
            Raises the <see cref="E:Neon.Temporal.TemporalClient.ConnectionClosed"/> event if it hasn't been
            raised already.
            </summary>
            <param name="exception">Optional exception to be included in the event.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.GetWorkerById(System.Int64)">
            <summary>
            Looks up an associated worker by its ID.
            </summary>
            <param name="workerId">The worker ID.</param>
            <returns>The <see cref="T:Neon.Temporal.Worker"/> or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ResolveNamespace(System.String)">
            <summary>
            Returns the Temporal namespace to be referenced for an operation.  If <paramref name="namespace"/>
            is not <c>null</c> or empty then that will be returned otherwise the  <see cref="P:Neon.Temporal.TemporalSettings.Namespace"/>
            will be returned.  Note that one of <paramref name="namespace"/> or the default namespace must
            be non-empty.
            </summary>
            <param name="namespace">The specific namespace to use or null/empty.</param>
            <returns>The namespace to be referenced.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="namespace"/> and the default namespace are both null or empty.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.CallProxyAsync(Neon.Temporal.Internal.ProxyRequest,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Asynchronously calls the <b>temporal-proxy</b> by sending a request message
            and then waits for a reply.
            </summary>
            <param name="request">The request message.</param>
            <param name="timeout">
            Optionally specifies the maximum time to wait for the operation to complete.
            This defaults to unlimited.
            </param>
            <param name="cancellationToken">Optional cancellation token.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ProxyReplyAsync(Neon.Temporal.Internal.ProxyRequest,Neon.Temporal.Internal.ProxyReply)">
            <summary>
            <para>
            Asynchronously replies to a request from the <b>temporal-proxy</b>.
            </para>
            <note>
            The reply message's <see cref="P:Neon.Temporal.Internal.ProxyReply.RequestId"/> will be automatically
            set to the <paramref name="request"/> message's request ID by this method.
            </note>
            </summary>
            <param name="request">The received request message.</param>
            <param name="reply">The reply message.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.HeartbeatThread">
            <summary>
            Implements the connection's background thread which is responsible
            for checking <b>temporal-proxy</b> health via heartbeat requests.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.TimeoutThread">
            <summary>
            Implements the connection's background thread which is responsible
            for handling <b>temporal-proxy</b> request timeouts.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RegisterNamespaceAsync(Neon.Temporal.Internal.InternalRegisterNamespaceRequest)">
            <summary>
            Registers a Temporal namespace using the <see cref="T:Neon.Temporal.Internal.InternalRegisterNamespaceRequest"/> information passed.
            </summary>
            <param name="request">The namespace properties.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.NamespaceAlreadyExistsException">Thrown if the namespace already exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal cluster problems.</exception>
            <exception cref="T:Neon.Temporal.ServiceBusyException">Thrown when Temporal is too busy.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RegisterNamespaceAsync(System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Registers a Temporal namespace using the specified parameters.
            </summary>
            <param name="name">The namespace name.</param>
            <param name="description">Optionally specifies a description.</param>
            <param name="ownerEmail">Optionally specifies the owner's email address.</param>
            <param name="retentionDays">
            Optionally specifies the number of days to retain the history for workflows 
            completed in this namespace.  This defaults to <b>7 days</b> and may be as long
            as <b>30 days</b>.
            </param>
            <param name="ignoreDuplicates">
            Optionally ignore duplicate namespace registrations.  This defaults
            to <c>false</c>.
            </param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.NamespaceAlreadyExistsException">Thrown if the namespace already exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal cluster problems.</exception>
            <exception cref="T:Neon.Temporal.ServiceBusyException">Thrown when Temporal is too busy.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.DescribeNamespaceAsync(System.String)">
            <summary>
            Describes the named Temporal namespace.
            </summary>
            <param name="name">The namespace name.</param>
            <returns>The <see cref="T:Neon.Temporal.Internal.NamespaceDescription"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the named namespace does not exist.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal cluster problems.</exception>
            <exception cref="T:Neon.Temporal.ServiceBusyException">Thrown when Temporal is too busy.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.UpdateNamespaceAsync(System.String,Neon.Temporal.UpdateNamespaceRequest)">
            <summary>
            Updates the named Temporal namespace.
            </summary>
            <param name="name">Identifies the target namespace.</param>
            <param name="request">The updated namespace information.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.ListNamespacesAsync(System.Int32,System.Byte[])">
            <summary>
            Lists the Temporal namespaces.
            </summary>
            <param name="pageSize">
            The maximum number of namespaces to be returned.  This must be
            greater than or equal to one.
            </param>
            <param name="nextPageToken">
            Optionally specifies an opaque token that can be used to retrieve subsequent
            pages of namespaces.
            </param>
            <returns>A <see cref="T:Neon.Temporal.NamespaceListPage"/> with the namespaces.</returns>
            <remarks>
            <para>
            This method can be used to retrieve one or more pages of namespace
            results.  You'll pass <paramref name="pageSize"/> as the maximum number
            of namespaces to be returned per page.  The <see cref="T:Neon.Temporal.NamespaceListPage"/>
            returned will list the namespaces and if there are more namespaces waiting
            to be returned, will return token that can be used in a subsequent
            call to retrieve the next page of results.
            </para>
            <note>
            <see cref="P:Neon.Temporal.NamespaceListPage.NextPageToken"/> will be set to <c>null</c>
            when there are no more result pages remaining.
            </note>
            </remarks>
        </member>
        <member name="E:Neon.Temporal.TemporalClient.WorkflowExecuteEvent">
            <summary>
            Raised when an external workflow is executed.  This is used internally
            for unit tests that verify that workflow options are configured correctly. 
            </summary>
        </member>
        <member name="E:Neon.Temporal.TemporalClient.ChildWorkflowExecuteEvent">
            <summary>
            Raised when a child workflow is executed.  This is used internally
            for unit tests that verify that workflow options are configured correctly. 
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RaiseWorkflowExecuteEvent(Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Raises the <see cref="E:Neon.Temporal.TemporalClient.WorkflowExecuteEvent"/>.
            </summary>
            <param name="options">The workflow options.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.RaiseChildWorkflowExecuteEvent(Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Raises the <see cref="E:Neon.Temporal.TemporalClient.ChildWorkflowExecuteEvent"/>.
            </summary>
            <param name="options">The workflow options.</param>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.SetCacheMaximumSizeAsync(System.Int32)">
            <summary>
            <para>
            Sets the maximum number of sticky workflows for which of history will be 
            retained for workflow workers created by this client as a performance 
            optimization.  When this is exceeded, Temporal will may need to retrieve 
            the entire workflow history from the Temporal cluster when a workflow is 
            scheduled on the client's workers.
            </para>
            <para>
            This defaults to <b>10K</b> sticky workflows.
            </para>
            </summary>
            <param name="cacheMaximumSize">The maximum number of workflows to be cached.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.GetWorkflowCacheSizeAsync">
            <summary>
            Returns the current maximum number of sticky workflows for which history
            will be retained as a performance optimization.
            </summary>
            <returns>The maximum number of cached workflows.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewUntypedWorkflowStub(System.String,Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Creates an untyped stub that can be used to start a single workflow execution.
            </summary>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Specifies the workflow options (including the <see cref="P:Neon.Temporal.StartWorkflowOptions.TaskQueue"/>).</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowStub"/>.</returns>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow methods using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Temporal as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            <para>
            GOLANG doesn't support the concept of workflow methods.  GOLANG workflows 
            are just given a simple name which you'll pass here as <paramref name="workflowTypeName"/>
            to make cross platform calls.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewUntypedWorkflowStub(System.String,System.String,System.String)">
            <summary>
            Creates an untyped stub for a known workflow execution.
            </summary>
            <param name="workflowId">The workflow ID.</param>
            <param name="runId">Optionally specifies the workflow run ID.</param>
            <param name="namespace">
            Optionally specifies the namespace where the target workflow is running.
            This will be required when default namespace for the client isn't specified
            or when the the target execution is running in a different namespace.
            </param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowStub"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewUntypedWorkflowStub(Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Creates an untyped stub for a known workflow execution.
            </summary>
            <param name="execution">The workflow execution.</param>
            <param name="namespace">
            Optionally specifies the namespace where the target workflow is running.
            This will be required when default namespace for the client isn't specified
            or when the the target execution is running in a different namespace.
            </param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowStub"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewWorkflowFutureStub``1(System.String,Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Creates a stub suitable for starting an external workflow and then waiting
            for the result as separate operations.
            </summary>
            <typeparam name="TWorkflowInterface">The target workflow interface.</typeparam>
            <param name="methodName">
            Optionally identifies the target workflow method.  This is the name specified in
            <c>[WorkflowMethod]</c> attribute for the workflow method or <c>null</c>/empty for
            the default workflow method.
            </param>
            <param name="options">Optionally specifies custom <see cref="T:Neon.Temporal.StartWorkflowOptions"/>.</param>
            <returns>A <see cref="T:Neon.Temporal.ChildWorkflowStub`1"/> instance.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewWorkflowStub``1(System.String,System.String,System.String)">
            <summary>
            Creates a typed workflow stub connected to a known workflow execution
            using IDs.  This can be used to signal and query the workflow via the 
            type-safe interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">Identifies the workflow interface.</typeparam>
            <param name="workflowId">Specifies the workflow ID.</param>
            <param name="runId">Optionally specifies the workflow's run ID.</param>
            <param name="namespace">
            Optionally specifies the namespace where the target workflow is running.
            This will be required when default namespace for the client isn't specified
            or when the the target execution is running in a different namespace.
            </param>
            <returns>The dynamically generated stub that implements the workflow methods defined by <typeparamref name="TWorkflowInterface"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewWorkflowStub``1(Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Creates a typed workflow stub connected to a known workflow execution
            using a <see cref="T:Neon.Temporal.WorkflowExecution"/>.  This can be used to signal and
            query the workflow via the type-safe interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">Identifies the workflow interface.</typeparam>
            <param name="execution">Specifies the <see cref="T:Neon.Temporal.WorkflowExecution"/>.</param>
            <param name="namespace">
            Optionally specifies the namespace where the target workflow is running.
            This will be required when default namespace for the client isn't specified
            or when the the target execution is running in a different namespace.
            </param>
            <returns>The dynamically generated stub that implements the workflow methods defined by <typeparamref name="TWorkflowInterface"/>.</returns>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewWorkflowStub(System.String,Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Creates an untyped workflow stub to be used for launching a workflow.
            </summary>
            <param name="workflowTypeName">Specifies the workflow type name.</param>
            <param name="options">Optionally specifies the workflow options.</param>
            <returns>The new <see cref="T:Neon.Temporal.WorkflowStub"/>.</returns>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow methods using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Temporal as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            <para>
            GOLANG doesn't support the concept of workflow methods.  GOLANG workflows 
            are just given a simple name which you'll pass here as <paramref name="workflowTypeName"/>
            to make cross platform calls.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.NewWorkflowStub``1(Neon.Temporal.StartWorkflowOptions,System.String)">
            <summary>
            Creates a typed workflow stub that can be used to start as well as 
            query and signal the workflow via the type-safe interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">Identifies the workflow interface.</typeparam>
            <param name="options">Optionally specifies the workflow options.</param>
            <param name="workflowTypeName">
            Optionally specifies the workflow type name by overriding the fully 
            qualified <typeparamref name="TWorkflowInterface"/> type name or the name
            specified by a <see cref="T:Neon.Temporal.WorkflowAttribute"/>.
            </param>
            <returns>The dynamically generated stub that implements the workflow methods defined by <typeparamref name="TWorkflowInterface"/>.</returns>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow methods using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Temporal as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            <para>
            GOLANG doesn't support the concept of workflow methods.  GOLANG workflows 
            are just given a simple name which you'll pass here as <paramref name="workflowTypeName"/>
            to make cross platform calls.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.DescribeWorkflowExecutionAsync(System.String,System.String,System.String)">
            <summary>
            Describes a workflow execution by explicit IDs.
            </summary>
            <param name="workflowId">The workflow ID.</param>
            <param name="runid">Optionally specifies the run ID.</param>
            <param name="namespace">Optionally specifies the namespace.</param>
            <returns>The <see cref="T:Neon.Temporal.Internal.WorkflowDescription"/></returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow does not exist.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.DescribeWorkflowExecutionAsync(Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Returns the current state of a running workflow.
            </summary>
            <param name="execution">Identifies the workflow execution.</param>
            <param name="namespace">Optionally specifies the namespace.  This defaults to the client namespace.</param>
            <returns>A <see cref="T:Neon.Temporal.Internal.WorkflowDescription"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.WaitForWorkflowStartAsync(Neon.Temporal.WorkflowExecution,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Waits for a resonable period of time for Temporal to start a workflow.
            </summary>
            <param name="execution">Identifies the target workflow.</param>
            <param name="namespace">Optional namespace.</param>
            <param name="maxWait">
            Optionally overrides <see cref="P:Neon.Temporal.TemporalSettings.MaxWorkflowWaitUntilRunningSeconds"/> to
            specify a custom maximum wait time.  The default setting is <b>30 seconds</b>.
            </param>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the target workflow does not exist.</exception>
            <exception cref="T:Neon.Temporal.SyncSignalException">Thrown if the workflow is closed or the signal could not be executed for another reason.</exception>
            <exception cref="T:Neon.Temporal.TemporalTimeoutException">Thrown when the workflow did not start running within a reasonable period of time.</exception>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <remarks>
            This method can be handy when writing non-emulated unit tests.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.StartWorkflowAsync(System.String,System.Byte[],Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Starts an external workflow using a specific workflow type name, returning a <see cref="T:Neon.Temporal.WorkflowExecution"/>
            that can be used to track the workflow and also wait for its result via <see cref="M:Neon.Temporal.TemporalClient.GetWorkflowResultAsync(Neon.Temporal.WorkflowExecution,System.String)"/>.
            </summary>
            <param name="workflowTypeName">
            The type name used when registering the workers that will handle this workflow.
            This name will often be the fully qualified name of the workflow type but 
            this may have been customized when the workflow worker was registered.
            </param>
            <param name="args">Specifies the workflow arguments encoded into a byte array.</param>
            <param name="options">Specifies the workflow options.</param>
            <returns>A <see cref="T:Neon.Temporal.WorkflowExecution"/> identifying the new running workflow instance.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if there is no workflow registered for <paramref name="workflowTypeName"/>.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is not valid.</exception>
            <exception cref="T:Neon.Temporal.WorkflowRunningException">Thrown if a workflow with this ID is already running.</exception>
            <remarks>
            This method kicks off a new workflow instance and returns after Temporal has
            queued the operation but the method <b>does not</b> wait for the workflow to
            complete.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.GetWorkflowResultAsync(Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Returns the result from a workflow execution, blocking until the workflow
            completes if it is still running.
            </summary>
            <param name="execution">Identifies the workflow execution.</param>
            <param name="namespace">Optionally specifies the namespace.  This defaults to the client namespace.</param>
            <returns>The workflow result encoded as bytes or <c>null</c>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.StartChildWorkflowAsync(Neon.Temporal.Workflow,System.String,System.Byte[],Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Starts a child workflow.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="workflowTypeName">
            The type name used when registering the workers that will handle this workflow.
            This name will often be the fully qualified name of the workflow type but 
            this may have been customized when the workflow worker was registered.
            </param>
            <param name="args">Specifies the workflow arguments encoded into a byte array.</param>
            <param name="options">Specifies the workflow options.</param>
            <returns>A <see cref="T:Neon.Temporal.Internal.ChildExecution"/> identifying the new running workflow instance.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if there is no workflow registered for <paramref name="workflowTypeName"/>.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is not valid.</exception>
            <exception cref="T:Neon.Temporal.WorkflowRunningException">Thrown if a workflow with this ID is already running.</exception>
            <remarks>
            This method kicks off a new child workflow instance and returns after Temporal has
            queued the operation but the method <b>does not</b> wait for the workflow to
            complete.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.GetChildWorkflowResultAsync(Neon.Temporal.Workflow,Neon.Temporal.Internal.ChildExecution)">
            <summary>
            Returns the result from a child workflow execution, blocking until the workflow
            completes if it is still running.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="childExecution">Identifies the child workflow execution.</param>
            <returns>The workflow result encoded as bytes or <c>null</c>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.CancelWorkflowAsync(Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Cancels a workflow if it has not already finished.
            </summary>
            <param name="execution">Identifies the running workflow.</param>
            <param name="namespace">Optionally identifies the namespace.  This defaults to the client namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.TerminateWorkflowAsync(Neon.Temporal.WorkflowExecution,System.String,System.Byte[],System.String)">
            <summary>
            Terminates a workflow if it has not already finished.
            </summary>
            <param name="execution">Identifies the running workflow.</param>
            <param name="reason">Optionally specifies an error reason string.</param>
            <param name="details">Optionally specifies additional details as a byte array.</param>
            <param name="namespace">Optionally specifies the namespace.  This defaults to the client namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.SignalWorkflowAsync(Neon.Temporal.WorkflowExecution,System.String,System.Byte[],System.String)">
            <summary>
            Transmits a signal to a running external workflow.  This low-level method accepts a byte array
            with the already encoded parameters.
            </summary>
            <param name="execution">The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</param>
            <param name="signalName">Identifies the signal.</param>
            <param name="signalArgs">Optionally specifies the signal arguments as a byte array.</param>
            <param name="namespace">Optionally specifies the namespace.  This defaults to the client namespace.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.SignalWorkflowWithStartAsync(System.String,System.String,System.Byte[],System.Byte[],Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Transmits a signal to an external workflow, starting the workflow if it's not currently running.
            This low-level method accepts a byte array with the already encoded parameters.
            </summary>
            <param name="workflowTypeName">The target workflow type name.</param>
            <param name="signalName">Identifies the signal.</param>
            <param name="signalArgs">Optionally specifies the signal arguments as a byte array.</param>
            <param name="startArgs">Optionally specifies the workflow arguments.</param>
            <param name="options">Optionally specifies the options to be used for starting the workflow when required.</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the namespace does not exist.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown if the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.QueryWorkflowAsync(Neon.Temporal.WorkflowExecution,System.String,System.Byte[],System.String)">
            <summary>
            Queries an external workflow.  This low-level method accepts a byte array
            with the already encoded parameters and returns an encoded result.
            </summary>
            <param name="execution">The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</param>
            <param name="queryType">Identifies the query.</param>
            <param name="queryArgs">Optionally specifies the query arguments encoded as a byte array.</param>
            <param name="namespace">Optionally specifies the namespace.  This defaults to the client namespace.</param>
            <returns>The query result encoded as a byte array.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the workflow no longer exists.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.SignalChildWorkflowAsync(Neon.Temporal.Workflow,Neon.Temporal.Internal.ChildExecution,System.String,System.Byte[])">
            <summary>
            <para>
            Signals a child workflow.  This low-level method accepts a byte array
            with the already encoded parameters.
            </para>
            <note>
            This method blocks until the child workflow is scheduled and
            actually started on a worker.
            </note>
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="childExecution">The child workflow execution.</param>
            <param name="signalName">Specifies the signal name.</param>
            <param name="signalArgs">Specifies the signal arguments as an encoded byte array.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the named namespace does not exist.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal cluster problems.</exception>
            <exception cref="T:Neon.Temporal.ServiceBusyException">Thrown when Temporal is too busy.</exception>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.SyncSignalWorkflowAsync(Neon.Temporal.WorkflowExecution,System.String,System.String,System.Byte[],System.String)">
            <summary>
            Transmits a signal to a running external workflow and then polls the completion by querying the workflow
            to wait for the signal to be received and processed by the workflow.  This overload does 
            not return a result.  This low-level method accepts a byte array with the already encoded 
            parameters.
            </summary>
            <param name="execution">The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</param>
            <param name="signalName">The target signal name.</param>
            <param name="signalId">The globally unique signal transaction ID.</param>
            <param name="signalArgs">Specifies the <see cref="T:Neon.Temporal.Internal.SyncSignalCall"/> as a single item array and encoded as a byte array.</param>
            <param name="namespace">Optionally specifies the namespace.</param>
            <returns>The encoded signal results or <c>null</c> for signals that don't return a result.</returns>
            <exception cref="T:Neon.Temporal.SyncSignalException">Thrown if the target synchronous signal doesn't exist or the workflow is already closed.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
            <exception cref="T:Neon.Temporal.TemporalTimeoutException">Thrown if the operation timed out while waiting for a reply.</exception>
            <remarks>
            <para>
            <paramref name="signalArgs"/> must include an internal <see cref="T:Neon.Temporal.Internal.SyncSignalCall"/> encoded as 
            the only argument.  This first includes the information required by the worker to route to the 
            user's signal, the globally unique transaction ID that the worker will use to track the signal
            execution state and the client will use to poll for that state.  This also includes the encoded
            user arguments being passed to the signal.
            </para>
            <note>
            The value passed as <paramref name="signalId"/> must match that in <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/>
            encoded as the encoded in <paramref name="signalArgs"/>.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.TemporalClient.SyncSignalChildWorkflowAsync(Neon.Temporal.Workflow,Neon.Temporal.Internal.ChildExecution,System.String,System.String,System.Byte[])">
            <summary>
            Transmits a signal to a child workflow and then polls for the completion by querying the workflow
            to wait for the signal to be received and processed by the workflow.  This overload does 
            not return a result.  This low-level method accepts a byte array with the already encoded 
            parameters.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="childExecution">The child workflow execution.</param>
            <param name="signalName">The target signal name.</param>
            <param name="signalId">The globally unique signal transaction ID.</param>
            <param name="signalArgs">Specifies the <see cref="T:Neon.Temporal.Internal.SyncSignalCall"/> as a single item array and encoded as a byte array.</param>
            <returns>The encoded signal results or <c>null</c> for signals that don't return a result.</returns>
            <exception cref="T:Neon.Temporal.SyncSignalException">Thrown if the target synchronous signal doesn't exist or the workflow is already closed.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal problems.</exception>
            <exception cref="T:Neon.Temporal.TemporalTimeoutException">Thrown if the operation timed out while waiting for a reply.</exception>
            <remarks>
            <para>
            <paramref name="signalArgs"/> must include an internal <see cref="T:Neon.Temporal.Internal.SyncSignalCall"/> encoded as 
            the only argument.  This first includes the information required by the worker to route to the 
            user's signal, the globally unique transaction ID that the worker will use to track the signal
            execution state and the client will use to poll for that state.  This also includes the encoded
            user arguments being passed to the signal.
            </para>
            <note>
            The value passed as <paramref name="signalId"/> must match that in <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/>
            encoded as the encoded in <paramref name="signalArgs"/>.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.TemporalClosedDelegate">
            <summary>
            Delegate called by a <see cref="T:Neon.Temporal.TemporalClient"/> when the connection is closed
            explicitly or where there's a problem communicating with the <b>temporal-proxy</b>.
            </summary>
            <param name="sender">The event sender.</param>
            <param name="args">The event arguments.</param>
        </member>
        <member name="T:Neon.Temporal.TemporalClientClosedArgs">
            <summary>
            The event arguments sent when a <see cref="T:Neon.Temporal.TemporalClient"/> is closed
            with a property indicating whether or not the connection was closed due
            to an error.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalClientClosedArgs.Exception">
            <summary>
            This will be set if the connection was closed due to an error
            or <c>null</c> when the connection was closed normally.
            </summary>
        </member>
        <member name="T:Neon.Temporal.TemporalExtensions">
            <summary>
            Implements handy extension methods.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalExtensions.SendRequestAsync``1(System.Net.Http.HttpClient,``0)">
            <summary>
            Extends <see cref="T:System.Net.Http.HttpClient"/> by adding a method that can serialize and
            transmit a <b>temporal-proxy</b> proxy request message.
            </summary>
            <typeparam name="TRequest">The request message type.</typeparam>
            <param name="client">The HTTP client.</param>
            <param name="request">The message to be sent.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.TemporalExtensions.SendReplyAsync``2(System.Net.Http.HttpClient,``0,``1)">
            <summary>
            <para>
            Extends <see cref="T:System.Net.Http.HttpClient"/> by adding a method that can serialize and
            transmit a <b>temporal-proxy</b> reply to a proxy request message.
            </para>
            <note>
            This method ensures that the reply message's <see cref="P:Neon.Temporal.Internal.ProxyReply.RequestId"/>
            matches the request's <see cref="P:Neon.Temporal.Internal.ProxyRequest.RequestId"/> before sending the
            reply.
            </note>
            </summary>
            <typeparam name="TRequest">The request message type.</typeparam>
            <typeparam name="TReply">The reply message type.</typeparam>
            <param name="client">The HTTP client.</param>
            <param name="request">The request being responsed to.</param>
            <param name="reply">The reply message.</param>
            <returns>The <see cref="T:System.Net.Http.HttpResponseMessage"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.TemporalSettings">
            <summary>
            <para>
            Temporal client settings.
            </para>
            <note>
            Temporal settings properties are considered to be <b>read/write</b> until they
            are used for connecting a <see cref="T:Neon.Temporal.TemporalClient"/>.  After that time,
            these properties are considered <b>read-only</b> and an <see cref="T:System.InvalidOperationException"/>
            will be thrown when you try to set a property value.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.Client">
            <summary>
            Set to the associated client.  Settings are considered to be <b>read-only</b>
            when this is not <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalSettings.EnsureReadWrite">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> when <see cref="P:Neon.Temporal.TemporalSettings.Client"/>
            is not <c>null</c>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalSettings.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="hostPort">
            Optionally specifies the target server host and port being connected.
            Specifies the Temporal server host and port being connected.  This is typically formatted
            as <b>host:port</b> where <b>host</b> is the IP address or hostname for the
            Temporal server.  Alternatively, this can be formatted as <b>dns:///host:port</b>
            to enable DNS round-robin lookups.  This defaults to <b>localhost:7233</b>.
            </param>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.HostPort">
            <summary>
            Specifies the Temporal server host and port being connected.  This is typically formatted
            as <b>host:port</b> where <b>host</b> is the IP address or hostname for the
            Temporal server.  Alternatively, this can be formatted as <b>dns:///host:port</b>
            to enable DNS round-robin lookups.  This defaults to <b>localhost:7233</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ListenPort">
            <summary>
            Optionally specifies the port where the client will listen for traffic from the 
            associated <b>temporal-proxy</b>.  This defaults to 0 which specifies that lets the 
            operating system choose an unused ephermal port.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.Namespace">
            <summary>
            Specifies the default Temporal namespace for this client.  This is required and defaults to <c>"default"</c>.
            </summary>
            <remarks>
            The default namespace can be overridden for workflow interfaces via <see cref="P:Neon.Temporal.WorkflowInterfaceAttribute.Namespace"/>
            or for specific interface methods via <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Namespace"/>.
            </remarks>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.CreateNamespace">
            <summary>
            <para>
            Optionally create the <see cref="P:Neon.Temporal.TemporalSettings.Namespace"/> if it doesn't already exist.
            This defaults to <c>false</c>.
            </para>
            <note>
            Enabling this can be handy for unit testing where you'll likely be starting
            off with a virgin Temporal server when the test start.  We don't recommend
            enabling this for production services.  For production, you should explicitly
            create your namespaces with suitable setttings such has how long workflow histories
            are to be retained.
            </note>
            <note>
            If the default namespace doesn't exist when <see cref="P:Neon.Temporal.TemporalSettings.CreateNamespace"/><c>=true</c> when a
            connection is established, it will be initialized to retain workflow histories for
            up to <b>7 days</b>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.TaskQueue">
            <summary>
            Specifies the default Temporal task queue for this client.  This is optional and defaults to <c>"default"</c>.
            </summary>
            <remarks>
            <para>
            Specifying a default task queue can be convienent for many scenarios, especially for those where
            the application workflows and activities are restricted to a single task queue.
            </para>
            <para>
            The default task queue can be overridden for workflow interfaces via <see cref="P:Neon.Temporal.WorkflowInterfaceAttribute.TaskQueue"/>
            or for specific interface methods via <see cref="P:Neon.Temporal.WorkflowMethodAttribute.TaskQueue"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ClientTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time the client should wait for synchronous 
            operations to complete.  This defaults to <b>10 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ClientTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ClientTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ClientIdentity">
            <summary>
            Optionally identifies the client application establishing the connection so that
            Temporal may include this in its logs and metrics.  This defaults to <b>"unknown"</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.SecurityToken">
            <summary>
            <para>
            The Temporal cluster security token.  This defaults to <c>null</c>.
            </para>
            <note>
            This is not currently supported by the .NET Temporal client and should be
            left alone for now.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ProxyTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time to allow the <b>temporal-proxy</b>
            to indicate that it has received a proxy request message by returning an
            OK response.  The proxy will be considered to be unhealthy when this 
            happens.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ProxyTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ProxyTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.HeartbeatIntervalSeconds">
            <summary>
            Optionally specifies the interval at which heartbeats are transmitted to
            <b>temporal-proxy</b> as a health check.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.HeartbeatInterval">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.HeartbeatIntervalSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.HeartbeatTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time to allow the <b>temporal-proxy</b>
            to respond to a heartbeat message.  The proxy will be considered to be 
            unhealthy when this happens.  This defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.HeartbeatTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.HeartbeatTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ConnectRetries">
            <summary>
            Specifies the number of times to retry connecting to the Temporal cluster.  This defaults
            to <b>3</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ConnectRetryDelaySeconds">
            <summary>
            Specifies the number of seconds to delay between cluster connection attempts.
            This defaults to <b>5.0 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ConnectRetryDelay">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ConnectRetryDelaySeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowExecutionTimeoutSeconds">
            <summary>
            Specifies the default maximum workflow execution time.  This defaults to <b>24 hours</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowExecutionTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.WorkflowExecutionTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowRunTimeoutSeconds">
            <summary>
            The timeout for duration of a single workflow run.
            The resolution is seconds.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowRunTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.WorkflowRunTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowTaskTimeoutSeconds">
            <summary>
            Specifies the default maximum time a workflow task may execute.
            This must be with the range of <b>1 &lt; value &lt;= 60</b> seconds.
            This defaults to <b>10 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowTaskTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.WorkflowTaskTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.WorkflowIdReusePolicy">
            <summary>
            Specifies what happens when Temporal workflows attempt to reuse workflow IDs.
            This defaults to <see cref="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicate"/>.
            Workflows can customize this via <see cref="T:Neon.Temporal.StartWorkflowOptions"/> or <see cref="T:Neon.Temporal.ChildWorkflowOptions"/>
            or by setting this in the <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/> tagging the 
            workflow entry point method
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityScheduleToCloseTimeoutSeconds">
            <summary>
            Specifies the default maximum time an activity is allowed to wait after being
            scheduled until it's actually scheduled to execute on a worker.  This defaults
            to <b>24 hours</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityScheduleToCloseTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ActivityScheduleToCloseTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityStartToCloseTimeoutSeconds">
            <summary>
            Specifies the default maximum time an activity may run after being started.
            This defaults to <b>24</b> hours.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityStartToCloseTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ActivityStartToCloseTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityScheduleToStartTimeoutSeconds">
            <summary>
            Specifies the default maximum time an activity may wait to be started after being scheduled.
            This defaults to <b>24</b> hours.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityScheduleToStartTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ActivityScheduleToStartTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityHeartbeatTimeoutSeconds">
            <summary>
            Specifies the default maximum allowed between activity heartbeats.  Activities that
            don't submit heartbeats within the time will be considered to be unhealthy and will
            be terminated.  This defaults to <b>60 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ActivityHeartbeatTimeout">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.ActivityHeartbeatTimeoutSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.MaxWorkflowKeepAliveSeconds">
            <summary>
            <b>EXPERIMENTAL:</b> Specifies the maximum seconds that a workflow will be kept alive after
            the workflow method returns to handle any oustanding synchronous signal queries.  This defaults
            to <b>30.0 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.MaxWorkflowKeepAlive">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.MaxWorkflowKeepAliveSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.MaxWorkflowWaitUntilRunningSeconds">
            <summary>
            The default maximum time the <see cref="M:Neon.Temporal.TemporalClient.WaitForWorkflowStartAsync(Neon.Temporal.WorkflowExecution,System.String,System.Nullable{System.TimeSpan})"/> method
            will wait for a workflow to start.  This defaults to <b>30.0 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.MaxWorkflowWaitUntilRunning">
            <summary>
            Returns <see cref="P:Neon.Temporal.TemporalSettings.MaxWorkflowWaitUntilRunningSeconds"/> as a <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.BinaryFolder">
            <summary>
            Optionally specifies the folder where the embedded <b>temporal-proxy</b> binary 
            will be written before starting it.  This defaults to <c>null</c> which specifies
            that the binary will be written to the same folder where the <b>Neon.Temporal</b>
            assembly resides.  This folder may not be writable by the current user so this
            allows you to specify an alternative folder.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.BinaryPath">
            <summary>
            <para>
            Optionally specifies the path to the <b>temporal-proxy</b> executable file.  This
            file must already be present on disk when a <see cref="T:Neon.Temporal.TemporalClient"/> connection
            is established and the appropriate execute permissions must be set for Linux and
            OS/X.  This property takes presidence over <see cref="P:Neon.Temporal.TemporalSettings.BinaryFolder"/> when set.
            </para>
            <para>
            This is useful for situations where the executable must be pre-provisioned for
            security.  One example is deploying Temporal workers to a Docker container with
            a read-only file system.
            </para>
            <note>
            You can use the <see cref="M:Neon.Temporal.TemporalClient.ExtractTemporalProxy(System.String)"/> method to extract
            the Windows, Linux, and OS/X builds of the <b>temporal-proxy</b> executable from
            the <b>Neon.Temporal</b> assembly.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.ProxyLogLevel">
            <summary>
            Optionally specifies the logging level for the associated <b>temporal-proxy</b>.
            This defaults to <see cref="F:Neon.Diagnostics.LogLevel.None"/> which will be appropriate for most
            production situations.  You may wish to set this to <see cref="F:Neon.Diagnostics.LogLevel.Info"/>
            or <see cref="F:Neon.Diagnostics.LogLevel.Debug"/> while debugging.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.LogTemporal">
            <summary>
            <para>
            Optionally specifies that low-level log messages from the embedded GOLANG Temporal client 
            will be included in the log output.  This defaults to <c>false</c>.
            </para>
            <note>
            <see cref="P:Neon.Temporal.TemporalSettings.LogTemporal"/> controls whether log messages coming directly from the GOLANG
            client are included in the log output.  These messages will include things like details
            for connection and workflow execution failures.  <see cref="P:Neon.Temporal.TemporalSettings.LogTemporalProxy"/> controls
            whether log messages from from the <b>temporal-proxy</b> code itself will be included.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.LogTemporalProxy">
            <summary>
            <para>
            Optionally specifies that log messages from the internal <b>temporal-proxy</b>
            code that bridges between .NET and the embedded GOLANG Temporal client
            will be included in the log output.  This defaults to <c>false</c>.
            </para>
            <note>
            <see cref="P:Neon.Temporal.TemporalSettings.LogTemporal"/> controls whether log messages coming directly from the GOLANG
            client are included in the log output.  These messages will include things like details
            for connection and workflow execution failures.  <see cref="P:Neon.Temporal.TemporalSettings.LogTemporalProxy"/> controls
            whether log messages from from the <b>temporal-proxy</b> code itself will be included.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.LogDuringReplay">
            <summary>
            Optionally enable workflow logging while the workflow is being
            replayed from history.  This should generally be enabled only
            while debugging.  This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.Debug">
            <summary>
            Optionally specifies that the connection should run in DEBUG mode.  This currently
            launches the <b>temporal-proxy</b> with a command window (on Windows only) to make 
            it easier to see any output it generates and also has <b>temporal-proxy</b>.  This
            defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.DebugPrelaunched">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally indicates that the <b>temporal-proxy</b> will
            already be running for debugging purposes.  When this is <c>true</c>, the 
            <b>temporal-client</b> be hardcoded to listen on <b>localhost:5001</b> and
            the <b>temporal-proxy</b> will be assumed to be listening on <b>localhost:5000</b>.
            This defaults to <c>false.</c>
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.DebugDisableHeartbeats">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally disable health heartbeats.  This can be
            useful while debugging the client but should never be set for production.
            This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.DebugDisableHandshakes">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally indicates that the <b>temporal-client</b>
            will not perform the <see cref="T:Neon.Temporal.Internal.InitializeRequest"/>/<see cref="T:Neon.Temporal.Internal.InitializeReply"/>
            and <see cref="T:Neon.Temporal.Internal.TerminateRequest"/>/<see cref="T:Neon.Temporal.Internal.TerminateReply"/> handshakes 
            with the <b>temporal-proxy</b> for debugging purposes.  This defaults to
            <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.DebugIgnoreTimeouts">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally ignore operation timeouts.  This can be
            useful while debugging the client but should never be set for production.
            This defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.DebugIgnoreHeartbeats">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally disables heartbeat handling by the
            emulated <b>temporal-proxy</b> for testing purposes.
            </summary>
        </member>
        <member name="P:Neon.Temporal.TemporalSettings.DebugHttpTimeout">
            <summary>
            <b>INTERNAL USE ONLY:</b> Optionally specifies the timeout to use for 
            HTTP requests made to the <b>temporal-proxy</b>.  This defaults to
            <b>5 seconds</b>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.TemporalSettings.Clone">
            <summary>
            Returns a copy of the current instance.
            </summary>
            <returns>The cloned <see cref="T:Neon.Temporal.TemporalSettings"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.UpdateNamespaceInfo">
            <summary>
            Holds the changes to be made to a Temporal namespace's basic properties.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceInfo.Description">
            <summary>
            The updated namespace description.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceInfo.OwnerEmail">
            <summary>
            The updated namespace owner email address.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceInfo.Data">
            <summary>
            Key-value map for any customized purpose.
            </summary>
        </member>
        <member name="T:Neon.Temporal.UpdateNamespaceRequest">
            <summary>
            Holds the changes to be made to a Temporal namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceRequest.Name">
            <summary>
            The namespace name.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceRequest.UpdateInfo">
            <summary>
            The updated basic namespace properties.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceRequest.Config">
            <summary>
            The updated namespace configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceRequest.ReplicationConfig">
            <summary>
            The updated namespace replication configuration.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceRequest.SecurityToken">
            <summary>
            The updated namespace security token.
            </summary>
        </member>
        <member name="P:Neon.Temporal.UpdateNamespaceRequest.DeleteBadBinary">
            <summary>
            The updated namespace bad binary.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Worker">
            <summary>
            Manages a Temporal activity/workflow worker.
            </summary>
            <remarks>
            <para>
            Temporal doesn't appear to support starting, stopping, and then restarting the same
            worker within an individual Temporal client so this class will prevent this.
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.Worker.ActivityRegistration">
            <summary>
            Used for mapping an activity type name to its underlying type
            and entry point method.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.ActivityRegistration.ActivityType">
            <summary>
            The activity type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.ActivityRegistration.ActivityMethod">
            <summary>
            The activity entry point method.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.ActivityRegistration.ActivityMethodParameterTypes">
            <summary>
            The activity method parameter types.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterActivityImplementationAsync(System.Type)">
            <summary>
            Registers an activity implementation with the temporal-proxy.
            </summary>
            <param name="activityType">The activity implementation type.</param>
            <exception cref="T:Neon.Temporal.RegistrationException">Thrown when there's a problem with the registration.</exception>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterActivityAsync``1(System.Boolean)">
            <summary>
            Registers an activity implementation with Temporal.
            </summary>
            <typeparam name="TActivity">The <see cref="T:Neon.Temporal.ActivityBase"/> derived class implementing the activity.</typeparam>
            <param name="disableDuplicateCheck">Disable checks for duplicate activity registrations.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the worker has already been started.  You must register workflow 
            and activity implementations before starting a worker.
            </exception>
            <exception cref="T:Neon.Temporal.RegistrationException">Thrown when there's a problem with the registration.</exception>
            <remarks>
            <note>
            Be sure to register all services you will be injecting into activities via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> before you call this as well as 
            registering of your activity implementations before starting a worker.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Scans the assembly passed looking for activity implementations derived from
            <see cref="T:Neon.Temporal.ActivityBase"/> and tagged by <see cref="T:Neon.Temporal.ActivityAttribute"/> and
            registers them with Temporal.
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="disableDuplicateCheck">Disable checks for duplicate activity registrations.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown for types tagged by <see cref="T:Neon.Temporal.ActivityAttribute"/> that are not 
            derived from <see cref="T:Neon.Temporal.ActivityBase"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown if one of the tagged classes conflict with an existing registration.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the worker has already been started.  You must register workflow 
            and activity implementations before starting workers.
            </exception>
            <exception cref="T:Neon.Temporal.RegistrationException">Thrown when there's a problem with the registration.</exception>
            <remarks>
            <note>
            Be sure to register all services you will be injecting into activities via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> before you call this as well as 
            registering of your activity implementations before starting a worker.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Worker.GetActivityInvokeInfo(System.Type,System.String)">
            <summary>
            Returns the <see cref="T:Neon.Temporal.Worker.ActivityRegistration"/> for an activity type and type name.
            </summary>
            <param name="activityType">The target activity type.</param>
            <param name="activityTypeName">The target activity type name.</param>
            <returns>The <see cref="T:Neon.Temporal.Worker.ActivityRegistration"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.CreateNormalActivity(Neon.Temporal.Worker.ActivityRegistration,System.Int64)">
            <summary>
            Constructs an activity instance suitable for executing a normal (non-local) activity.
            </summary>
            <param name="invokeInfo">The activity invocation information.</param>
            <param name="contextId">The activity context ID.</param>
            <returns>The constructed activity.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.CreateLocalActivity(Neon.Temporal.Internal.LocalActivityAction,System.Int64)">
            <summary>
            Constructs an activity instance suitable for executing a local activity.
            </summary>
            <param name="activityAction">The target activity action.</param>
            <param name="contextId">The activity context ID.</param>
            <returns>The constructed activity.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnActivityProxyRequestAsync(Neon.Temporal.Internal.ProxyRequest)">
            <summary>
            Called to handle activity related request messages received from the <b>temporal-proxy</b>.
            </summary>
            <param name="request">The request message.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnActivityInvokeRequest(Neon.Temporal.Internal.ActivityInvokeRequest)">
            <summary>
            Handles received <see cref="T:Neon.Temporal.Internal.ActivityInvokeRequest"/> messages.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnInvokeLocalActivity(Neon.Temporal.Internal.ActivityInvokeLocalRequest)">
            <summary>
            Handles workflow local activity invocations.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.ActivityStoppingRequest(Neon.Temporal.Internal.ActivityStoppingRequest)">
            <summary>
            Handles received <see cref="M:Neon.Temporal.Worker.ActivityStoppingRequest(Neon.Temporal.Internal.ActivityStoppingRequest)"/> messages.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.#ctor(Neon.Temporal.TemporalClient,System.Int64,Neon.Temporal.WorkerOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="client">The parent client.</param>
            <param name="workerId">The ID of the worker as tracked by the <b>temporal-proxy</b>.</param>
            <param name="options">Specifies the worker options or <c>null</c>.</param>
        </member>
        <member name="M:Neon.Temporal.Worker.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Neon.Temporal.Worker.Client">
            <summary>
            Returns the parent Temporal client.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.IsDisposed">
            <summary>
            Indicates whether the worker has been fully disposed.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.Mode">
            <summary>
            Identifies whether the worker will process activities, workflows, or both.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.WorkerId">
            <summary>
            Returns the ID of the worker as tracked by the <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.Namespace">
            <summary>
            Returns the Temporal namespace where the worker is registered.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.Tasklist">
            <summary>
            Returns the Temporal task queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Worker.EnsureNotDisposed">
            <summary>
            Ensures that the worker instances is not disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the worker is disposed.</exception>
        </member>
        <member name="M:Neon.Temporal.Worker.EnsureCanRegister">
            <summary>
            Ensures that the worker is not running during a registration operation. 
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the worker has already started.</exception>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterAssemblyAsync(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Scans the assembly passed looking for workflow and activity implementations 
            derived from and registers them with Temporal.  This is equivalent to calling
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.Boolean)"/> and
            <see cref="M:Neon.Temporal.Worker.RegisterAssemblyActivitiesAsync(System.Reflection.Assembly,System.Boolean)"/>,
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="disableDuplicateCheck">Disable checks for duplicate workflow and activity registrations.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown for types tagged by <see cref="T:Neon.Temporal.WorkflowAttribute"/> that are not 
            derived from <see cref="T:Neon.Temporal.WorkflowBase"/> or for types tagged by <see cref="T:Neon.Temporal.ActivityAttribute"/>
            that are now derived from <see cref="T:Neon.Temporal.ActivityBase"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown if one of the tagged classes conflict with an existing registration.</exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the worker has already been started.  You must register workflow 
            and activity implementations before starting workers.
            </exception>
            <exception cref="T:Neon.Temporal.RegistrationException">Thrown when there's a problem with the registration.</exception>
            <remarks>
            <note>
            Be sure to register all services you will be injecting into activities via
            <see cref="P:Neon.Common.NeonHelper.ServiceContainer"/> before you call this as well as 
            registering of your activity and workflow implementations before starting 
            a worker.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Worker.StartAsync">
            <summary>
            Starts the worker if it has not already been started.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the worker is disposed.</exception>
        </member>
        <member name="T:Neon.Temporal.Worker.WorkflowRegistration">
            <summary>
            Describes the workflow implementation type, entry point method, and 
            signal/query methods for registered workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.WorkflowRegistration.WorkflowType">
            <summary>
            The workflow implemention type.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.WorkflowRegistration.WorkflowMethod">
            <summary>
            The workflow entry point method.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.WorkflowRegistration.WorkflowMethodParameterTypes">
            <summary>
            The workflow entry point parameter types.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Worker.WorkflowRegistration.MethodMap">
            <summary>
            Maps workflow signal and query names to the corresponding
            method implementations.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterWorkflowImplementationAsync(System.Type)">
            <summary>
            Registers a workflow implementation with temporal-proxy.
            </summary>
            <param name="workflowType">The workflow implementation type.</param>
            <exception cref="T:Neon.Temporal.RegistrationException">Thrown when there's a problem with the registration.</exception>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterWorkflowAsync``1(System.Boolean)">
            <summary>
            Registers a workflow implementation with Temporal.
            </summary>
            <typeparam name="TWorkflow">The <see cref="T:Neon.Temporal.WorkflowBase"/> derived class implementing the workflow.</typeparam>
            <param name="disableDuplicateCheck">Disable checks for duplicate registrations.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the worker has already been started.  You must register workflow 
            and activity implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all of your workflow implementations before starting a worker.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Worker.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Scans the assembly passed looking for workflow implementations derived from
            <see cref="T:Neon.Temporal.WorkflowBase"/> and tagged by <see cref="T:Neon.Temporal.WorkflowAttribute"/> with
            <see cref="P:Neon.Temporal.WorkflowAttribute.AutoRegister"/> set to <c>true</c> and registers 
            them with Temporal.
            </summary>
            <param name="assembly">The target assembly.</param>
            <param name="disableDuplicateCheck">Disable checks for duplicate registrations.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown for types tagged by <see cref="T:Neon.Temporal.WorkflowAttribute"/> that are not 
            derived from <see cref="T:Neon.Temporal.WorkflowBase"/>.
            </exception>
            <exception cref="T:System.InvalidOperationException">Thrown if one of the tagged classes conflict with an existing registration.</exception>
            <exception cref="T:System.InvalidOperationException">
            <exception cref="T:Neon.Temporal.RegistrationException">Thrown when there's a problem with the registration.</exception>
            Thrown if the worker has already been started.  You must register workflow 
            and activity implementations before starting workers.
            </exception>
            <remarks>
            <note>
            Be sure to register all of your workflow implementations before starting a worker.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Worker.GetWorkflowRegistration(System.String)">
            <summary>
            Returns the registration for the named Temporal workflow.
            </summary>
            <param name="workflowTypeName">The Temporal workflow type name.</param>
            <returns>The <see cref="T:Neon.Temporal.Worker.WorkflowRegistration"/> or <c>null</c> if the type was not found.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.GetWorkflow(System.Int64)">
            <summary>
            Returns the existing workflow corresponding to a context ID.
            </summary>
            <param name="contextId">The workflow context ID.</param>
            <returns>The <see cref="T:Neon.Temporal.Workflow"/> or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnProxyRequestAsync(Neon.Temporal.Internal.ProxyRequest)">
            <summary>
            Called to handle workflow related request messages received from the <b>temporal-proxy</b>.
            </summary>
            <param name="request">The request message.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnInvokeAsync(Neon.Temporal.Internal.WorkflowInvokeRequest)">
            <summary>
            Handles workflow invocation.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnSignalAsync(Neon.Temporal.Internal.WorkflowSignalInvokeRequest)">
            <summary>
            Handles workflow signals.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnSyncSignalAsync(Neon.Temporal.Internal.WorkflowSignalInvokeRequest)">
            <summary>
            Handles internal <see cref="F:Neon.Temporal.TemporalClient.SignalSync"/> workflow signals.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="M:Neon.Temporal.Worker.OnQueryAsync(Neon.Temporal.Internal.WorkflowQueryInvokeRequest)">
            <summary>
            Handles workflow queries.
            </summary>
            <param name="request">The request message.</param>
            <returns>The reply message.</returns>
        </member>
        <member name="T:Neon.Temporal.WorkerArgs">
            <summary>
            Holds the opaque arguments passed to <see cref="T:Neon.Temporal.WorkflowBase"/> and <see cref="T:Neon.Temporal.ActivityBase"/>
            implementations by the <see cref="T:Neon.Temporal.TemporalClient"/> when the workflow or activity is 
            executed on a worker.  This must be passed to the base <see cref="T:Neon.Temporal.WorkflowBase"/> or
            <see cref="T:Neon.Temporal.ActivityBase"/> class constructors.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerArgs.Worker">
            <summary>
            The parent <see cref="T:Neon.Temporal.Worker"/>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerArgs.ContextId">
            <summary>
            The ID used to reference the corresponding Temporal context managed by
            the <b>temporal-proxy</b>.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkerMode">
            <summary>
            Enumerates the possible worker modes.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkerMode.Unspecified">
            <summary>
            THe worker mode has not been specified.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkerMode.Activity">
            <summary>
            The worker processes activities.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkerMode.Workflow">
            <summary>
            The worker processes workflows.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkerMode.Both">
            <summary>
            The worker processes both activities and workflows.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkerOptions">
            <summary>
            Specifies the options Temporal will use when assigning workflow and activity
            executions to a user worker service.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.MaxConcurrentActivityExecutionSize">
            <summary>
            Optionally sets set the maximum concurrent activity executions this worker can have.
            The zero value of this uses the default value.  Defaults to <b>1000</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.WorkerActivitiesPerSecond">
            <summary>
            <para>
            Optionally sets the rate limiting on number of activities that can be executed per second per
            worker. This can be used to limit resources used by the worker.
            </para>
            <note>
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            The zero value of this uses the default value..
            </note>
            <para>
            This defaults to <b>100,000</b>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.MaxConcurrentLocalActivityExecutionSize">
            <summary>
            Optionally sets the maximum concurrent local activity executions this worker can have.
            The zero value of this uses the default value.  This defaults to <b>1000</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.WorkerLocalActivitiesPerSecond">
            <summary>
            <para>
            Optionally sets the rate limiting on number of local activities that can be executed per second per
            worker. This can be used to limit resources used by the worker.
            </para>
            <note>
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your local activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            The zero value of this uses the default value.
            </note>
            <para>
            This defaults to <b>100,000</b>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.TaskQueueActivitiesPerSecond">
            <summary>
            <para>
            Optionally sets the rate limiting on number of activities that can be executed per second.
            This is managed by the server and controls activities per second for your entire task queue
            whereas WorkerActivityTasksPerSecond controls activities only per worker.
            </para>
            <note>
            Notice that the number is represented in float, so that you can set it to less than
            1 if needed. For example, set the number to 0.1 means you want your activity to be executed
            once for every 10 seconds. This can be used to protect down stream services from flooding.
            </note>
            <para>
            The zero value of this uses the default value. This defaults to <b>100,000</b>.
            </para>
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.MaxConcurrentActivityTaskPollers">
            <summary>
            Optionally sets the maximum number of goroutines that will concurrently poll the
            temporal-server to retrieve activity tasks. Changing this value will affect the
            rate at which the worker is able to consume tasks from a task queue. Defaults to <b>2</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.MaxConcurrentWorkflowTaskExecutionSize">
            <summary>
            Optionally sets the maximum concurrent decision task executions this worker can have.
            The zero value of this uses the default value.  This defaults to <b>100,000</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.MaxConcurrentWorkflowTaskPollers">
            <summary>
            Optionally sets the maximum number of goroutines that will concurrently poll the
            temporal-server to retrieve workflow tasks. Changing this value will affect the
            rate at which the worker is able to consume tasks from a task queue. Defaults to <b>2</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.EnableLoggingInReplay">
            <summary>
            Optionally enables logging in replay.  This defaults to <c>false</c>.
            </summary>
            <remarks>
            In the workflow code you can use workflow.GetLogger(ctx) to write logs. By default, the logger will skip log
            entry during replay mode so you won't see duplicate logs. This option will enable the logging in replay mode.
            This is only useful for debugging purpose.
            </remarks>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.DisableStickyExecution">
            <summary>
            Optionally disables sticky execution.  This defaults to <c>false</c>.
            </summary>
            <remarks>
            This is an optimization for workflow execution. When sticky execution is enabled, the worker can maintain
            workflow state and history making workflow replaying faster.
            </remarks>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.StickyScheduleToStartTimeout">
            <summary>
            Optionally sets the sticky schedule to start timeout.  Defaults to <b>5 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.NonDeterministicWorkflowPolicy">
            <summary>
            Optionally sets how decision workers deals with non-deterministic history events,
            presumably arising from non-deterministic workflow definitions or non-backward compatible workflow definition changes.
            This defaults to <see cref="F:Neon.Temporal.NonDeterministicPolicy.BlockWorkflow"/> which 
            just logs error and does not fail the workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkerOptions.WorkerStopTimeout">
            <summary>
            Optionally sets the graceful shutdown timeout.  Defaults to zero.  Time is represented in nanoseconds.
            </summary>
        </member>
        <member name="T:Neon.Temporal.Workflow">
            <summary>
            Provides useful information and functionality for workflow implementations.
            This will be available via the <see cref="P:Neon.Temporal.WorkflowBase.Workflow"/> property.
            </summary>
        </member>
        <member name="F:Neon.Temporal.Workflow.DefaultVersion">
            <summary>
            The default workflow version returned by <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> 
            when a version has not been set yet.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.Current">
            <summary>
            Returns the <see cref="T:Neon.Temporal.Workflow"/> information for the worflow executing within the
            current asynchronous flow or <c>null</c> if the current code is not executing within
            the context of a workflow.  This property use an internal <see cref="T:System.Threading.AsyncLocal`1"/>
            to manage this state.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Workflow.#ctor(Neon.Temporal.WorkflowBase,Neon.Temporal.Worker,System.Int64,System.String,System.String,System.String,System.String,System.String,System.Boolean,Neon.Temporal.WorkflowMethodMap)">
            <summary>
            Constructor.
            </summary>
            <param name="parent">The parent workflow instance.</param>
            <param name="worker">The worker managing the workflow execution.</param>
            <param name="contextId">The workflow's context ID.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="namespace">The hosting namespace.</param>
            <param name="taskQueue">The hosting task queue.</param>
            <param name="workflowId">The workflow ID.</param>
            <param name="runId">The current workflow run ID.</param>
            <param name="isReplaying">Indicates whether the workflow is currently replaying from histor.</param>
            <param name="methodMap">Maps the workflow signal and query methods.</param>
        </member>
        <member name="P:Neon.Temporal.Workflow.WorkflowBase">
            <summary>
            Returns the parent <see cref="T:Neon.Temporal.WorkflowBase"/> implementation.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.ContextId">
            <summary>
            Returns the workflow's context ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.Client">
            <summary>
            Returns the <see cref="T:Neon.Temporal.TemporalClient"/> managing this workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.Worker">
            <summary>
            Returns the <see cref="P:Neon.Temporal.Workflow.Worker"/> managing this workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.Logger">
            <summary>
            Returns the logger to be used for logging workflow related events.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.WorkflowInfo">
            <summary>
            Returns information about the running workflow.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.MethodMap">
            <summary>
            Returns the workflow types method map.
            </summary>
        </member>
        <member name="P:Neon.Temporal.Workflow.SignalId">
            <summary>
            Returns the unique ID of the signal being called on the current task.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Workflow.GetNextActivityId">
            <summary>
            Returns the next available workflow local activity ID.
            </summary>
            <returns>The nextr ID.</returns>
        </member>
        <member name="P:Neon.Temporal.Workflow.IsReplaying">
            <summary>
            <para>
            Indicates whether the workflow code is being replayed.
            </para>
            <note>
            <b>WARNING:</b> Never have workflow logic depend on this flag as doing so will
            break determinism.  The only reasonable uses for this flag are for managing
            external things like logging or metric reporting.
            </note>
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="P:Neon.Temporal.Workflow.Execution">
            <summary>
            Returns the execution information for the current workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.Workflow.GetSignalStatus(System.String)">
            <summary>
            Returns the <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/> information for the specified
            signal ID, adding a status record if one doesn't already exist.
            </summary>
            <param name="signalId">The unique signal ID.</param>
            <returns>The <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/> for the signal.</returns>
        </member>
        <member name="M:Neon.Temporal.Workflow.SetStackTrace(System.Int32)">
            <summary>
            Handles saving the current stack trace to the parent <see cref="P:Neon.Temporal.WorkflowBase.StackTrace"/>
            property so this will be available for the internal stack trace query.
            </summary>
            <param name="skipFrames">
            The number of frames to skip.  This defaults to 2 such that this method's
            stack frame will be skipped along with the caller (presumably one the public
            methods in this class.
            </param>
        </member>
        <member name="M:Neon.Temporal.Workflow.ExecuteNonParallel``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Executes a Temporal workflow related operation, trying to detect
            when an attempt is made to perform more than one operation in 
            parallel, which will likely break workflow determinism.
            </summary>
            <typeparam name="TResult">The operation result type.</typeparam>
            <param name="actionAsync">The workflow action function.</param>
            <returns>The action result.</returns>
            <remarks>
            <note>
            This method performs the parallel check only when executing within
            the context of a workflow entry point method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.UpdateReplay``1(``0)">
            <summary>
            Updates the workflow's <see cref="P:Neon.Temporal.Workflow.IsReplaying"/> state to match the
            state specified in the reply from temporal-proxy.
            </summary>
            <typeparam name="TReply">The reply message type.</typeparam>
            <param name="reply">The reply message.</param>
        </member>
        <member name="M:Neon.Temporal.Workflow.UtcNowAsync">
            <summary>
            <para>
            Returns the current workflow time (UTC).
            </para>
            <note>
            This must used instead of calling <see cref="P:System.DateTime.UtcNow"/> or any other
            time method to guarantee determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The current workflow time.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.ContinueAsNewAsync(System.Object[])">
            <summary>
            Continues the current workflow as a new run using the same workflow options.
            </summary>
            <param name="args">The new run arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.ContinueAsNewAsync(Neon.Temporal.ContinueAsNewOptions,System.Object[])">
            <summary>
            Continues the current workflow as a new run allowing the specification of
            new workflow options.
            </summary>
            <param name="options">The continuation options.</param>
            <param name="args">The new run arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Used to implement backwards compatible changes to a workflow implementation.
            </summary>
            <param name="changeId">Identifies the change.</param>
            <param name="minSupported">
            Specifies the minimum supported version.  You may pass <see cref="F:Neon.Temporal.Workflow.DefaultVersion"/> <b>(-1)</b>
            which will be set as the version for workflows that haven't been versioned yet.
            </param>
            <param name="maxSupported">Specifies the maximum supported version.</param>
            <returns>The workflow implementation version.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            It is possible to upgrade workflow implementation with workflows in flight using
            the <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> method.  The essential requirement
            is that the new implementation must execute the same logic for the decision steps
            that have already been executed and recorded to the history fo a previous workflow 
            to maintain workflow determinism.  Subsequent unexecuted steps, are free to implement
            different logic.
            </para>
            <note>
            Temporal attempts to detect when replaying workflow performs actions that are different
            from those recorded as history and will fail the workflow when this occurs.
            </note>
            <para>
            Upgraded workflows will use <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> to indicate
            where upgraded logic has been inserted into the workflow.  You'll pass a <b>changeId</b>
            string that identifies the change being made.  This can be anything you wish as long as
            it's not empty and is unique for each change made to the workflow.  You'll also pass
            <b>minSupported</b> and <b>maxSupported</b> integers.  <b>minSupported</b> specifies the 
            minimum version of the workflow implementation that will be allowed to continue to
            run.  Workflows start out with their version set to <see cref="F:Neon.Temporal.Workflow.DefaultVersion"/>
            or <b>(-1)</b> and this will often be passed as <b>minSupported</b> such that upgraded
            workflow implementations will be able to take over newly scheduled workflows.  
            <b>maxSupported</b> essentially specifies the current (latest) version of the workflow 
            implementation. 
            </para>
            <para>
            When <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> called and is not being replayed
            from the workflow history, the method will record the <b>changeId</b> and <b>maxSupported</b>
            values to the workflow history.  When this is being replayed, the method will simply
            return the <b>maxSupported</b> value from the history.  Let's go through an example demonstrating
            how this can be used.  Let's say we start out with a simple two step workflow that 
            first calls <b>ActivityA</b> and then calls <b>ActivityB</b>:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task DoSomething()
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
            
                    await activities.ActivityAAsync();  
                    await activities.ActivityBAsync();  
                }
            }
            </code>
            <para>
            Now, let's assume that we need to replace the call to <b>ActivityA</b> with a call to
            <b>ActivityC</b>.  If there is no chance of any instances of <B>MyWorkflow</B> still
            being in flight, you could simply redepoy the recoded workflow:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task&lt;byte[]&gt; RunAsync(byte[] args)
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
            
                    await activities.ActivityCAsync();  
                    await activities.ActivityBAsync();
                }
            }
            </code>
            <para>
            But, if instances of this workflow may be in flight you'll need to deploy a backwards
            compatible workflow implementation that handles workflows that have already executed 
            <b>ActivityA</b> but haven't yet executed <b>ActivityB</b>.  You can accomplish this
            via:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task&lt;byte[]&gt; RunAsync(byte[] args)
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
                    var version    = await GetVersionAsync("Replace ActivityA", DefaultVersion, 1);    
            
                    switch (version)
                    {
                        case DefaultVersion:
                        
                            await activities.ActivityAAsync();  
                            break;
                            
                        case 1:
                        
                            await activities.ActivityCAsync();  // &lt;-- change
                            break;
                    }
                    
                    await activities.ActivityBAsync();  
                }
            }
            </code>
            <para>
            This upgraded workflow calls <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> passing
            <b>minSupported=DefaultVersion</b> and <b>maxSupported=1</b>  For workflow instances
            that have already executed <b>ActivityA</b>, <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/>
            will return <see cref="F:Neon.Temporal.Workflow.DefaultVersion"/> and we'll call <b>ActivityA</b>, which will match
            what was recorded in the history.  For workflows that have not yet executed <b>ActivityA</b>,
            <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> will return <b>1</b>, which we'll use as
            the indication that we can call <b>ActivityC</b>.
            </para>
            <para>
            Now, lets say we need to upgrade the workflow again and change the call for <b>ActivityB</b>
            to <b>ActivityD</b>, but only for workflows that have also executed <b>ActivityC</b>.  This 
            would look something like:
            </para>
            <code lang="C#">
            public class MyWorkflow : WorkflowBase
            {
                public async Task&lt;byte[]&gt; RunAsync(byte[] args)
                {
                    var activities = Workflow.NewActivityStub&lt;MyActivities&gt;();
                    var version    = await GetVersionAsync("Replace ActivityA", DefaultVersion, 1);    
            
                    switch (version)
                    {
                        case DefaultVersion:
                        
                            await activities.ActivityAAsync();  
                            break;
                            
                        case 1:
                        
                            await activities.ActivityCAsync();  // &lt;-- change
                            break;
                    }
                    
                    version = await GetVersionAsync("Replace ActivityB", 1, 2);    
            
                    switch (version)
                    {
                        case DefaultVersion:
                        case 1:
                        
                            await activities.ActivityBAsync();
                            break;
                            
                        case 2:
                        
                            await activities.ActivityDAsync();  // &lt;-- change
                            break;
                    }
                }
            }
            </code>
            <para>
            Notice that the second <see cref="M:Neon.Temporal.Workflow.GetVersionAsync(System.String,System.Int32,System.Int32)"/> call passed a different
            change ID and also that the version range is now <b>1..2</b>.  The version returned will be
            <see cref="F:Neon.Temporal.Workflow.DefaultVersion"/> or <b>1</b> if <b>ActivityA</b> and <b>ActivityB</b> were 
            recorded in the history or <b>2</b> if <b>ActivityC</b> was called.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.GetWorkflowExecutionAsync(System.Object)">
            <summary>
            Returns the <see cref="T:Neon.Temporal.WorkflowExecution"/> for a child workflow created via
            <see cref="M:Neon.Temporal.Workflow.NewChildWorkflowStub``1(Neon.Temporal.ChildWorkflowOptions,System.String)"/>
            or <see cref="M:Neon.Temporal.Workflow.NewExternalWorkflowStub(System.String,System.String)"/>.
            </summary>
            <param name="stub">The child workflow stub.</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown if the stub has not been started.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.MutableSideEffectAsync``1(System.String,System.Func{``0})">
            <summary>
            Calls the specified function and then searches the workflow history
            to see if a value was already recorded with the specified <paramref name="id"/>.
            If no value has been recorded for the <paramref name="id"/> or the
            value returned by the function will be recorded, replacing any existing
            value.  If the function value is the same as the history value, then
            nothing will be recorded.
            </summary>
            <typeparam name="T">Specifies the result type.</typeparam>
            <param name="id">Identifies the value in the workflow history.</param>
            <param name="function">The side effect function.</param>
            <returns>The latest value persisted to the workflow history.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it and it's also more efficient because it avoids
            recording the same value multiple times in the history.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return the default 
            value for <typeparamref name="T"/>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time 
            <see cref="M:Neon.Temporal.Workflow.MutableSideEffectAsync``1(System.String,System.Func{``0})"/>
            is called but it will ignore all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.MutableSideEffectAsync(System.Type,System.String,System.Func{System.Object})">
            <summary>
            <para>
            Calls the specified function and then searches the workflow history
            to see if a value was already recorded with the specified <paramref name="id"/>.
            If no value has been recorded for the <paramref name="id"/> or the
            value returned by the function will be recorded, replacing any existing
            value.  If the function value is the same as the history value, then
            nothing will be recorded.
            </para>
            <para>
            This version of the method uses a parameter to specify the expected
            result type.
            </para>
            </summary>
            <param name="resultType">Specifies the result type.</param>
            <param name="id">Identifies the value in the workflow history.</param>
            <param name="function">The side effect function.</param>
            <returns>The latest value persisted to the workflow history.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it and it's also more efficient because it avoids
            recording the same value multiple times in the history.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return <c>null</c>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time 
            <see cref="M:Neon.Temporal.Workflow.MutableSideEffectAsync(System.Type,System.String,System.Func{System.Object})"/>
            is called but it will ignore all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewGuidAsync">
            <summary>
            <para>
            Returns a replay safe <see cref="T:System.Guid"/>.
            </para>
            <note>
            This must be used instead of calling <see cref="M:System.Guid.NewGuid"/>
            to guarantee determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The new <see cref="T:System.Guid"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.NextRandomDoubleAsync">
            <summary>
            <para>
            Returns a replay safe random non-negative integer greater than or equal to a minimum value
            less than a maximum value that is greater than or equal to 0.0 and less than 1.0.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The next random double between: <c>0  &lt;= value &lt; 1.0</c></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NextRandomAsync">
            <summary>
            <para>
            Returns a replay safe random non-negative random integer.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <returns>The next random integer greater than or equal to 0</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NextRandomAsync(System.Int32)">
            <summary>
            <para>
            Returns a replay safe random non-negative integer less than a maximum value.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <param name="maxValue">The exclusive upper limit of the value returned.  This cannot be negative.</param>
            <returns>The next random integer between: <c>0  &lt;= value &lt; maxValue</c></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NextRandomAsync(System.Int32,System.Int32)">
            <summary>
            <para>
            Returns a replay safe random non-negative integer greater than or equal to a minimum value
            less than a maximum value.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <param name="minValue">The inclusive lower limit of the value returned (may be negative).</param>
            <param name="maxValue">The exclusive upper limit of the value returned (may be negative).</param>
            <returns>The next random integer between: <c>0  &lt;= value &lt; maxValue</c>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NextRandomBytesAsync(System.Int32)">
            <summary>
            <para>
            Returns a replay safe byte array filled with random values.
            </para>
            <note>
            This must be used instead of something like <see cref="T:System.Random"/> to guarantee 
            determinism when a workflow is replayed.
            </note>
            </summary>
            <param name="size">The size of the byte array returned (must be positive)..</param>
            <returns>The random bytes.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            The internal random number generator is seeded such that workflow instances
            will generally see different sequences of random numbers.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.SideEffectAsync``1(System.Func{``0})">
            <summary>
            Calls the specified function and records the value returned in the workflow
            history such that subsequent calls will return the same value.
            </summary>
            <typeparam name="T">Specifies the result type.</typeparam>
            <param name="function">The side effect function.</param>
            <returns>The value returned by the first function call.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return the default 
            value for <typeparamref name="T"/>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time <see cref="M:Neon.Temporal.Workflow.SideEffectAsync``1(System.Func{``0})"/>
            is called but it will ignore the all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.SideEffectAsync(System.Type,System.Func{System.Object})">
            <summary>
            Calls the specified function and records the value returned in the workflow
            history such that subsequent calls will return the same value.  This version
            specifies the expected result type as a parameter.
            </summary>
            <param name="resultType">Specifies the result type.</param>
            <param name="function">The side effect function.</param>
            <returns>The value returned by the first function call.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            This is similar to what you could do with a local activity but is
            a bit easier since you don't need to declare the activity and create
            a stub to call it.
            </para>
            <note>
            The function must return within the configured decision task timeout 
            and should avoid throwing exceptions.
            </note>
            <note>
            The function passed should avoid throwing exceptions.  When an exception
            is thrown, this method will catch it and simply return <c>null</c>.
            </note>
            <note>
            <para>
            The .NET version of this method currently works a bit differently than
            the Java and GOLANG clients which will only call the function once.
            The .NET implementation calls the function every time <see cref="M:Neon.Temporal.Workflow.SideEffectAsync(System.Type,System.Func{System.Object})"/>
            is called but it will ignore the all but the first call's result.
            </para>
            <para>
            This is an artifact of how the .NET client is currently implemented
            and may change in the future.  You should take care not to code your
            application to depend on this behavior (one way or the other).
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.SleepAsync(System.TimeSpan)">
            <summary>
            Pauses the workflow for at least the specified interval.
            </summary>
            <param name="duration">The duration to pause.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            This must be used instead of calling <see cref="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)"/> or <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)"/>
            to guarantee determinism when a workflow is replayed.
            </note>
            <note>
            Temporal time interval resolution is limited to whole seconds and
            the duration will be rounded up to the nearest second and the 
            workflow may resumed sometime after the requested interval 
            depending on how busy the registered workers are and how long
            it takes to actually wake the workflow.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.SleepUntilUtcAsync(System.DateTime)">
            <summary>
            Pauses the workflow until at least the specified time (UTC).
            </summary>
            <param name="wakeTimeUtc">The wake time (UTC).</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/></returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            Temporal timers have a resolution of only one second at this time
            and due to processing delays, it's very possible that the workflow
            will wake several seconds later than scheduled.  You should not
            depend on time resolutions less than around 10 seconds.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.HasLastCompletionResultAsync">
            <summary>
            Determines whether a previous run of the current CRON workflow completed
            and returned a result.
            </summary>
            <returns><c>true</c> if the a previous CRON workflow run returned a result.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.GetLastCompletionResultAsync``1">
            <summary>
            Returns the result of the last run of the current CRON workflow or
            <c>null</c>.  This is useful for CRON workflows that would like to
            pass information from from one workflow run to the next.
            </summary>
            <typeparam name="TResult">The expected result type.</typeparam>
            <returns>The previous run result as bytes or <c>null</c>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewActivityStub``1(Neon.Temporal.ActivityOptions)">
            <summary>
            Creates a client stub that can be used to launch one or more activity instances
            via the type-safe interface methods.
            </summary>
            <typeparam name="TActivityInterface">The activity interface.</typeparam>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The new <see cref="T:Neon.Temporal.ActivityStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            Unlike workflow stubs, a single activity stub instance can be used to
            launch multiple activities.
            </note>
            <para>
            Activities launched by the returned stub will be scheduled normally
            by Temporal to executed on one of the worker nodes.  Use 
            <see cref="M:Neon.Temporal.Workflow.NewLocalActivityStub``2(Neon.Temporal.LocalActivityOptions)"/>
            to execute short-lived activities locally within the current process.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewExternalActivityStub(System.String,Neon.Temporal.ActivityOptions)">
            <summary>
            Creates an untyped client stub that can be used to launch one or more activity
            instances using a specific activity type name.  This is typically used to launch
            activities written in other languages.
            </summary>
            <param name="activityTypeName">Specifies the target activity type name.</param>
            <param name="options">Optionally specifies the activity options.</param>
            <returns>The untyped <see cref="T:Neon.Temporal.ActivityStub"/> you'll use to execute the activity.</returns>
            <remarks>
            <para>
            <paramref name="activityTypeName"/> specifies the target activity implementation type name and optionally,
            the specific activity method to be called for activity interfaces that have multiple methods.  For
            activity methods tagged by <c>ActivityMethod]</c>[ with specifying a name, the activity type name will default
            to the fully qualified interface type name or the custom type name specified by <see cref="P:Neon.Temporal.ActivityAttribute.Name"/>.
            </para>
            <para>
            For activity methods with <see cref="P:Neon.Temporal.ActivityMethodAttribute.Name"/> specified, the activity type will
            look like:
            </para>
            <code>
            ACTIVITY-TYPE-NAME::METHOD-NAME
            </code>
            <note>
            You may need to customize activity type name when interoperating with activities written
            in other languages.  See <a href="https://doc.neonkube.com/Neon.Temporal-CrossPlatform.htm">Temporal Cross-Platform</a>
            for more information.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewChildWorkflowStub``1(Neon.Temporal.ChildWorkflowOptions,System.String)">
            <summary>
            Creates a workflow client stub that can be used to launch, signal, and query child
            workflows via the type-safe workflow interface methods.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="options">Optionally specifies the child workflow options.</param>
            <param name="workflowTypeName">
            Optionally specifies the workflow type name by overriding the fully 
            qualified <typeparamref name="TWorkflowInterface"/> type name or the name
            specified by a <see cref="T:Neon.Temporal.WorkflowAttribute"/>.
            </param>
            <returns>The child workflow stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewContinueAsNewStub``1(Neon.Temporal.ContinueAsNewOptions)">
            <summary>
            Creates a typed-safe client stub that can be used to continue the workflow as a new run.
            </summary>
            <typeparam name="TWorkflowInterface">The workflow interface.</typeparam>
            <param name="options">Optionally specifies the new options to use when continuing the workflow.</param>
            <returns>The type-safe stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            The workflow stub returned is intended just for continuing the workflow by
            calling one of the workflow entry point methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            Any signal or query methods defined by <typeparamref name="TWorkflowInterface"/> will 
            throw a <see cref="T:System.InvalidOperationException"/> when called.
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewExternalWorkflowStub(Neon.Temporal.WorkflowExecution)">
            <summary>
            Creates a workflow client stub that can be used communicate with an
            existing workflow identified by a <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <param name="execution">Identifies the workflow.</param>
            <returns>The workflow stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewExternalWorkflowStub(System.String,System.String)">
            <summary>
            Creates a workflow client stub that can be used communicate with an
            existing workflow identified by a workflow ID and optional namespace.
            </summary>
            <param name="workflowId">Identifies the workflow.</param>
            <param name="namespace">Optionally overrides the parent workflow namespace.</param>
            <returns>The workflow stub.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewLocalActivityStub``2(Neon.Temporal.LocalActivityOptions)">
            <summary>
            Creates a client stub that can be used to launch one or more local activity 
            instances via the type-safe interface methods.
            </summary>
            <typeparam name="TActivityInterface">The activity interface.</typeparam>
            <typeparam name="TActivityImplementation">The activity implementation.</typeparam>
            <param name="options">Optionally specifies activity options.</param>
            <returns>The new <see cref="T:Neon.Temporal.ActivityStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            Unlike workflow stubs, a single activity stub instance can be used to
            launch multiple activities.
            </note>
            <para>
            Activities launched by the returned stub will be executed in the current
            process.  This is intended to easily and efficiently execute activities
            that will complete very quickly (usually within a few seconds).  Local
            activities are similar to normal activities with these differences:
            </para>
            <list type="bullet">
                <item>
                Local activities are always scheduled to executed within the current process.
                </item>
                <item>
                Local activity types do not need to be registered with the worker.
                </item>
                <item>
                Local activities must complete within the <see cref="P:Neon.Temporal.StartWorkflowOptions.WorkflowTaskTimeout"/>.
                This defaults to 10 seconds and can be set to a maximum of 60 seconds.
                </item>
                <item>
                Local activities cannot heartbeat.
                </item>
            </list>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewChildWorkflowFutureStub``1(System.String,Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Creates a specialized stub suitable for starting and running a child workflow in parallel
            with other workflow operations such as child workflows or activities.
            </summary>
            <typeparam name="TWorkflowInterface">The target workflow interface.</typeparam>
            <param name="methodName">
            Optionally identifies the target workflow method.  This is the name specified in
            <c>[WorkflowMethod]</c> attribute for the workflow method or <c>null</c>/empty for
            the default workflow method.
            </param>
            <param name="options">Optionally specifies custom <see cref="T:Neon.Temporal.ChildWorkflowOptions"/>.</param>
            <returns>A <see cref="T:Neon.Temporal.ChildWorkflowStub`1"/> instance.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            Sometimes workflows need to run child workflows in parallel with other child workflows or
            activities.  Although the typed workflow stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
            workflow developers are required to immediately <c>await</c> every call to these stubs to 
            ensure that the workflow will execute consistently when replayed from history.  This 
            means that you must not do something like this:
            </para>
            <code language="C#">
            public interface IMyWorkflow : IWorkflow
            {
                [WorkflowMethod]
                Task MainAsync();
                
                [WorkflowMethod(Name = "child")]
                Task&lt;string&gt; ChildAsync(string arg);
            }
            
            public class MyWorkflow : WorkflowBase, IMyWorkflow
            {
                public Task MainAsync()
                {
                    var stub1     = Workflow.NewChildWorkflowStub&lt;IMyWorkflow&gt;("FOO");
                    var childTask = stub1.DoChildWorkflow();
                    var stub2     = Workflow.NewChildWorkflowStub&lt;IMyWorkflow&gt;();
                    var value2    = await stub2.DoChildWorkflow("BAR");
                    var value1    = await childTask;
                }
                
                public Task&lt;string&gt; ChildAsync(string arg)
                {
                    return await Task.FromResult(arg);
                }
            }
            </code>
            <para>
            The <c>MainAsync()</c> workflow method here creates and starts a child workflow, but it 
            doesn't immediately <c>await</c> it.  It then runs another child workflow in parallel 
            and then after the second child returns, the workflow awaits the first child.  This pattern 
            is not supported by <b>Neon.Temporal</b> because all workflow related operations need to 
            be immediately awaited to ensure that operations will complete in a consistent order when
            workflows are replayed.
            </para>
            <note>
            The reason for this restriction is related to how the current <b>Neon.Temporal</b> implementation
            uses an embedded GOLANG Temporal client to actually communicate with a Temporal cluster.  This
            may be relaxed in the future if/when we implement native support for the Temporal protocol.
            </note>
            <para>
            A correct implementation would look something like this:
            </para>
            <code language="C#">
            public interface IMyWorkflow : IWorkflow
            {
                [WorkflowMethod]
                Task MainAsync();
                
                [WorkflowMethod(Name = "child")]
                Task&lt;string&gt; ChildAsync(string arg);
            }
            
            public class MyWorkflow : WorkflowBase, IMyWorkflow
            {
                public Task MainAsync()
                {
                    var stub1  = Workflow.NewChildWorkflowFutureStub&lt;IMyWorkflow&gt;("child");
                    var future = await stub1.StartAsync$lt;string&gt;("FOO");   // Starting the child with param: "FOO"
                    var stub2  = Workflow.NewChildWorkflowStub&lt;IMyWorkflow&gt;();
                    var value2 = await stub2.DoChildWorkflow("BAR");            // This returns: "BAR"
                    var value1 = await future.GetAsync();                       // This returns: "FOO"
                }
                
                public Task&lt;string&gt; ChildAsync(string arg)
                {
                    return await Task.FromResult(arg);
                }
            }
            </code>
            <para>
            Here we call <see cref="M:Neon.Temporal.Workflow.NewChildWorkflowFutureStub``1(System.String,Neon.Temporal.ChildWorkflowOptions)"/> specifying
            <b>"child"</b> as the workflow method name.  This matches the <c>[WorkflowMethod(Name = "child")]</c>
            attribute decorating the <c>ChildAsync()</c> workflow interface method.  Then we start the child workflow by awaiting 
            <see cref="M:Neon.Temporal.ChildWorkflowStub`1.StartAsync(System.Object[])"/>. This returns an <see cref="T:Neon.Temporal.ChildWorkflowFuture`1"/> whose 
            <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the workflow result.  The code above calls this to retrieve the 
            result from the first child after executing the second child in parallel.
            </para>
            <note>
            <para>
            You must take care to pass parameters that match the target method.  <b>Neon.Temporal</b> does check these at
            runtime, but there is no compile-time checking.
            </para>
            <para>
            You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
            This method always returns the <c>object</c> type even if referenced workflow and activity methods return
            <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
            </para>
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewUntypedChildWorkflowFutureStub(System.String,Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Creates an untyped child workflow stub that can be used to start, signal, and wait
            for the child workflow completion.  Use this version for child workflows that
            don't return a value.
            </summary>
            <param name="workflowTypeName">The workflow type name (see the remarks).</param>
            <param name="options">Optionally specifies the child workflow options.</param>
            <returns>The <see cref="T:Neon.Temporal.ChildWorkflowFutureStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </para>
            <para>
            <paramref name="workflowTypeName"/> specifies the target workflow type name.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewUntypedChildWorkflowFutureStub``1(System.String,Neon.Temporal.ChildWorkflowOptions)">
            <summary>
            Creates an untyped child workflow stub that can be used to start, signal, and wait
            for the child workflow completion.  Use this version for child workflows that
            return a value.
            </summary>
            <typeparam name="TResult">Specifies the child workflow result type.</typeparam>
            <param name="workflowTypeName">The workflow type name (see the remarks).</param>
            <param name="options">Optionally specifies the child workflow options.</param>
            <returns>The <see cref="T:Neon.Temporal.ChildWorkflowFutureStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            Unlike activity stubs, a workflow stub may only be used to launch a single
            workflow.  You'll need to create a new stub for each workflow you wish to
            invoke and then the first method called on a workflow stub must be
            the one of the methods tagged by <see cref="T:Neon.Temporal.WorkflowMethodAttribute"/>.
            </para>
            <para>
            <paramref name="workflowTypeName"/> specifies the target workflow type name.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewUntypedExternalWorkflowStub(Neon.Temporal.WorkflowExecution,System.String)">
            <summary>
            Creates an untyped stub that can be used to signal or cancel a child
            workflow identified by its <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <param name="execution">The target <see cref="T:Neon.Temporal.WorkflowExecution"/>.</param>
            <param name="namespace">Optionally specifies the target namespace.  This defaults to the parent workflow's namespace.</param>
            <returns>The <see cref="T:Neon.Temporal.ExternalWorkflowStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewUntypedExternalWorkflowStub(System.String,System.String)">
            <summary>
            Creates an untyped stub that can be used to signal or cancel a child
            workflow identified by its workflow ID.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="namespace">Optionally specifies the target namespace.  This defaults to the parent workflow's namespace.</param>
            <returns>The <see cref="T:Neon.Temporal.ExternalWorkflowStub"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewActivityFutureStub``1(System.String,Neon.Temporal.ActivityOptions)">
             <summary>
             Creates a specialized stub suitable for starting and running an activity in parallel
             with other workflow operations such as child workflows or activities.
             </summary>
             <typeparam name="TActivityInterface">The activity interface.</typeparam>
             <param name="methodName">
             Optionally identifies the target activity method.  This is the name specified in
             <c>[ActivityMethod]</c> attribute for the activity method or <c>null</c>/empty for 
             the default activity method.
             </param>
             <param name="options">Optionally specifies the activity options.</param>
             <returns>The new <see cref="T:Neon.Temporal.ActivityFutureStub`1"/>.</returns>
             <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
             <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
             <remarks>
             <para>
             Sometimes workflows need to run activities in parallel with other child workflows or
             activities.  Although the standard stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
             workflow developers are required to immediately <c>await</c> every call to these stubs to 
             ensure that the workflow will execute consistently when replayed from history.  This 
             means that you must not do something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "activity-1"]
                 Task&lt;string&gt; FooActivityAsync(string arg);
                 
                 [ActivityMethod(Name = "activity-2"]
                 Task&lt;string&gt; BarActivityAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var stub     = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var fooTask  = stub.FooActivity("FOO");
                     var barValue = await stub.BarActivityAsync("BAR");
                     var fooValue = await fooTask;
                 }
             }
             </code>
             <para>
             The <c>MainAsync()</c> workflow method here starts an activity but doesn't immediately
             <c>await</c> it.  It then runs another activity in parallel and then after the second 
             activity returns, the workflow awaits the first activity.  This pattern is not supported 
             by <b>Neon.Temporal</b> because all workflow related operations need to be immediately
             awaited to ensure that operations will complete in a consistent order when workflows 
             are replayed.
             </para>
             <note>
             The reason for this restriction is related to how the current <b>Neon.Temporal</b> implementation
             uses an embedded GOLANG Temporal client to actually communicate with a Temporal cluster.  This
             may be relaxed in the future if/when we implement native support for the Temporal protocol.
             </note>
             <para>
             A correct implementation would look something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "foo"]
                 Task&lt;string&gt; FooAsync(string arg);
                 
                 [ActivityMethod(Name = "bar"]
                 Task&lt;string&gt; BarAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var fooStub  = Workflow.NewActivityFutureStub("foo");
                     var future   = fooStub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarAsync("BAR");   // Returns: "BAR"
                     var fooValue = await future.GetAsync();         // Returns: "FOO"
                 }
             }
             </code>
             <para>
             Here we call <see cref="M:Neon.Temporal.Workflow.NewActivityFutureStub``1(System.String,Neon.Temporal.ActivityOptions)"/> specifying
             <b>"foo"</b> as the workflow method name.  This matches the <c>[ActivityMethod(Name = "foo")]</c> decorating
             the <c>FooAsync()</c> activity interface method.  Then we start the first activity by awaiting 
             <see cref="T:Neon.Temporal.ActivityFutureStub`1"/>.  This returns an <see cref="T:Neon.Tasks.IAsyncFuture`1"/> whose 
             <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the activity result.  The code above calls this to
             retrieve the result from the first activity after executing the second activity in parallel.
             </para>
             <note>
             <para>
             You must take care to pass parameters that match the target method.  <b>Neon.Temporal</b> does check these at
             runtime, but there is no compile-time checking for this scheme.
             </para>
             <para>
             You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
             This method always returns the <c>object</c> type even if referenced workflow and activity methods return
             <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
             </para>
             </note>
             </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewActivityFutureStub(System.String,Neon.Temporal.ActivityOptions)">
             <summary>
             Creates a specialized untyped stub suitable for starting and running an activity in parallel
             with other workflow operations such as child workflows or activities.  This is typically
             used for executing activities written in another language.
             </summary>
             <param name="activityTypeName">Specifies the target activity type name.</param>
             <param name="options">Optionally specifies the activity options.</param>
             <returns>The new untyped <see cref="T:Neon.Temporal.ActivityFutureStub"/>.</returns>
             <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
             <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
             <remarks>
             <para>
             Sometimes workflows need to run activities written in other languages in parallel with other
             child workflows or activities.  Although the standard stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
             workflow developers are required to immediately <c>await</c> every call to these stubs to 
             ensure that the workflow will execute consistently when replayed from history.  This 
             means that you must not do something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "activity-1"]
                 Task&lt;string&gt; FooActivityAsync(string arg);
                 
                 [ActivityMethod(Name = "activity-2"]
                 Task&lt;string&gt; BarActivityAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var stub     = Workflow.NewActivityStub("MyActivity::FooActivityAsync");
                     var fooTask  = stub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarActivityAsync("BAR");
                     var fooValue = await fooTask;
                 }
             }
             </code>
             <para>
             The <c>MainAsync()</c> workflow method here starts an activity but doesn't immediately
             <c>await</c> it.  It then runs another activity in parallel and then after the second 
             activity returns, the workflow awaits the first activity.  This pattern is not supported 
             by <b>Neon.Temporal</b> because all workflow related operations need to be immediately
             awaited to ensure that operations will complete in a consistent order when workflows 
             are replayed.
             </para>
             <note>
             The reason for this restriction is related to how the current <b>Neon.Temporal</b> implementation
             uses an embedded GOLANG Temporal client to actually communicate with a Temporal cluster.  This
             may be relaxed in the future if/when we implement native support for the Temporal protocol.
             </note>
             <para>
             A correct implementation would look something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "foo"]
                 Task&lt;string&gt; FooAsync(string arg);
                 
                 [ActivityMethod(Name = "bar"]
                 Task&lt;string&gt; BarAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var fooStub  = Workflow.NewActivityFutureStub("foo");
                     var future   = await fooStub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarAsync("BAR");   // Returns: "BAR"
                     var fooValue = await future.GetAsync();         // Returns: "FOO"
                 }
             }
             </code>
             <para>
             Here we call <see cref="M:Neon.Temporal.Workflow.NewActivityFutureStub(System.String,Neon.Temporal.ActivityOptions)"/> specifying
             <b>"foo"</b> as the workflow method name.  This matches the <c>[ActivityMethod(Name = "foo")]</c> decorating
             the <c>FooAsync()</c> activity interface method.  Then we start the first activity by awaiting 
             <see cref="T:Neon.Temporal.ActivityFutureStub`1"/>.  This returns an <see cref="T:Neon.Tasks.IAsyncFuture`1"/> whose 
             <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the activity result.  The code above calls this to
             retrieve the result from the first activity after executing the second activity in parallel.
             </para>
             <note>
             <para>
             You must take care to pass parameters that match the target method.  <b>Neon.Temporal</b> does check these at
             runtime, but there is no compile-time checking for this scheme.
             </para>
             <para>
             You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
             This method always returns the <c>object</c> type even if referenced workflow and activity methods return
             <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
             </para>
             </note>
             </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewStartLocalActivityStub``2(System.String,Neon.Temporal.LocalActivityOptions)">
             <summary>
             Creates a specialized stub suitable for starting and running a local activity in parallel
             with other workflow operations such as child workflows or activities.
             </summary>
             <typeparam name="TActivityInterface">Specifies the activity interface.</typeparam>
             <typeparam name="TActivityImplementation">Specifies the local activity implementation class.</typeparam> 
             <param name="methodName">
             Optionally identifies the target activity method.  This is the name specified in
             <c>[ActivityMethod]</c> attribute for the activity method or <c>null</c>/empty for
             the default activity method.
             </param>
             <param name="options">Optionally specifies the local activity options.</param>
             <returns>The new <see cref="M:Neon.Temporal.Workflow.NewStartLocalActivityStub``2(System.String,Neon.Temporal.LocalActivityOptions)"/>.</returns>
             <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
             <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
             <remarks>
             <para>
             Sometimes workflows need to run local activities in parallel with other child workflows or
             activities.  Although the standard stubs return a <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.Task`1"/>,
             workflow developers are required to immediately <c>await</c> every call to these stubs to 
             ensure that the workflow will execute consistently when replayed from history.  This 
             means that you must not do something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "activity-1"]
                 Task&lt;string&gt; FooActivityAsync(string arg);
                 
                 [ActivityMethod(Name = "activity-2"]
                 Task&lt;string&gt; BarActivityAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarActivityAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var stub     = Workflow.NewLocalActivityStub&lt;IMyActivity, MyActivity&gt;();
                     var fooTask  = stub.FooActivity("FOO");
                     var barValue = await stub.BarActivityAsync("BAR");
                     var fooValue = await fooTask;
                 }
             }
             </code>
             <para>
             The <c>MainAsync()</c> workflow method here starts a local activity but doesn't immediately
             <c>await</c> it.  It then runs another activity in parallel and then after the second 
             activity returns, the workflow awaits the first activity.  This pattern is not supported 
             by <b>Neon.Temporal</b> because all workflow related operations need to be immediately
             awaited to ensure that operations will complete in a consistent order when workflows 
             are replayed.
             </para>
             <note>
             The reason for this restriction is related to how the current <b>Neon.Temporal</b> implementation
             uses an embedded GOLANG Temporal client to actually communicate with a Temporal cluster.  This
             may be relaxed in the future if/when we implement native support for the Temporal protocol.
             </note>
             <para>
             A correct implementation would look something like this:
             </para>
             <code language="C#">
             public interface IMyActivity : IActivity
             {
                 [ActivityMethod(Name = "foo"]
                 Task&lt;string&gt; FooAsync(string arg);
                 
                 [ActivityMethod(Name = "bar"]
                 Task&lt;string&gt; BarAsync(string arg);
             }
             
             public MyActivity : ActivityBase, IMyActivity
             {
                 public Task&lt;string&gt; FooAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
                 
                 public Task&lt;string&gt; BarAsync(string arg)
                 {
                     await Task.FromResult(arg);
                 }
             }
            
             public class MyWorkflow : WorkflowBase, IMyWorkflow
             {
                 [WorkflowMethod]
                 public Task MainAsync()
                 {
                     var fooStub  = Workflow.NewStartLocalActivityStub("foo");
                     var future   = fooStub.StartAsync&lt;string&gt;("FOO");
                     var barStub  = Workflow.NewActivityStub&lt;IMyActivity&gt;();
                     var barValue = await barStub.BarAsync("BAR");   // Returns: "BAR"
                     var fooValue = await future.GetAsync();         // Returns: "FOO"
                 }
             }
             </code>
             <para>
             Here we call <see cref="M:Neon.Temporal.Workflow.NewActivityFutureStub``1(System.String,Neon.Temporal.ActivityOptions)"/> specifying
             <b>"foo"</b> as the workflow method name.  This matches the <c>[ActivityMethod(Name = "foo")]</c> decorating
             the <c>FooAsync()</c> activity interface method.  Then we start the first activity by awaiting 
             <see cref="T:Neon.Temporal.ActivityFutureStub`1"/>.  This returns an <see cref="T:Neon.Tasks.IAsyncFuture`1"/> whose 
             <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> method returns the activity result.  The code above calls this to
             retrieve the result from the first activity after executing the second activity in parallel.
             </para>
             <note>
             <para>
             You must take care to pass parameters that match the target method.  <b>Neon.Temporal</b> does check these at
             runtime, but there is no compile-time checking for this scheme.
             </para>
             <para>
             You'll also need to cast the <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> result to the actual type (if required).
             This method always returns the <c>object</c> type even if referenced workflow and activity methods return
             <c>void</c>.  <see cref="M:Neon.Tasks.IAsyncFuture.GetAsync"/> will return <c>null</c> in these cases.
             </para>
             </note>
             </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.NewQueueAsync``1(System.Int32)">
            <summary>
            Creates a new workflow safe queue.  These are typically used by workflow signal
            methods for communicating with the workflow logic.
            </summary>
            <typeparam name="T">Specifies the queued data type.</typeparam>
            <param name="capacity">
            <para>
            Specifies the maximum number items the queue may hold.
            </para>
            <note>
            This defaults to <see cref="F:Neon.Temporal.WorkflowQueue`1.DefaultCapacity"/>.
            </note>
            </param>
            <returns>The new <see cref="T:Neon.Temporal.WorkflowQueue`1"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <para>
            You may write and read data items from the returned queue.  Writes
            will block when the queue is full until an item has been read, freeing
            a slot.
            </para>
            <note>
            Items will be serialized internally using the current <see cref="T:Neon.Temporal.IDataConverter"/> to
            bytes before actually enqueuing the item.  This serialized data must be less
            than 64KiB.
            </note>
            <para>
            See <see cref="T:Neon.Temporal.WorkflowQueue`1"/> for more information.
            </para>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.Workflow.ExecuteActivityAsync(System.String,System.Byte[],Neon.Temporal.ActivityOptions)">
            <summary>
            Executes an activity with a specific activity type name and waits for it to complete.
            </summary>
            <param name="activityTypeName">Identifies the activity.</param>
            <param name="args">Specifies the encoded activity arguments or <c>null</c> when there are no arguments.</param>
            <param name="options">Specifies the activity options.</param>
            <returns>The activity result encoded as a byte array.</returns>
            <exception cref="T:Neon.Temporal.TemporalException">
            An exception derived from <see cref="T:Neon.Temporal.TemporalException"/> will be be thrown 
            if the child workflow did not complete successfully.
            </exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the Temporal namespace does not exist.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal cluster problems.</exception>
            <exception cref="T:Neon.Temporal.ServiceBusyException">Thrown when Temporal is too busy.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.RegisterActivityAction(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo)">
            <summary>
            Registers a local activity type and method with the workflow and returns 
            its local activity action ID.
            </summary>
            <param name="activityType">The activity type.</param>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityMethod">The target local activity method.</param>
            <returns>The new local activity action ID.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.ExecuteLocalActivityAsync(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo,System.Byte[],Neon.Temporal.LocalActivityOptions)">
            <summary>
            Executes a local activity and waits for it to complete.
            </summary>
            <param name="activityType">The activity type.</param>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityMethod">The target local activity method.</param>
            <param name="args">Specifies specifies the encoded activity arguments or <c>null</c> when there are no arguments.</param>
            <param name="options">Specifies the local activity options.</param>
            <returns>The activity result encoded as a byte array.</returns>
            <exception cref="T:Neon.Temporal.TemporalException">
            An exception derived from <see cref="T:Neon.Temporal.TemporalException"/> will be be thrown 
            if the child workflow did not complete successfully.
            </exception>
            <remarks>
            This method can be used to optimize activities that will complete quickly
            (within seconds).  Rather than scheduling the activity on any worker that
            has registered an implementation for the activity, this method will simply
            instantiate an instance of <paramref name="activityType"/> and call its
            <paramref name="activityMethod"/> method.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
            <exception cref="T:Neon.Temporal.EntityNotExistsException">Thrown if the Temporal namespace does not exist.</exception>
            <exception cref="T:Neon.Temporal.BadRequestException">Thrown when the request is invalid.</exception>
            <exception cref="T:Neon.Temporal.InternalServiceException">Thrown for internal Temporal cluster problems.</exception>
            <exception cref="T:Neon.Temporal.ServiceBusyException">Thrown when Temporal is too busy.</exception>
        </member>
        <member name="M:Neon.Temporal.Workflow.ForceReplayAsync">
            <summary>
            Forces the current workflow execution to terminate such that it will be rescheduled
            and replayed as required.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.WorkflowAttribute">
            <summary>
            Used to tag workflow implementations that inherit from
            <see cref="T:Neon.Temporal.WorkflowBase"/> to customize the how the workflow is
            registered.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowAttribute.AutoRegister">
            <summary>
            Indicates that <see cref="M:Neon.Temporal.Worker.RegisterAssemblyWorkflowsAsync(System.Reflection.Assembly,System.Boolean)"/> will
            automatically register the tagged workflow implementation for the specified assembly.
            This defaults to <c>false</c>
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowBase">
            <summary>
            Base class that must be inherited for all workflow implementations.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowBase.CallContext">
            <summary>
            Holds ambient task state indicating whether the current task executing
            in the context of a workflow entry point, signal, or query.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowBase.CheckCallContext(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Ensures that the current <see cref="T:System.Threading.Tasks.Task"/> is running within the context of a workflow 
            entry point, signal, or query method and also that the context matches one of the parameters
            indicating which contexts are allowed.  This is used ensure that only workflow operations
            that are valid for a context are allowed.
            </summary>
            <param name="allowWorkflow">Optionally indicates that calls from workflow entry point contexts are allowed.</param>
            <param name="allowQuery">Optionally indicates that calls from workflow query contexts are allowed.</param>
            <param name="allowSignal">Optionally indicates that calls from workflow signal contexts are allowed.</param>
            <param name="allowActivity">Optionally indicates that calls from activity contexts are allowed.</param>
            <exception cref="T:System.NotSupportedException">Thrown when the operation is not supported in the current context.</exception>
        </member>
        <member name="P:Neon.Temporal.WorkflowBase.StackTrace">
            <summary>
            This field holds the stack trace for the most recent decision related 
            <see cref="P:Neon.Temporal.WorkflowBase.Workflow"/> method calls.  This will be returned for internal
            workflow <b>"__stack_trace"</b> queries.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowBase.HasSynchronousSignals">
            <summary>
            Indicates that the workflow implements one or more synchronous signals.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowBase.Workflow">
            <summary>
            Returns a <see cref="P:Neon.Temporal.WorkflowBase.Workflow"/> instance with utilty methods you'll use
            for implementing your workflows.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowBase.WaitForPendingWorkflowOperationsAsync">
            <summary>
            Waits for any pending workflow operations (like outstanding synchronous signals) to 
            complete.  This is called before returning from a workflow method.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowBase.RegisterActivityAction(System.Type,System.Reflection.ConstructorInfo,System.Reflection.MethodInfo)">
            <summary>
            Registers a local activity type and method with the workflow and returns 
            its local activity action ID.
            </summary>
            <param name="activityType">The activity type.</param>
            <param name="activityConstructor">The activity constructor.</param>
            <param name="activityMethod">The target local activity method.</param>
            <returns>The new local activity action ID.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated Temporal client is disposed.</exception>
        </member>
        <member name="M:Neon.Temporal.WorkflowBase.GetActivityAction(System.Int64)">
            <summary>
            Retrieves the <see cref="T:Neon.Temporal.Internal.LocalActivityAction"/> for the specified activity type ID.
            </summary>
            <param name="activityTypeId">The activity type ID.</param>
            <returns>The corresponding <see cref="T:Neon.Temporal.Internal.LocalActivityAction"/> or <c>null</c>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowBase.GetSignalStatus(System.String)">
            <summary>
            Returns the <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/> for the specified workflow and signal.
            </summary>
            <param name="signalId">The target signal ID.</param>
            <returns>The <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/> for the signal.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowBase.SetSignalStatus(System.String,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean@)">
            <summary>
            Creates a new signal status record for the specified signal ID if no signal
            status already exists.
            </summary>
            <param name="signalId">The signal ID.</param>
            <param name="args">The signal arguments.</param>
            <param name="newSignal">Returns as <c>true</c> if the signal status was created by the method.</param>
            <returns>The new <see cref="T:Neon.Temporal.Internal.SyncSignalStatus"/> instance or the preexisting one.</returns>
        </member>
        <member name="T:Neon.Temporal.WorkflowCloseStatus">
            <summary>
            Enumerates the possible reasons why a workflow was closed.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowCloseStatus.Completed">
            <summary>
            The workflow completed successfully.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowCloseStatus.Failed">
            <summary>
            The workflow failed.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowCloseStatus.Cancelled">
            <summary>
            The workflow was cancelled.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowCloseStatus.Terminated">
            <summary>
            The workflow was terminated.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowCloseStatus.ContinuedAsNew">
            <summary>
            The workflow was continued as new.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowCloseStatus.Timedout">
            <summary>
            The workflow timed out.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowExecution">
            <summary>
            Describes the state of an executed workflow.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowExecution.#ctor">
            <summary>
            Defaulty constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowExecution.#ctor(System.String,System.String)">
            <summary>
            Internal constructor.
            </summary>
            <param name="workflowId">The original ID for the workflow.</param>
            <param name="runId">Optionally specifies the current run ID for the workflow.</param>
        </member>
        <member name="P:Neon.Temporal.WorkflowExecution.WorkflowId">
            <summary>
            Returns the current ID for workflow execution.  This will be different
            than <see cref="P:Neon.Temporal.WorkflowExecution.RunId"/> when the workflow has been continued as new
            or potentially restarted.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowExecution.RunId">
            <summary>
            The original ID assigned to the workflow when it was started.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowFutureStub`1">
            <summary>
            <para>
            Manages starting, signalling, or querying an external workflow instance
            based on its workflow type name and arguments.  This class separates workflow 
            execution and retrieving the result into separate operations.
            </para>
            <para>
            Use this version for workflows that don't return a result.
            </para>
            </summary>
            <typeparam name="WorkflowInterface">Specifies the workflow interface.</typeparam>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.#ctor(Neon.Temporal.TemporalClient,System.String,Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Internal constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="methodName">
            Optionally identifies the target workflow method by the name specified in
            the <c>[WorkflowMethod]</c> attribute tagging the method.  Pass a <c>null</c>
            or empty string to target the default method.
            </param>
            <param name="options">Optional workflow options.</param>
        </member>
        <member name="P:Neon.Temporal.WorkflowFutureStub`1.Execution">
            <summary>
            Returns the workflow <see cref="T:Neon.Temporal.WorkflowExecution"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the workflow has not been started.</exception>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.StartAsync(System.Object[])">
            <summary>
            Starts the workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the the workflow to complete.  This version does not return a workflow
            result.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Temporal.ExternalWorkflowFuture"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.StartAsync``1(System.Object[])">
            <summary>
            Starts the workflow, returning an <see cref="T:Neon.Tasks.IAsyncFuture"/> that can be used
            to wait for the the workflow to complete and obtain its result.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The workflow arguments.</param>
            <returns>An <see cref="T:Neon.Temporal.ExternalWorkflowFuture`1"/> that can be used to retrieve the workflow result as an <c>object</c>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the workflow has already been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            and the result type are compatible with the target workflow method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the workflow.
            </summary>
            <param name="signalName">
            The signal name as defined by the <see cref="T:Neon.Temporal.SignalMethodAttribute"/>
            decorating the workflow signal method.
            </param>
            <param name="args">The signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the child workflow has not been started.</exception>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.  No compile-time type checking
            is performed for this method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.SyncSignalAsync(System.String,System.Object[])">
            <summary>
            <b>EXPERIMENTAL:</b> This method synchronously signals the workflow and returns
            only after the workflow has processed received and processed the signal as opposed
            to <see cref="M:Neon.Temporal.WorkflowFutureStub`1.SignalAsync(System.String,System.Object[])"/> which is fire-and-forget and does not wait for the
            signal to be processed.
            </summary>
            <param name="signalName">
            The signal name as defined by the <see cref="T:Neon.Temporal.SignalMethodAttribute"/>
            decorating the workflow signal method.
            </param>
            <param name="args">The signal arguments.</param>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.  No compile-time type checking
            is performed for this method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.SyncSignalAsync``1(System.String,System.Object[])">
            <summary>
            <b>EXPERIMENTAL:</b> This method synchronously signals the workflow and returns
            the signal result only after the workflow has processed received and processed the 
            signal as opposed to <see cref="M:Neon.Temporal.WorkflowFutureStub`1.SignalAsync(System.String,System.Object[])"/> which is fire-and-forget and does 
            not wait for the signal to be processed and cannot return a result.
            </summary>
            <typeparam name="TResult">The signal result type.</typeparam>
            <param name="signalName">
            The signal name as defined by the <see cref="T:Neon.Temporal.SignalMethodAttribute"/>
            decorating the workflow signal method.
            </param>
            <param name="args">The signal arguments.</param>
            <returns>The signal result.</returns>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters passed
            are compatible with the target workflow arguments.  No compile-time type checking
            is performed for this method.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowFutureStub`1.QueryAsync``1(System.String,System.Object[])">
            <summary>
            Queries the workflow.
            </summary>
            <typeparam name="TQueryResult">The query result type.</typeparam>
            <param name="queryName">Identifies the query.</param>
            <param name="args">The query arguments.</param>
            <returns>The query result.</returns>
            <remarks>
            <note>
            <b>IMPORTANT:</b> You need to take care to ensure that the parameters and
            result type passed are compatible with the target workflow query arguments.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.WorkflowIdReusePolicy">
            <summary>
            Enumerates the workflow ID reuse policies.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicateFailedOnly">
            <summary>
            Allows starting a workflow with the same ID as another workflow when
            that workflow is not running and the last execution close state 
            is in [terminated, cancelled, timeout, failed].
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowIdReusePolicy.AllowDuplicate">
            <summary>
            Allows starting a workflow with the same ID as another workflow when
            that workflow is not running for any reason.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowIdReusePolicy.RejectDuplicate">
            <summary>
            Prohibits starting a workflow with the same ID as another workflow,
            whether that workflow is running or not.
            </summary>
        </member>
        <member name="F:Neon.Temporal.WorkflowIdReusePolicy.UseDefault">
            <summary>
            Indicates that the reuse policy specified by <see cref="P:Neon.Temporal.StartWorkflowOptions.WorkflowIdReusePolicy"/>
            or <see cref="P:Neon.Temporal.TemporalSettings.WorkflowIdReusePolicy"/> should be used.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowInterfaceAttribute">
            <summary>
            Used to tag workflow interfaces and optionally specify the task queue
            identifying the workers hosting this workflow.  <see cref="T:Neon.Temporal.TemporalClient"/>
            for more information on how task lists work.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowInterfaceAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowInterfaceAttribute.Namespace">
            <summary>
            Optionally specifies the Temporal namespace where the workflow is registered.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowInterfaceAttribute.TaskQueue">
            <summary>
            Optionally specifies the Temporal task queue identifying the workers
            hosting this workflow.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowMethodAttribute">
            <summary>
            Used to identify a workflow interface method as a workflow entry point.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodAttribute.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.Name">
            <summary>
            Specifies the name to be used to identify a specific workflow method.  This is optional
            for workflow interfaces that have only one workflow entry point method but is required
            for interfaces with multiple entry points.
            </summary>
            <remarks>
            <para>
            When specified, this name will be combined with the workflow type name when registering
            and executing a workflow started via the method.  This will typically look like:
            </para>
            <code>
            WORKFLOW_TYPENAME::METHODNAME
            </code>
            <para>
            where <b>WORKFLOW_TYPENAME</b> defaults to the the workflow interface's fully qualified 
            name, with any leading "I" character removed and <b>METHOD_NAME</b> is from
            <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Name"/>.  This is the same convention implemented by 
            the Java client.
            </para>
            <note>
            Settings <see cref="P:Neon.Temporal.WorkflowMethodAttribute.IsFullName"/><c>true</c> specifies that <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Name"/>
            by itself specifies the workflow type name so you can easily interoperate with other
            clients and type naming conventions.
            </note>
            <para>
            Sometimes it's useful to be able to specify a workflow type name that doesn't
            follow the convention above, for example to interoperate with workflows written
            in another language..  You can do this by setting <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Name"/> to the
            required workflow type name and then setting <see cref="P:Neon.Temporal.WorkflowMethodAttribute.IsFullName"/><c>=true</c>.
            </para>
            </remarks>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.IsFullName">
            <summary>
            <para>
            Optionally indicates that <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Name"/> holds the fully qualified type name for
            the workflow and that the .NET client will not add a prefix to <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Name"/>
            when registering the workflow.
            </para>
            <para>
            This is useful when interoperating with workflows written in another language by
            providing a way to specify a specific workflow type name. 
            </para>
            <note>
            <see cref="P:Neon.Temporal.WorkflowMethodAttribute.Name"/> cannot be <c>null</c> or empty when this is <c>true</c>.
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.WorkflowExecutionTimeoutSeconds">
            <summary>
            Optionally specifies the maximum workflow execution time.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.WorkflowTaskTimeoutSeconds">
            <summary>
            Optionally specifies the maximum execution time for an individual workflow decision
            task.  The maximum possible duration is <b>60 seconds</b>.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.WorkflowRunTimeoutSeconds">
            <summary>
            Optionally specifies the maximum time a workflow can wait
            between being scheduled and being actually executed on a
            worker.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.TaskQueue">
            <summary>
            Optionally specifies the target Temporal task queue.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.Namespace">
            <summary>
            Optionally specifies the target Temporal namespace.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.WorkflowId">
            <summary>
            Optionally specifies the workflow ID.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.WorkflowIdReusePolicy">
            <summary>
            Specifies the workflow ID reuse policy.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodAttribute.CronSchedule">
            <summary>
            Optionally specifies a recurring schedule for the workflow method.  This can be set to a string specifying
            the minute, hour, day of month, month, and day of week scheduling parameters using the standard Linux
            CRON format described here: <a href="https://en.wikipedia.org/wiki/Cron">https://en.wikipedia.org/wiki/Cron</a>
            </summary>
            <remarks>
            <para>
            Temporal accepts a CRON string formatted as a single line of text with 5 parameters separated by
            spaces.  The parameters specified the minute, hour, day of month, month, and day of week values:
            </para>
            <code>
             minute (0 - 59)
              hour (0 - 23)
               day of the month (1 - 31)
                month (1 - 12)
                 day of the week (0 - 6) (Sunday to Saturday)
                
                
            * * * * * 
            </code>
            <para>
            Each parameter may be set to one of:
            </para>
            <list type="table">
            <item>
                <term><b>*</b></term>
                <description>
                Matches any value.
                </description>
            </item>
            <item>
                <term><b>value</b></term>
                <description>
                Matches a specific integer value.
                </description>
            </item>
            <item>
                <term><b>value1-value2</b></term>
                <description>
                Matches a range of values to be matched (inclusive).
                </description>
            </item>
            <item>
                <term><b>value1,value2,...</b></term>
                <description>
                Matches a list of values to be matched.
                </description>
            </item>
            <item>
                <term><b>value1/value2</b></term>
                <description>
                Matches values starting at <b>value1</b> and then those incremented by <b>value2</b>.
                </description>
            </item>
            </list>
            <para>
            You can use this handy CRON calculator to see how this works: <a href="https://crontab.guru">https://crontab.guru</a>
            </para>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.WorkflowMethodMap">
            <summary>
            Maps workflow query and signal names to the methods implementing the queries
            and signals for a given workflow interface.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodMap.Create(System.Type)">
            <summary>
            Constructs a query/signal method map for a workflow type.
            </summary>
            <param name="workflowType">The workflow type.</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowMethodMap"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodMap.#ctor">
            <summary>
            Private constructor.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodMap.GetSignalMethod(System.String)">
            <summary>
            Returns the <see cref="T:System.Reflection.MethodInfo"/> for the handler for a given signal.
            </summary>
            <param name="name">Ths signal name.</param>
            <returns>
            The <see cref="T:System.Reflection.MethodInfo"/> for the handler or <c>null</c> when there
            is no handler for the named signal.
            </returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodMap.GetQueryMethod(System.String)">
            <summary>
            Returns the <see cref="T:System.Reflection.MethodInfo"/> for the handler for a given query.
            </summary>
            <param name="name">Ths query name.</param>
            <returns>
            The <see cref="T:System.Reflection.MethodInfo"/> for the handler or <c>null</c> when there
            is no handler for the named query.
            </returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodMap.GetSignalNames">
            <summary>
            Returns the names of the mapped signals.
            </summary>
            <returns>The signal name list.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowMethodMap.GetQueryTypes">
            <summary>
            Returns the names of the mapped queries.
            </summary>
            <returns>The query name list.</returns>
        </member>
        <member name="P:Neon.Temporal.WorkflowMethodMap.HasSynchronousSignals">
            <summary>
            Returns <c>true</c> if the workflow defines any synchronous signals.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowQueue`1">
            <summary>
            Implements a workflow-safe first-in-first-out (FIFO) queue that can be used by
            workflow signal methods to communicate with the running workflow logic.
            </summary>
            <typeparam name="T">Specifies the type of the queued items.</typeparam>
            <remarks>
            <para>
            You can construct workflow queue instances in your workflows via
            <see cref="M:Neon.Temporal.Workflow.NewQueueAsync``1(System.Int32)"/>, optionally specifying 
            the maximum capacity of the queue.  This defaults to <see cref="F:Neon.Temporal.WorkflowQueue`1.DefaultCapacity"/>
            and may not be less that 2 queued items.
            </para>
            <para>
            Items are added to the queue via <see cref="M:Neon.Temporal.WorkflowQueue`1.EnqueueAsync(`0)"/>.  This
            method will return immediately when the number of items currently in
            the queue is less than the capacity, otherwise the operation will block
            until an item has been dequeued and the queue is no longer full.
            </para>
            <note>
            Serialized item sizes must be less than 64 KiB.
            </note>
            <para>
            Use <see cref="M:Neon.Temporal.WorkflowQueue`1.DequeueAsync(System.TimeSpan)"/> to read from the queue using
            an optional timeout.
            </para>
            <note>
            <para>
            The <see cref="T:Neon.Temporal.WorkflowQueue`1"/> class is intended only for two scenarios
            within an executing workflow:
            </para>
            <list type="number">
                <item>
                <b>Workflow Entry Point:</b> Workflow entry points have full access queues 
                including creating, closing, reading, writing, and fetching the length.
                </item>
                <item>
                <b>Workflow Signal:</b> Workflow signal methods have partial access to
                queues including closing, writing, and fetching the length.  Signals 
                cannot create or read from queues.
                </item>
                </list>
            </note>
            </remarks>
        </member>
        <member name="F:Neon.Temporal.WorkflowQueue`1.DefaultCapacity">
            <summary>
            The default maximum number of items allowed in a queue.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.#ctor(Neon.Temporal.Workflow,System.Int64,System.Int32)">
            <summary>
            Internal constructor.
            </summary>
            <param name="parentWorkflow">The parent workflow.</param>
            <param name="queueId">The queue ID.</param>
            <param name="capacity">The maximum number of items allowed in the queue.</param>
            <exception cref="T:System.NotSupportedException">Thrown when this is called outside of a workflow entry point method.</exception>
            <remarks>
            <note>
            <see cref="T:Neon.Temporal.WorkflowQueue`1"/> instances may only be created within 
            workflow entry point methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.Dispose">
            <summary>
            Closes the queue if it's not already closed.
            </summary>
            <remarks>
            <note>
            Queues may be disposed only from within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.Dispose(System.Boolean)">
            <summary>
            Releases all associated resources.
            </summary>
            <param name="disposing">Pass <c>true</c> if we're disposing, <c>false</c> if we're finalizing.</param>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.CheckDisposed">
            <summary>
            Ensures that the instance is not disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
        </member>
        <member name="P:Neon.Temporal.WorkflowQueue`1.Capacity">
            <summary>
            Returns the maximum number of items allowed in the queue at any given moment.
            This may not be set to a value less than 2.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.EnqueueAsync(`0)">
            <summary>
            Adds an item to the queue.
            </summary>
            <param name="item">The item.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the serialized size of <paramref name="item"/> is not less than 64KiB.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:Neon.Temporal.WorkflowQueueClosedException">Thrown if the associated queue has been closed.</exception>
            <remarks>
            <para>
            This method returns immediately if the queue is not full, otherwise
            it will block until there's enough space to append the new item.
            </para>
            <note>
            Item data after being serialized must be less than 64 KiB.
            </note>
            </remarks>
            <remarks>
            <note>
            Items may be added to queues only within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.TryEnqueueAsync(`0)">
            <summary>
            Attempts to add an item to the queue.  Unlike <see cref="M:Neon.Temporal.WorkflowQueue`1.EnqueueAsync(`0)"/>, this method
            does not block when the queue is full and returns <c>false</c> instead.
            </summary>
            <param name="item">The item.</param>
            <returns><c>true</c> if the item was written or <c>false</c> if the queue is full and the item was not written.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the serialized size of <paramref name="item"/> is not less than 64KiB.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:Neon.Temporal.WorkflowQueueClosedException">Thrown if the associated queue has been closed.</exception>
            <remarks>
            <note>
            Item data after being serialized must be less than 64 KiB.
            </note>
            </remarks>
            <remarks>
            <note>
            Items may be added to queues only within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.DequeueAsync(System.TimeSpan)">
            <summary>
            Attempts to dequeue an item from the queue with an optional timeout.
            </summary>
            <param name="timeout">The optional timeout.</param>
            <returns>The next item from the queue.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <exception cref="T:Neon.Temporal.TemporalTimeoutException">Thrown if the timeout was reached before a value could be returned.</exception>
            <exception cref="T:Neon.Temporal.WorkflowQueueClosedException">Thrown if the the queue is closed.</exception>
            <remarks>
            <note>
            Items may be read from queues only from within workflow entrypoint methods.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowQueue`1.CloseAsync">
            <summary>
            <para>
            Closes the queue.
            </para>
            <note>
            This does nothing if the queue is already closed.
            </note>
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Thrown if the associated workflow client is disposed.</exception>
            <exception cref="T:System.ObjectDisposedException">Thrown if the queue is disposed.</exception>
            <remarks>
            <note>
            Queues may be closed only from within workflow entrypoint or signal methods.
            </note>
            </remarks>
        </member>
        <member name="T:Neon.Temporal.WorkflowStub">
            <summary>
            Implements an untyped client side stub to a single external workflow instance.  This can 
            be used to invoke, signal, query, and cancel a workflow when the actual workflow 
            interface isn't available.
            </summary>
        </member>
        <member name="T:Neon.Temporal.WorkflowStub.IHelperActivity">
            <summary>
            Defines the helper methods used to perform external stub operations
            as a local activity so they can be replayed from history.
            </summary>
            <remarks>
            <note>
            These methods are going to use byte arrays to receive arguments from
            the caller and also to return results.  These will use the current
            data converter for encoding.
            </note>
            </remarks>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.IHelperActivity.CancelAsync(System.String,System.String)">
            <summary>
            Cancels an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.IHelperActivity.GetResultAsync(System.String,System.String)">
            <summary>
            Waits for and returns the result for an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <returns>The encoded workflow result.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.IHelperActivity.QueryAsync(System.String,System.String,System.String,System.Byte[])">
            <summary>
            Queries an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <param name="queryType">Identifies the query.</param>
            <param name="args">The encoded query arguments.</param>
            <returns>The encode query result.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.IHelperActivity.SignalAsync(System.String,System.String,System.String,System.Byte[])">
            <summary>
            Signals an external workflow.
            </summary>
            <param name="workflowId">The target workflow ID.</param>
            <param name="runId">The target runID.</param>
            <param name="signalName">Identifies the signal.</param>
            <param name="args">The encoded signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="T:Neon.Temporal.WorkflowStub.HelperActivity">
            <summary>
            Implements <see cref="T:Neon.Temporal.WorkflowStub.IHelperActivity"/>.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.FromTypedAsync(System.Object)">
            <summary>
            <para>
            Returns the untyped <see cref="T:Neon.Temporal.WorkflowStub"/> from a typed stub.
            </para>
            <note>
            This works only for external workflow stubs (not child stubs) and only for
            stubs that have already been started.
            </note>
            </summary>
            <param name="stub">The source typed workflow stub.</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowStub"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.#ctor(Neon.Temporal.TemporalClient,System.Boolean)">
            <summary>
            Default internal constructor.
            </summary>
            <param name="client">The associated client.</param>
            <param name="withinWorkflow">
            Optionally indicates that the stub was created from within a workflow and that 
            operations such as get result, query, signal, and cancel must be performed
            within local activities such that that can be replayed from history correctly.
            </param>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.#ctor(Neon.Temporal.TemporalClient,System.String,Neon.Temporal.WorkflowExecution,Neon.Temporal.StartWorkflowOptions)">
            <summary>
            Used to construct an untyped workflow stub that can be used to start an external workflow.
            </summary>
            <param name="client">The associated client.</param>
            <param name="workflowTypeName">The workflow type name.</param>
            <param name="execution">The workflow execution.</param>
            <param name="options">The workflow options.</param>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.#ctor(Neon.Temporal.TemporalClient,Neon.Temporal.WorkflowExecution,System.Boolean)">
            <summary>
            Used to construct an untyped workflow stub that can manage an existing external workflow.
            </summary>
            <param name="client">The associated client.</param>
            <param name="execution">The workflow execution.</param>
            <param name="withinWorkflow">
            Optionally indicates that the stub was created from within a workflow and that 
            operations such as get result, query, signal, and cancel must be performed
            within local activities such that that can be replayed from history correctly.
            </param>
        </member>
        <member name="P:Neon.Temporal.WorkflowStub.WorkflowTypeName">
            <summary>
            <para>
            Returns the workflow type name.
            </para>
            <note>
            <para>
            .NET and Java workflows can implement multiple workflow method using attributes
            and annotations to assign unique names to each.  Each workflow method is actually
            registered with Temporal as a distinct workflow type.  Workflow methods with a blank
            or <c>null</c> name will simply be registered using the workflow type name.
            </para>
            <para>
            Workflow methods with a name will be registered using a combination  of the workflow
            type name and the method name, using <b>"::"</b> as the separator, like:
            </para>
            <code>
            WORKFLOW-TYPENAME::METHOD-NAME
            </code>
            </note>
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowStub.Execution">
            <summary>
            Returns the workflow execution.
            </summary>
        </member>
        <member name="P:Neon.Temporal.WorkflowStub.Options">
            <summary>
            Returns the workflow options.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.EnsureStarted">
            <summary>
            Ensures that the workflow has been started.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.EnsureNotStarted">
            <summary>
            Ensures that the workflow has not been started.
            </summary>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.CancelAsync">
            <summary>
            Attempts to cancel the associated workflow.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.GetResultAsync">
            <summary>
            Waits for the workflow to complete or throws an error exception.  Use this for 
            workflows that don't return a result.
            </summary>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.GetResultAsync``1">
            <summary>
            Waits for the workflow to complete and then returns the result or throws
            an error exception.  This override accepts the result type as a type parameter.
            </summary>
            <typeparam name="TResult">The result type.</typeparam>
            <returns>The result.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.GetResultAsync(System.Type)">
            <summary>
            Waits for the workflow to complete and then returns the result or throws
            an error exception.  This override accepts the result type as a normal parameter.
            </summary>
            <param name="resultType">Specifies the result type.</param>
            <returns>The result as a <c>dynamic</c>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.QueryAsync``1(System.String,System.Object[])">
            <summary>
            Queries the associated workflow.
            </summary>
            <typeparam name="TResult">The query result type.</typeparam>
            <param name="queryType">Specifies the query type.</param>
            <param name="args">Specifies the query arguments.</param>
            <returns>The query result.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.QueryAsync(System.Type,System.String,System.Object[])">
            <summary>
             Queries the associated workflow specifying the expected result type as
             a parameter.
            </summary>
            <param name="resultType">Specifies the query result type.</param>
            <param name="queryType">Specifies the query type.</param>
            <param name="args">Specifies the query arguments.</param>
            <returns>The query result as a <c>dynamic</c>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.SignalAsync(System.String,System.Object[])">
            <summary>
            Signals the associated workflow.
            </summary>
            <param name="signalName">Specifies the signal name.</param>
            <param name="args">Specifies the signal arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.SignalWithStartAsync(System.String,System.Object[],System.Object[])">
            <summary>
            Signals the associated workflow, starting it if it hasn't already been started.
            </summary>
            <param name="signalName">Specifies the signal name.</param>
            <param name="signalArgs">Specifies the signal arguments.</param>
            <param name="startArgs">Specifies the workflow start arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.StartAsync(System.Object[])">
            <summary>
            Starts the associated workflow.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.StartAsync(System.Byte[])">
            <summary>
            <b>INTERNAL USE ONLY:</b> Used internally for unit tests that need to control
            how the workflow arguments are encoded.
            </summary>
            <param name="argBytes">The encoded workflow arguments.</param>
            <returns>The <see cref="T:Neon.Temporal.WorkflowExecution"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.ExecuteAsync(System.Object[])">
            <summary>
            Executes the associated workflow and waits for it to complete.
            </summary>
            <param name="args">The workflow arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
        <member name="M:Neon.Temporal.WorkflowStub.ExecuteAsync``1(System.Object[])">
            <summary>
            Executes the associated workflow and waits for it to complete,
            returning the workflow result.
            </summary>
            <typeparam name="TResult">The workflow result type.</typeparam>
            <param name="args">The workflow arguments.</param>
            <returns>The tracking <see cref="T:System.Threading.Tasks.Task"/>.</returns>
        </member>
    </members>
</doc>
