//-----------------------------------------------------------------------------
// FILE:	    GenerateKubernetesWithRetry.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:	Copyright (c) 2005-2021 by neonFORGE LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Diagnostics.Contracts;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using k8s;

using Neon.Common;

namespace Prebuilder
{
    /// <summary>
    /// Generates a wrapper for the <see cref="Kubernetes"/> client class, including
    /// additional retry logic.
    /// </summary>
    public static class GenerateKubernetesWithRetry
    {
        /// <summary>
        /// Implements the <b>kubernetes-wrapper</b> class.
        /// </summary>
        /// <param name="commandLine">The command line.</param>
        public static void Run(CommandLine commandLine)
        {
            const string wrapperClassName = "KubernetesWithRetry";

            var targetPath      = commandLine.Arguments.ElementAtOrDefault(0);
            var targetNamespace = commandLine.Arguments.ElementAtOrDefault(1);
            var kubernetesType  = typeof(Kubernetes);

            if (string.IsNullOrEmpty(targetPath))
            {
                Console.Error.WriteLine("*** ERROR: TARGET-PATH argument is required.");
                Program.Exit(1);
            }

            if (string.IsNullOrEmpty(targetNamespace))
            {
                Console.Error.WriteLine("*** ERROR: NAMESPACE argument is required.");
                Program.Exit(1);
            }

            using (var writer = new StreamWriter(targetPath))
            {
                //-----------------------------------------------------------------
                // Generate the file header and opening namespace statement as well
                // as the opening class definition.

                writer.WriteLine(
$@"//-----------------------------------------------------------------------------
// FILE:	    {Path.GetFileName(targetPath)}.cs
// CONTRIBUTOR: Auto-generated by [prebuilder] tool during pre-build event
// COPYRIGHT:	Copyright (c) 2005-2021 by neonFORGE LLC.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// WARNING: This file is automatically generated during the build.
//          Do not edit this manually.

#pragma warning disable CS1591  // Missing XML comment

using System;
using System.IO;
using System.Linq;
using System.Text;

using k8s;

using Neon.Common;
using Neon.Retry;

namespace {targetNamespace}
{{
    /// <summary>
    /// Wraps the standard <see cref=""Kubernetes""/> class by adding support for an
    /// <see cref=""IRetryPolicy""/> for all instance method calls.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This is intended to be a drop-in replacement for the <see cref=""Kubernetes""/> class,
    /// adding support for an optional <see cref=""IRetryPolicy""/> for all instance method calls.
    /// </para>
    /// <para>
    /// To use, simply instantiate an instance and assign your custom <see cref=""IRetryPolicy""/>
    /// to the <see cref=""RetryPolicy""/> property.  This property defaults to <see cref=""NoRetryPolicy""/>
    /// which means this class will work exactly like the standard <see cref=""Kubernetes""/> class.
    /// You may change the retry policy at any time. 
    /// </para>
    /// <note>
    /// Static methods don't honor any retry policy.
    /// </note>
    /// </remarks>
    public sealed class {wrapperClassName} : IKubernetes, IDisposable
    {{");
                //-----------------------------------------------------------------
                // Generate the local fields

                writer.WriteLine($"        private Kubernetes      kubernetes;");

                //-----------------------------------------------------------------
                // Generate the public constructors.

                foreach (var constructor in kubernetesType.GetConstructors())
                {
                    var parameters = constructor.GetParameters();

                    writer.WriteLine();
                    writer.WriteLine($"        public {wrapperClassName}({GetParameterDefinition(parameters)})");
                    writer.WriteLine($"        {{");
                    writer.WriteLine($"            kubernetes = new Kubernetes({GetParameterNames(parameters)});");
                    writer.WriteLine($"        }}");
                }

                //-----------------------------------------------------------------
                // Generate the [RetryPolicy] properties.

                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// <para>");
                writer.WriteLine($"        /// The retry policy to be applied public instance method calls.  This may");
                writer.WriteLine($"        /// be modified at anytime and defaults to <see cref=\"NoRetryPolicy\"/>.");
                writer.WriteLine($"        /// </para>");
                writer.WriteLine($"        /// <note>");
                writer.WriteLine($"        /// You may also set this to <c>null</c> which is equivalant to <see cref=\"NoRetryPolicy\"/>.");
                writer.WriteLine($"        /// </note>");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        public IRetryPolicy RetryPolicy {{ get; set; }} = NoRetryPolicy.Instance;");
                writer.WriteLine();
                writer.WriteLine($"        /// <summary>");
                writer.WriteLine($"        /// Returns the <see cref=\"RetryPolicy\"/> or <see cref=\"NoRetryPolicy.Instance\"/> when the current policy is <c>null</c>.");
                writer.WriteLine($"        /// </summary>");
                writer.WriteLine($"        private IRetryPolicy NormalizedRetryPolicy => RetryPolicy ?? NoRetryPolicy.Instance;");

                //-----------------------------------------------------------------
                // Generate the [Dispose()] method.

                writer.WriteLine();
                writer.WriteLine($"        /// <inheritdoc/>");
                writer.WriteLine($"        public void Dispose()");
                writer.WriteLine($"        {{");
                writer.WriteLine($"             kubernetes.Dispose();");
                writer.WriteLine($"        }}");

                //-----------------------------------------------------------------
                // Generate the public properties.

                foreach (var property in kubernetesType.GetProperties())
                {
                    var getter    = property.GetGetMethod();
                    var setter    = property.GetSetMethod();
                    var accessors = new StringBuilder();

                    if (getter != null)
                    {
                        accessors.AppendWithSeparator("get;");
                    }

                    if (setter != null)
                    {
                        accessors.AppendWithSeparator("set;");
                    }

                    writer.WriteLine();
                    writer.WriteLine("         /// <inheritdoc/>");
                    writer.WriteLine($"        public {ResolveTypeReference(property.PropertyType, isResultType: true)} {property.Name} {{ {accessors} }}");
                }

                //-----------------------------------------------------------------
                // Generate wrappers for the public static methods.

                foreach (var method in kubernetesType.GetMethods(BindingFlags.Public | BindingFlags.Static))
                {
                    var parameters = method.GetParameters();

                    writer.WriteLine();
                    writer.WriteLine($"        /// <inheritdoc/>");
                    writer.WriteLine($"        public static {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)})");
                    writer.WriteLine($"        {{");

                    if (method.ReturnType == typeof(void))
                    {
                        writer.WriteLine($"            {ResolveTypeReference(kubernetesType)}.{method.Name}({GetParameterNames(parameters)});");
                    }
                    else
                    {
                        writer.WriteLine($"            return {ResolveTypeReference(kubernetesType)}.{method.Name}({GetParameterNames(parameters)});");
                    }

                    writer.WriteLine($"        }}");
                }

                //-----------------------------------------------------------------
                // Generate wrappers for the public instance methods.

                foreach (var method in kubernetesType.GetMethods(BindingFlags.Public | BindingFlags.Instance))
                {
                    if (method.Attributes.HasFlag(MethodAttributes.SpecialName))
                    {
                        // Don't generate the property getter/setter methods.

                        continue;
                    }

                    var parameters  = method.GetParameters();
                    var isAsync     = method.ReturnType == typeof(Task) || method.ReturnType.ToString().StartsWith("System.Threading.Tasks.Task`");
                    
                    if (isAsync)
                    {
                        writer.WriteLine(); ;
                        writer.WriteLine($"        /// <inheritdoc/>");
                        writer.WriteLine($"        public async {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)})");
                        writer.WriteLine($"        {{");

                        if (method.ReturnType == typeof(void))
                        {
                            writer.WriteLine($"            await NormalizedRetryPolicy.Invoke(");
                            writer.WriteLine($"                async () =>");
                            writer.WriteLine($"                {{");
                            writer.WriteLine($"                    await kubernetes.{method.Name}({GetParameterNames(parameters)});");
                            writer.WriteLine($"                }});");
                        }
                        else
                        {
                            writer.WriteLine($"            return await NormalizedRetryPolicy.Invoke(");
                            writer.WriteLine($"                async () =>");
                            writer.WriteLine($"                {{");
                            writer.WriteLine($"                    return await kubernetes.{method.Name}({GetParameterNames(parameters)});");
                            writer.WriteLine($"                }});");
                        }
                    }
                    else
                    {
                        writer.WriteLine();
                        writer.WriteLine($"        /// <inheritdoc/>");
                        writer.WriteLine($"        public {ResolveTypeReference(method.ReturnType, isResultType: true)} {method.Name}{GetGenericArgsDefinition(method)}({GetParameterDefinition(parameters)})");
                        writer.WriteLine($"        {{");

                        if (method.ReturnType == typeof(Task))
                        {
                            writer.WriteLine($"            NormalizedRetryPolicy.Invoke(");
                            writer.WriteLine($"                () =>");
                            writer.WriteLine($"                {{");
                            writer.WriteLine($"                    kubernetes.{method.Name}({GetParameterNames(parameters)});");
                            writer.WriteLine($"                }});");
                        }
                        else
                        {
                            writer.WriteLine($"            return NormalizedRetryPolicy.Invoke(");
                            writer.WriteLine($"                () =>");
                            writer.WriteLine($"                {{");
                            writer.WriteLine($"                    return kubernetes.{method.Name}({GetParameterNames(parameters)});");
                            writer.WriteLine($"                }});");
                        }
                    }

                    writer.WriteLine($"        }}");
                }

                //-----------------------------------------------------------------
                // Close the class and namespace definitions.

                writer.WriteLine($"    }}");
                writer.WriteLine($"}}");
            }
        }

        /// <summary>
        /// Some parameter names are C# reserved words and need to have and <b>@</b>
        /// sign prepended.
        /// </summary>
        /// <param name="name">The parameter name.</param>
        /// <returns>The noprmalized name.</returns>
        private static string NormalizeParameterName(string name)
        {
            switch (name)
            {
                case "namespace":   return "@namespace";
                case "continue":    return "@continue";
                default:            return name;
            }
        }

        /// <summary>
        /// Converts an array of reflected parameter info into a C# parameter
        /// definition.
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The C# parameter definition source code.</returns>
        private static string GetParameterDefinition(ParameterInfo[] parameters)
        {
            var sb = new StringBuilder();

            foreach (var parameter in parameters)
            {
                var typeReference      = ResolveTypeReference(parameter.ParameterType);
                var hasParamsAttribute = parameter.GetCustomAttribute<ParamArrayAttribute>() != null;

                if (hasParamsAttribute)
                {
                    sb.AppendWithSeparator($"params {typeReference} {NormalizeParameterName(parameter.Name)}", ", ");
                }
                else
                {
                    sb.AppendWithSeparator($"{typeReference} {NormalizeParameterName(parameter.Name)}", ", ");
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Returns the C# generic type definition for generic methods and an
        /// empty string for everything else.
        /// </summary>
        /// <param name="method">The target method.</param>
        /// <returns>The C# generic type definition.</returns>
        private static string GetGenericArgsDefinition(MethodInfo method)
        {
            // $todo(jefflill): This doesn't handle nested generic types.

            if (method.IsGenericMethod)
            {
                var genericArgs = method.GetGenericArguments();
                var sbArgs      = new StringBuilder();

                foreach (var arg in genericArgs)
                {
                    sbArgs.AppendWithSeparator(arg.Name, ", ");
                }

                return $"<{sbArgs}>";
            }
            else
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// Returns the comma separated parameter names.
        /// </summary>
        /// <param name="parameters">The parameters.</param>
        /// <returns>The parameter names.</returns>
        private static string GetParameterNames(ParameterInfo[] parameters)
        {
            var sb = new StringBuilder();

            foreach (var parameter in parameters)
            {
                sb.AppendWithSeparator($"{NormalizeParameterName(parameter.Name)}", ", ");
            }

            return sb.ToString();
        }

        /// <summary>
        /// Returns the C# source string used to reference a type.
        /// </summary>
        /// <param name="type">The target type.</param>
        /// <returns>The type reference.</returns>
        private static string GetTypeName(Type type)
        {
            // Convert common types into their C# equivents:

            var typeName = type.FullName;

            switch (typeName)
            {
                case "System.Void":     return "void";
                case "System.Byte":     return "byte";
                case "System.SByte":    return "sbyte";
                case "System.Int16":    return "short";
                case "System.UInt16":   return "ushort";
                case "System.Int32":    return "int";
                case "System.UInt32":   return "uint";
                case "System.Int64":    return "long";
                case "System.UInt64":   return "ulong";
                case "System.Float":    return "float";
                case "System.Double":   return "double";
                case "System.String":   return "string";
                case "System.Boolean":  return "bool";
                case "System.Decimal":  return "decimal";
            }

            // We're going to use the global namespace to avoid namespace conflicts and we're
            // going to // Remove the special generic "`1...", syntax if present.

            typeName = type.ToString();

            var backTickPos = typeName.IndexOf('`');

            if (backTickPos != -1)
            {
                typeName = typeName.Substring(0, backTickPos);
            }

            if (type.IsGenericParameter)
            {
                return typeName;
            }
            else
            {
                return $"global::{typeName}";
            }
        }

        /// <summary>
        /// Resolves the type passed into a nice string taking generic types 
        /// and arrays into account.
        /// </summary>
        /// <param name="type">The referenced type.</param>
        /// <param name="isResultType">Optionally allow the <c>void</c> and related types (used for service method results).</param>
        /// <returns>The type reference as a string or <c>null</c> if the type is not valid.</returns>
        private static string ResolveTypeReference(Type type, bool isResultType = false)
        {
            if (isResultType)
            {
                if (type == typeof(void) || (type == typeof(Task)))
                {
                    // These types are all essentially a way of specifying [void].

                    return "void";
                }
                else if (type.IsGenericType)
                {
                    // We need to extract the type parameter from [Task<T>] or
                    // [ActionResult<T>] as a special case.

                    var typeRef = GetTypeName(type);

                    switch (typeRef)
                    {
                        case "Task":
                        case "ActionResult":

                            type = type.GenericTypeArguments.First();
                            break;
                    }
                }
            }

            if (type == typeof(void))
            {
                // This is not a valid member or parameter type.

                return null;
            }

            if (type.IsPrimitive || !type.IsArray && !type.IsGenericType)
            {
                return GetTypeName(type);
            }

            if (type.IsArray)
            {
                // We need to handle jagged arrays where the element type 
                // is also an array.  We'll accomplish this by walking down
                // the element types until we get to a non-array element type,
                // counting how many subarrays there were.

                var arrayDepth  = 0;
                var elementType = type.GetElementType();

                while (elementType.IsArray)
                {
                    arrayDepth++;
                    elementType = elementType.GetElementType();
                }

                var arrayRef = ResolveTypeReference(elementType);

                for (int i = 0; i <= arrayDepth; i++)
                {
                    arrayRef += "[]";
                }

                return arrayRef;
            }
            else if (type.IsGenericType)
            {
                if (type.Name.StartsWith("System.Nullable`"))
                {
                    // Special-case Nullable<T> by appending a "?".

                    var nullableType = type.GenericTypeArguments.First();

                    return $"{GetTypeName(nullableType)}?";
                }
                else
                {
                    var genericRef    = GetTypeName(type);
                    var genericParams = string.Empty;

                    foreach (var genericParamType in type.GetGenericArguments())
                    {
                        if (genericParams.Length > 0)
                        {
                            genericParams += ", ";
                        }

                        genericParams += ResolveTypeReference(genericParamType);
                    }

                    return $"{genericRef}<{genericParams}>";
                }
            }

            Covenant.Assert(false); // We should never get here.
            return null;
        }
    }
}
